<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-01T13:34:46.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单一功能原则</title>
    <link href="http://yoursite.com/2016/05/01/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2016/05/01/单一功能原则/</id>
    <published>2016-05-01T13:29:49.000Z</published>
    <updated>2016-05-01T13:34:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个术语由&lt;strong&gt;罗伯特·C·马丁（Robert Cecil Martin）&lt;/strong&gt;在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。&lt;/p&gt;
&lt;p&gt;马丁表述该原则是基于的《结构化分析和系统规格》一书中的内聚原则（Cohesion）上。&lt;/p&gt;
&lt;p&gt;马丁把功能（职责）定义为：“&lt;strong&gt;改变的原因&lt;/strong&gt;”，并且总结出一个类或者模块应该&lt;strong&gt;有且只有一个&lt;/strong&gt;改变的原因。&lt;/p&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一，报表的内容可以改变（编辑）。
第二，报表的格式可以改变（打印）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。&lt;br&gt;单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。&lt;br&gt;
    
    </summary>
    
    
      <category term="［类的魔法］" scheme="http://yoursite.com/tags/%EF%BC%BB%E7%B1%BB%E7%9A%84%E9%AD%94%E6%B3%95%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>基本文件操作filehandle的用法</title>
    <link href="http://yoursite.com/2016/04/29/%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cfilehandle%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/29/基本文件操作filehandle的用法/</id>
    <published>2016-04-29T12:57:38.000Z</published>
    <updated>2016-04-29T13:00:52.000Z</updated>
    
    <content type="html">&lt;p&gt;利用NSFilehandle类提供的方法，允许更有效地使用文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一般而言，处理文件时都要经历以下三个步骤：

1.打开文件，并获取一个NSFileHandle对象，以便在后面的I/O操作中引用该文件

2.对打开的文件执行I/O操作（读取、写入、更新）

3.关闭文件
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; NSFileHandle用于以标准输入、标准输出、标准错误和空设置的方法。他们的格式为fileHandleWithDevice，其中Device可以是StandardInput、StandardOutput、StandardError或者NullDevice。&lt;/p&gt;
&lt;p&gt; 应该注意到，&lt;strong&gt;NSFileHandle类并没有提供创建文件的功能&lt;/strong&gt;。必须使用NSFileManager方法来创建文件。因此，方法 fileHandleForWritingAtPath：和 hfileHandleUpdatingAtPath：都假定文件已经存在，否则返回nil。对于这两个方法，文件的偏移量都设为文件的开始，所以都是在文件的开始位置开始写入（或更新模式的读取）&lt;/p&gt;
&lt;p&gt; NSFileHandle常用方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(NSFileHandle*)fileHandleForReadingAtPath:path 打开一个文件用于读入

+(NSFileHandle*)fileHandleForWritingAtPath:path 打开一个文件用于写入

+(NSFileHandle*)fileHandleForUpdatingAtPath:path 打开一个文件用于读写

-(NSData*)availableData 从设备或者通道返回可用数据

-(NSData*)readDataToEndOfFile 读取其余的数据知道文件的末尾(最多UINT_MAX字节)

-(NSData*)readDataOfLength:(NSUInteger)bytes 从文件中读取指定字节的内容

-(void)writeData:data  将data写入文件

-(unsigned long long)offsetInFile 获取当前偏移量

-(void)seekToFileOffset:offset  设置偏移量

-(unsigned long long)seekToEndOfFile 将偏移量定位到文件的末尾

-(void)truncateFileAtOffset:offset 讲文件的长度设置为offset字节

-(void)closeFile 关闭文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法fileHandleForWritingAtPath和fileHandleForUpdatingAtPath所指定的文件必须是已经存在的，否则返回nil,另外对于这两个方法中文件的偏移量都是为文件的开始。&lt;/p&gt;
&lt;h3 id=&quot;部分代码&quot;&gt;&lt;a href=&quot;#部分代码&quot; class=&quot;headerlink&quot; title=&quot;部分代码&quot;&gt;&lt;/a&gt;部分代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSFileHandle *inFile, *outFile;
NSData *buffer;

//文件 1
NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
[[NSFileManager defaultManager] createFileAtPath:@&amp;quot;test.txt&amp;quot; contents:data attributes:nil];

//文件2
NSData *data2 = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/123&amp;quot;];
[[NSFileManager defaultManager] createFileAtPath:@&amp;quot;out.txt&amp;quot; contents:data2 attributes:nil];

// 打开test.txt文件用于读取操作
inFile = [NSFileHandle fileHandleForReadingAtPath:@&amp;quot;test.txt&amp;quot;];

// 打开test.txt文件用于写操作
outFile = [NSFileHandle fileHandleForWritingAtPath: @&amp;quot;out.txt&amp;quot;];
outFile = [NSFileHandle fileHandleForUpdatingAtPath:@&amp;quot;out.txt&amp;quot;];

// 读取数据
buffer = [inFile readDataToEndOfFile];
buffer = [inFile readDataOfLength:60];

// 写入数据
[outFile writeData:buffer];

//获取当前文件的偏移量
long long offset =  [outFile offsetInFile];
NSLog(@&amp;quot;offset = %lld&amp;quot;, offset);


//设置当前文件的偏移量
[inFile seekToFileOffset:100];

if(inFile == nil)
{
    NSLog(@&amp;quot;Open of testfile.txt for reading failed!&amp;quot;);
    return 1;
} else {

    buffer = [inFile readDataToEndOfFile];
    NSLog(@&amp;quot;%@&amp;quot;, buffer);
}

//关闭两个文件
[inFile closeFile];
[outFile closeFile];

NSLog(@&amp;quot;%@&amp;quot;, [NSString stringWithContentsOfFile:@&amp;quot;out.txt&amp;quot; encoding:NSUTF8StringEncoding error:nil]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;利用NSFilehandle类提供的方法，允许更有效地使用文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一般而言，处理文件时都要经历以下三个步骤：

1.打开文件，并获取一个NSFileHandle对象，以便在后面的I/O操作中引用该文件

2.对打开的文件执行I/O操作（读取、写入、更新）

3.关闭文件
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2016/04/27/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/04/27/位运算/</id>
    <published>2016-04-27T12:21:31.000Z</published>
    <updated>2016-04-27T12:25:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;头文件中的特别标记&quot;&gt;&lt;a href=&quot;#头文件中的特别标记&quot; class=&quot;headerlink&quot; title=&quot;头文件中的特别标记&quot;&gt;&lt;/a&gt;头文件中的特别标记&lt;/h3&gt;&lt;p&gt;0UL 表示 无符号长整型 0&lt;br&gt;1UL 表示 无符号长整型 1&lt;/p&gt;
&lt;p&gt; 如果不写UL后缀，系统默认为：int, 即，有符号整数。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt; 1.数值常数有：整型常数、浮点常数；&lt;br&gt; 2.只有数值常数才有后缀说明；&lt;br&gt; 3.数值常数后缀不区分字母大小写。&lt;/p&gt;
&lt;p&gt;（1）整型常数的表示形式有：十进制形式、以0开头的八进制形式、以0x开头的十六进制形式，无二进制形式。&lt;br&gt;    整型常数默认是signed int的。&lt;br&gt;    对整型常数进行类型转换的后缀只有：u或U（unsigned）、l或L（long）、u/U与l/L的组合（如：ul、lu、Lu等）。例：100u; -123u; 0x123l;&lt;/p&gt;
&lt;p&gt;（2）浮点常数的表示形式有：科学计数形式和小数点形式。&lt;br&gt;    浮点常数默认是double的。&lt;br&gt;    对浮点常数进行类型转换的后缀只有：f或F（单精度浮点数）、l或L（长双精度浮点数）。（注：因浮点型常数总是有符号的，故没有u或U后缀）。例：1.23e5f; 1.23l; -123.45f;&lt;/p&gt;
&lt;h3 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h3&gt;&lt;p&gt;  在许多计算机编程语言（例如：C语言、C++语言、Java语言、JavaScript语言、Pascal语言等）中，“&amp;gt;&amp;gt;”代表右移运算符，就相当于“shr”。该运算符为双目运算符，结合方向为从左到右，作用是把一个整型数的所有位向右移动指定的位数，移动到右边界之外的多余二进制位会被丢弃，并从左边界移入0。&lt;/p&gt;
&lt;p&gt;  右移运算的两个操作数应为整数类型。第一个操作数是要进行移位操作的数，第二个操作数指定第一个操作数移动的位数。如果第二个操作数等于0则不发生任何移位。&lt;/p&gt;
&lt;p&gt;应用举例：&lt;br&gt;        问：&lt;strong&gt;计算表达式14 &amp;gt;&amp;gt; 2的值&lt;/strong&gt;。&lt;br&gt;        答：表达式14 &amp;gt;&amp;gt; 2的值为3，因为14（即二进制的00001110）向右移两位等于3（即二进制的00000011）。&lt;/p&gt;
&lt;p&gt;  说白了，就是把要移动的数转换成2进制，右移几位就去掉右边的几位数，左移几位就在右边加几个0，比如14右移2位就是转成二进制变成1110，去掉右边的10，变成11，11转成十进制就是3；左移2位就是111000，转成十进制就是56。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,&lt;br&gt;也就是说,枚举值里面存取的是 计算后的十进制值. &lt;/p&gt;
&lt;p&gt;打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论&lt;strong&gt;你如何组合在一起,也不会产生两个同样的数字&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;头文件中的特别标记&quot;&gt;&lt;a href=&quot;#头文件中的特别标记&quot; class=&quot;headerlink&quot; title=&quot;头文件中的特别标记&quot;&gt;&lt;/a&gt;头文件中的特别标记&lt;/h3&gt;&lt;p&gt;0UL 表示 无符号长整型 0&lt;br&gt;1UL 表示 无符号长整型 1&lt;/p&gt;
&lt;p&gt; 如果不写UL后缀，系统默认为：int, 即，有符号整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>字符串加密之Base64</title>
    <link href="http://yoursite.com/2016/04/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%B9%8BBase64/"/>
    <id>http://yoursite.com/2016/04/27/字符串加密之Base64/</id>
    <published>2016-04-27T12:18:00.000Z</published>
    <updated>2016-04-27T12:31:36.000Z</updated>
    
    <content type="html">&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;转码过程例子：

    3*8=4*6
    内存1个字符占8位

    转前： s 1 3

    先转成ascii：对应 115 49 51

    2进制： 01110011 00110001 00110011

    6个一组（4组） 011100110011000100110011

    然后才有后面的 011100 110011 000100 110011

    然后计算机是8位8位的存数 6不够，自动就补两个高位0了
    所有有了 高位补0

    科学计算器输入 00011100 00110011 00000100 00110011

    得到 28 51 4 51
    查对下照表 c z E z
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;关于这个编码的规则：
①.把3个字符变成4个字符。
②.每76个字符加一个换行符。
③.最后的结束符也要处理。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;编码的过程是这样的&quot;&gt;&lt;a href=&quot;#编码的过程是这样的&quot; class=&quot;headerlink&quot; title=&quot;编码的过程是这样的&quot;&gt;&lt;/a&gt;编码的过程是这样的&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 第一个字符通过右移2位获得第一个目标字符的Base64表位置，根据这个数值取到表上相应的字符，就是第一个目标字符。

2. 然后将第一个字符与0x03(00000011)进行与(&amp;amp;)操作并左移4位,接着第二个字符右移4位与前者相或(|)，即获得第二个目标字符。

3. 再将第二个字符与0x0f(00001111)进行与(&amp;amp;)操作并左移2位,接着第三个字符右移6位与前者相或(|)，获得第三个目标字符。

4. 最后将第三个字符与0x3f(00111111)进行与(&amp;amp;)操作即获得第四个目标字符。

5. 在以上的每一个步骤之后，再把结果与 0x3F 进行 AND 位操作，就可以得到编码后的字符了。

 可是等等……聪明的你可能会问到，原文的字节数量应该是3的倍数啊，如果这个条件不能满足的话，那该怎么办呢？

我们的解决办法是这样的：原文剩余的字节根据编码规则继续单独转(1变2,2变3;不够的位数用0补全)，
再用=号补满4个字节。这就是为什么有些Base64编码会以一个或两个等号结束的原因，但等号最多只有两个。

 因为：
  一个原字节至少会变成两个目标字节

所以余数任何情况下都只可能是0，1，2这三个数中的一个。如果余数是0的话，就表示原文字节数正好是3的倍数（最理想的情况）。
如果是1的话，转成2个Base64编码字符，为了让Base64编码是4的倍数，就要补2个等号；同理，如果是2的话，就要补1个等号。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;MIME格式&quot;&gt;&lt;a href=&quot;#MIME格式&quot; class=&quot;headerlink&quot; title=&quot;MIME格式&quot;&gt;&lt;/a&gt;MIME格式&lt;/h3&gt;&lt;p&gt; 在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，&lt;strong&gt;等号“=”&lt;/strong&gt;用来作为后缀用途。&lt;/p&gt;
&lt;p&gt; 完整的base64定义可见 RFC1421和 RFC2045。编码后的数据比原始数据略长，为原来的4/3。在电子邮件中，根据RFC822规定，&lt;strong&gt;每76个字符，还需要加上一个回车换行&lt;/strong&gt;。可以估算编码后数据长度大约为&lt;strong&gt;原长的135.1%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的Bit用0补足。然后，每次取出6个bit，按照其值选择 &lt;em&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&lt;/em&gt;    中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。&lt;/p&gt;
&lt;p&gt; 如果最后&lt;em&gt;剩下两个输入数据&lt;/em&gt;，在编码结果后&lt;em&gt;加&lt;strong&gt;1个&lt;/strong&gt;“=”&lt;/em&gt;；如果最后&lt;em&gt;剩下一个输入数据&lt;/em&gt;，编码结果后&lt;em&gt;加&lt;strong&gt;2个&lt;/strong&gt;“=”&lt;/em&gt;；如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>导入头文件的几种方式</title>
    <link href="http://yoursite.com/2016/04/27/%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/04/27/导入头文件的几种方式/</id>
    <published>2016-04-27T12:05:41.000Z</published>
    <updated>2016-04-27T12:34:01.000Z</updated>
    
    <content type="html">&lt;p&gt;导入头文件的方式有一下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. #include &amp;lt; &amp;gt;
2. #include &amp;quot; &amp;quot;
3. #import &amp;lt; &amp;gt;
4. #import &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; #import 相对 #include 可以先检查文件中是否已经引入头文件，如果已经引入则不再引入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt; &amp;gt; 引用的是编译器的类库里面头文件
&amp;quot; &amp;quot; 引用的是你程序目录的相对路径中的头文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  如果使用””，它是会先在你项目的当前目录查找是否有对应头文件&lt;br&gt;  如果没有，它还是会在对应的引用目录里面查找对应的头文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果遇到已经导入 文件夹 但是代码显示找不到那个文件夹里面的文件，可以&lt;br&gt; 在 Build Settings -&amp;gt; Search Paths -&amp;gt; Header Search Paths 添加相对路径（添加之后会显示绝对路径 $(PROJECT_DIR)/Tools/Alipay）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Create-groups-与-Create-folder-references-的区别&quot;&gt;&lt;a href=&quot;#Create-groups-与-Create-folder-references-的区别&quot; class=&quot;headerlink&quot; title=&quot;Create groups 与 Create folder references 的区别&quot;&gt;&lt;/a&gt;Create groups 与 Create folder references 的区别&lt;/h4&gt;&lt;p&gt; 1.使用Create groups ，为任何新增加的文件夹创建组，组的概念也许我们并不陌生，我们在项目中完全可以手动添加一个groups（右键点击选择New Group），但是手动添加的groups实际上并不会存在于项目的目录中，你会发现被添加进groups中的文件仍在位于它原来所在的位置，但是从外部引入进来的groups并不会如此，正如我们刚才那样。groups一旦被创建或添加，都是以黄色文件夹的形式存在的，当你想要使用文件夹中的某个类的头文件时，你可以直接添加它的引用，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include xxx.h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 因为groups下的cpp文件是会被编译的。&lt;/p&gt;
&lt;p&gt; 2.使用Create folder references方法只是将文件单纯的创建了引用，这些文件不会被编译，所以在使用的时候需要加入其路径，比如在我们想要使用上图中的myScripts文件夹下面有某个头文件，则需要按照下面的方法添加声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include myScripts/xxx.h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 否则编译器就会告诉你找不到xxx.h文件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;导入头文件的方式有一下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. #include &amp;lt; &amp;gt;
2. #include &amp;quot; &amp;quot;
3. #import &amp;lt; &amp;gt;
4. #import &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>OC的三大特性</title>
    <link href="http://yoursite.com/2016/04/24/OC%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/04/24/OC的三大特性/</id>
    <published>2016-04-24T14:38:11.000Z</published>
    <updated>2016-04-24T14:44:56.000Z</updated>
    
    <content type="html">&lt;p&gt; OC中类的三大特性：继承，封装，多态&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;OC中是有四种访问权限修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@public、@protected、@private、@package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中默认的修饰符是@private&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;但是这里要注意的是：OC中的方法是没有修饰符的概念的，这个和Java有很大的区别，一般都是公开访问的，即public的，但是我们怎么做到让OC中的一个方法不能被外界访问呢？&lt;/p&gt;
&lt;p&gt;OC中是这么做的，如果想让一个方法不被外界访问的话，只需要在.m文件中实现这个方法，不要在头文件中进行定义，说白了就是：该方法有实现，没定义，这样外界在导入头文件的时候，是没有这个方法的，但是这个方法我们可以在自己的.m文件中进行使用。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;继承是类中的一个重要的特性，他的出现使得我们没必要别写重复的代码，可重用性很高&lt;/p&gt;
&lt;p&gt;可以使用 super 关键字来调用父类的方法，同时这里我们也是可以用 self 关键字来调用，这里看到其实这两种方式调用的效果是一样的，当我们在子类重新实现 brake 方法的时候(Java中的重写概念)，那么这时候 super 关键字调用的还是父类的方法，而 self 调用的就是重写之后的 brake 方法了。&lt;/p&gt;
&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;p&gt;定义类型和实际类型，一般是基于接口的形式实现的。&lt;/p&gt;
&lt;p&gt;下面就来详细讲解一下多态的好处&lt;br&gt;上面的例子是一个彩色打印机和黑白打印机这两种打印机，然后Person类中有一个操作打印的方法，当然这个方法是需要打印机对象的，如果不用多态机制实现的话(Person.h中注释的代码部分)，就是给两种打印机单独定义个操作的方法，然后在Person.m(代码中注释的部分)中用具体的打印机对象进行操作，在main.m文件中，我们看到，当Person需要使用哪个打印机的时候，就去调用指定的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[person printWithBlack:blackPrint];//调用黑白打印机  
[person printWithColor:colorPrint];//调用彩色打印机  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种设计就不好了，为什么呢？假如现在又有一种打印机，那么我们还需要在 Person.h 中定义一种操作这种打印机的方法，那么后续如果在添加新的打印机呢？还在添加方法吗？那么 Person.h 文件就会变得很臃肿。所以这时候多态就体现到好处了，使用父类类型，在 Person.h 中定义一个方法就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void) doPrint:(Printer *)printer;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里看到了，这个方法的参数类型就是父类的类型，这就是多态，定义类型为父类类型，实际类型为子类类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void) doPrint:(Printer *)printer{  
  [printer print];  
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里调用print方法，就是传递进来的实际类型的print方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printer *p1 = [[ColorPrinter alloc] init];  
Printer *p2 = [[BlackPrinter alloc] init];  

[person doPrint:p1];  
[person doPrint:p2];  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的p1,p2表面上的类型是Printer，但是实际类型是子类类型，所以会调用他们自己对应的print方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; OC中类的三大特性：继承，封装，多态&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;OC中是有四种访问权限修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@public、@protected、@private、@package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中默认的修饰符是@private&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件的处理－见识filemanager的强大</title>
    <link href="http://yoursite.com/2016/04/22/%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8D%E8%A7%81%E8%AF%86filemanager%E7%9A%84%E5%BC%BA%E5%A4%A7/"/>
    <id>http://yoursite.com/2016/04/22/文件的处理－见识filemanager的强大/</id>
    <published>2016-04-22T14:29:05.000Z</published>
    <updated>2016-04-22T14:29:35.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;获取-Documents-目录文件&quot;&gt;&lt;a href=&quot;#获取-Documents-目录文件&quot; class=&quot;headerlink&quot; title=&quot;获取 Documents 目录文件&quot;&gt;&lt;/a&gt;获取 Documents 目录文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Library-目录路径&quot;&gt;&lt;a href=&quot;#获取-Library-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Library 目录路径&quot;&gt;&lt;/a&gt;获取 Library 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString *libraryDirectofry = [paths2 lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Tmp-目录路径&quot;&gt;&lt;a href=&quot;#获取-Tmp-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Tmp 目录路径&quot;&gt;&lt;/a&gt;获取 Tmp 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *tmpDirectory = NSTemporaryDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件夹&quot;&gt;&lt;a href=&quot;#创建文件夹&quot; class=&quot;headerlink&quot; title=&quot;创建文件夹&quot;&gt;&lt;/a&gt;创建文件夹&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *testDirectory = [documentsDirectory stringByAppendingString:@&amp;quot;test&amp;quot;];
BOOL res = [fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil];   
if (res) {

    NSLog(@&amp;quot;创建文件夹成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件夹失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件&quot;&gt;&lt;a href=&quot;#创建文件&quot; class=&quot;headerlink&quot; title=&quot;创建文件&quot;&gt;&lt;/a&gt;创建文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
NSString *testPath = [testDirectory stringByAppendingPathComponent:@&amp;quot;test.txt&amp;quot;];
BOOL res2 = [fileManager createFileAtPath:testPath contents:data attributes:nil]; 
if (res2) {

    NSLog(@&amp;quot;创建文件成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;测试写入内容&quot;&gt;&lt;a href=&quot;#测试写入内容&quot; class=&quot;headerlink&quot; title=&quot;测试写入内容&quot;&gt;&lt;/a&gt;测试写入内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content = @&amp;quot;测试写入内容&amp;quot;;
BOOL res3 = [content writeToFile:testPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; 
if (res3) {

    NSLog(@&amp;quot;文件写入成功&amp;quot;);
} else {

    NSLog(@&amp;quot;文件写入失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;读取文件内容&quot;&gt;&lt;a href=&quot;#读取文件内容&quot; class=&quot;headerlink&quot; title=&quot;读取文件内容&quot;&gt;&lt;/a&gt;读取文件内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content2 = [NSString stringWithContentsOfFile:testPath encoding:NSUTF8StringEncoding error:nil]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取文件属性&quot;&gt;&lt;a href=&quot;#获取文件属性&quot; class=&quot;headerlink&quot; title=&quot;获取文件属性&quot;&gt;&lt;/a&gt;获取文件属性&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:testPath error:nil]; 
for (int i = 0; i &amp;lt; [[fileAttributes allKeys] count]; i ++) {

    NSLog(@&amp;quot;key: %@, value:%@&amp;quot;, [[fileAttributes allKeys] objectAtIndex:i], [fileAttributes objectForKey:[[fileAttributes allKeys] objectAtIndex:i]]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;BOOL res4 = [fileManager removeItemAtPath:testPath error:nil]; 
if (res4) {

    NSLog(@&amp;quot;删除成功&amp;quot;);
} else {

    NSLog(@&amp;quot;删除失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>内存空间Zone的挖掘</title>
    <link href="http://yoursite.com/2016/04/22/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4Zone%E7%9A%84%E6%8C%96%E6%8E%98/"/>
    <id>http://yoursite.com/2016/04/22/内存空间Zone的挖掘/</id>
    <published>2016-04-22T14:26:34.000Z</published>
    <updated>2016-04-22T14:27:11.000Z</updated>
    
    <content type="html">&lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;所以你为什么想要去用你自己的NSZone呢？&lt;/p&gt;
&lt;p&gt;如果你大量分配数百个小对象，事实上你会发现你花费精力来为他们分配内存是有意义的。因为这种标准的（默认的）空间会被一直使用，它会变得斑驳起来；释放对象的过程会给整个内存留下令人尴尬的空隙。标准空间的分配器（allocator）也知道知道这一点，所以它尝试着优先去使用被用户释放的内存，去填补这些空隙，但是这种方式只有在空间(zone) 变得很大时才有明显效果。&lt;/p&gt;
&lt;p&gt;如果你想为大量对象分配内存，然后，你可以创建你自己的空间（zone）并且告诉它不用去为了为新对象分配内存而去查找那些空隙。分配器现在能够每次跳到内存分配的末尾为你的新对象分配内存，能起到不错的效果。&lt;/p&gt;
&lt;p&gt;另外，分配器也能为你节省时间，当分配器向操作系统请求更多内存时，分配器去查找哪块空间什么时候被填满，需要花费不少时间。一种更快的时间是一次去请求一大块内存，你也能告诉你的NSZone在这儿做什么。&lt;/p&gt;
&lt;p&gt;NSZone也能节省你释放内存的时间。它有方法释放大量分配的内存，而不打扰释放器（deallocators）。如果用一个集合（set）包含一系列对象，这样能够节省时间，你可以一次释放它们而不用去乏味地一个个释放它们。&lt;/p&gt;
&lt;p&gt;NSZone is Apple’s way of optimizing object allocation and freeing. NSZone is not an object; it is an opaque C-struct storing information about how memory should be handled for a set of objects.&lt;/p&gt;
&lt;p&gt;One rarely needs to worry about handling your own zones in applications; Cocoa handles it transparently. A default NSZone is created&amp;gt;If you are mass-allocating hundreds of cheap objects, you may find the cost of actually allocating space for them becomes significant. Because the standard zone is used all the time, it can become very patchy; deleted objects can leave awkward gaps throughout memory. The allocator for the standard NSZone knows this, and it tries to fill these gaps in preference to grabbing more memory off the system, but this can be costly in time if the zone has grown quite large.&lt;/p&gt;
&lt;p&gt;If you want to mass-allocate objects, then, you can create your own zone and tell it not to bother with finding gaps to put new objects in. The allocator can now jump to the end of its allotted memory each time and quickly assign memory to your new objects, saving a lot of effort.&lt;/p&gt;
&lt;p&gt;Allocators can save you time elsewhere, too, as asking the OS for more memory, which a zone needs to do whenever it fills up, is another costly operation if it’s done a lot. Much quicker is to ask for huge chunks of memory at a time, and you can tell your NSZone what to do here as well.&lt;/p&gt;
&lt;p&gt;Rumor has it that NSZone could save you deallocation time in the Good Old Days, too, with a method that simply chucks away all the allotted memory without bothering to call deallocators. If a set of objects is self-contained, this could save a lot of time, as you can chuck them all away at style=”font-weight:bold”&amp;gt;NSZone method (NSRecycleZone) carefully puts all the objects in a zone neatly style=”font-weight:bold”&amp;gt;NSZone. Not exactly a huge time-saver.&lt;/p&gt;
&lt;p&gt;So, in summary, zones save you time in mass allocations. &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>错误类error的学习</title>
    <link href="http://yoursite.com/2016/04/22/%E9%94%99%E8%AF%AF%E7%B1%BBerror%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/04/22/错误类error的学习/</id>
    <published>2016-04-22T14:24:31.000Z</published>
    <updated>2016-04-22T14:25:03.000Z</updated>
    
    <content type="html">&lt;p&gt;获取系统的错误信息 &lt;/p&gt;
&lt;p&gt;比如移动文件时，获取文件操作错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NSError *e = nil;
  [[NSFileManager defaultManager] moveItemAtPath:sourcePath toPath:targetPath error:&amp;amp;e];
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
先定一个空的错误信息
  NSError *e = nil;
取地址
  &amp;amp;e   
如果有错误信息，打印错误的本地化描述
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;自定义错误信息&quot;&gt;&lt;a href=&quot;#自定义错误信息&quot; class=&quot;headerlink&quot; title=&quot;自定义错误信息&quot;&gt;&lt;/a&gt;自定义错误信息&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;通常可以通过下面语句，自定义个NSError对象

   #define CustomErrorDomain @&amp;quot;com.xiaodao.test&amp;quot;
     typedef enum {

   　　  XDefultFailed = -1000,
   　　  XRegisterFailed,
   　　  XConnectFailed,
   　　  XNotBindedFailed
     }CustomErrorFailed;

   NSDictionary *userInfo = [NSDictionary dictionaryWithObject:@&amp;quot;is a error test&amp;quot;                                                                      forKey:NSLocalizedDescriptionKey];
   NSError *aError = [NSError errorWithDomain:CustomErrorDomain code:XDefultFailed userInfo:userInfo];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，自定义错误域对象CustomErrorDomain，通常用域名反写，也可以是任何其他字符串code错误标识, 系统的code一般都大于零，自定code可以用枚举（最好用负数, 但不是必须的）userInfo自定义错误信息，NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述可以通过NSError的localizedDescription方法获得对应的值信息&lt;/p&gt;
&lt;p&gt;主调用函数一般传入NSError指针的指针，来获取错误信息，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (Bool)doSomething:(NSDictionary *)parameter1 error:(NSError **)aError
{
   //TODO: do something
　　*aError = [NSError errorWithDomain:CustomErrorDomain code:XDefultFailed userInfo:userInfo];
　　return Yes;

}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSError头文件解析&quot;&gt;&lt;a href=&quot;#NSError头文件解析&quot; class=&quot;headerlink&quot; title=&quot;NSError头文件解析&quot;&gt;&lt;/a&gt;NSError头文件解析&lt;/h3&gt;&lt;h4 id=&quot;NSError对象中，主要有三个私有变量&quot;&gt;&lt;a href=&quot;#NSError对象中，主要有三个私有变量&quot; class=&quot;headerlink&quot; title=&quot;NSError对象中，主要有三个私有变量&quot;&gt;&lt;/a&gt;NSError对象中，主要有三个私有变量&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;错误域（NSInteger）： _domain

错误标示（NSString *）：_code

错误详细信息（NSDictionary *）：_userInfo

通常用_domain和_code一起标识一个错误信息


获取_domain
- (NSString *)domain;

获取 _code
- (NSInteger)code;

获取 _userInfo
- (NSDictionary *)userInfo;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;预定义域&quot;&gt;&lt;a href=&quot;#预定义域&quot; class=&quot;headerlink&quot; title=&quot;预定义域&quot;&gt;&lt;/a&gt;预定义域&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;AppKit和Foundation库中主要的错误域
     NSString *const NSCocoaErrorDomain;

其他域
     NSString *const NSPOSIXErrorDomain;
     NSString *const NSOSStatusErrorDomain;
     NSString *const NSMachErrorDomain;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;预定义的userinfo键名&quot;&gt;&lt;a href=&quot;#预定义的userinfo键名&quot; class=&quot;headerlink&quot; title=&quot;预定义的userinfo键名&quot;&gt;&lt;/a&gt;预定义的userinfo键名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;推荐的标准方式，通用键
    NSString *const NSUnderlyingErrorKey;

其他键，对应各自读取信息的方法：

详细描述键
    NSString *const NSLocalizedDescriptionKey;

取方法
   - (NSString *)localizedDescription;

失败原因键
    NSString *const NSLocalizedFailureReasonErrorKey

取方法
    - (NSString *)localizedFailureReason;

恢复建议键
    NSString *const NSLocalizedRecoverySuggestionErrorKey;

取方法
    - (NSString *)localizedRecoverySuggestion;

恢复选项键
    NSString *const NSLocalizedRecoveryOptionsErrorKey

取方法
    - (NSArray *)localizedRecoveryOptions;

其他键
    NSString *const NSRecoveryAttempterErrorKey; 
    NSString *const NSHelpAnchorErrorKey;
    NSString *const NSStringEncodingErrorKey ;
    NSString *const NSURLErrorKey;
    NSString *const NSFilePathErrorKey;
用法：
NSDictionary *userInfo ＝ [NSDictionary dictionaryWithObjectsAndKeys:@&amp;quot;这是错误详细的描述信息&amp;quot;, NSLocalizedDescriptionKey, error, NSUnderlyingErrorKey, nil]];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;主要的初始化方法：&quot;&gt;&lt;a href=&quot;#主要的初始化方法：&quot; class=&quot;headerlink&quot; title=&quot;主要的初始化方法：&quot;&gt;&lt;/a&gt;主要的初始化方法：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (id)initWithDomain:(NSString *)domain code:(NSInteger)code userInfo:(NSDictionary *)dict;
+ (id)errorWithDomain:(NSString *)domain code:(NSInteger)code userInfo:(NSDictionary *)dict;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;获取系统的错误信息 &lt;/p&gt;
&lt;p&gt;比如移动文件时，获取文件操作错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NSError *e = nil;
  [[NSFileManager defaultManager] moveItemAtPath:sourcePath toPath:targetPath error:&amp;amp;e];
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
先定一个空的错误信息
  NSError *e = nil;
取地址
  &amp;amp;e   
如果有错误信息，打印错误的本地化描述
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS程序的五种状态</title>
    <link href="http://yoursite.com/2016/04/22/iOS%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2016/04/22/iOS程序的五种状态/</id>
    <published>2016-04-22T14:21:54.000Z</published>
    <updated>2016-04-22T14:23:20.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;IOS应用程序5种状态&quot;&gt;&lt;a href=&quot;#IOS应用程序5种状态&quot; class=&quot;headerlink&quot; title=&quot;IOS应用程序5种状态&quot;&gt;&lt;/a&gt;IOS应用程序5种状态&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Not running:应用还没有启动，或者应用正在运行但是途中被系统停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inactive:当前应用正在前台运行，但是并不接收事件（当前 或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不 同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时 间比较长的情况是：当用户 锁屏时，或者系统提示用户去响应某 些（诸如电话来电、有未读短信等）事件的时候。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Active:当前应用正在前台运行，并且接收事件。这是应用正在前台运行时所处的正常状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Background:应用处在后台，并且还在执行代码。大多数将 要进入Suspended状态的应用，会先短暂进入此状态。然而，对于请求 需要额外的执行时间的应用，会在此状态保持更长一段时间。另外， 如果一个应用要 求启动时直接进入后台运行，这样的应用会直接 从Not running状态进入Background状态，中途不会经过Inactive状 态。比如没有界面的应用。注此处并不特指没有界面的应用，其实 也可以是 有界面的应用，只是如果要直接进入background状态的 话，该应用界面不会被显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Suspended:应用处在后台，并且已停止执行代码。系统自动 的将应用移入此状态，且在此举之前不会对应用做任何通知。当处在 此状态时，应用依然驻留内存但不执行任何程序代码。当系统发生 低内存告警时，系统将会将处 于Suspended状态的应用清除出内 存以为正在前台运行的应用提供足够的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IOS应用程序5种状态&quot;&gt;&lt;a href=&quot;#IOS应用程序5种状态&quot; class=&quot;headerlink&quot; title=&quot;IOS应用程序5种状态&quot;&gt;&lt;/a&gt;IOS应用程序5种状态&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Not running:应用还没有启动，或者应用正在运行但是途中被系统停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inactive:当前应用正在前台运行，但是并不接收事件（当前 或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不 同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时 间比较长的情况是：当用户 锁屏时，或者系统提示用户去响应某 些（诸如电话来电、有未读短信等）事件的时候。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>单例UIApplication-总结</title>
    <link href="http://yoursite.com/2016/04/22/%E5%8D%95%E4%BE%8BUIApplication-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/22/单例UIApplication-总结/</id>
    <published>2016-04-22T14:16:58.000Z</published>
    <updated>2016-04-22T14:21:05.000Z</updated>
    
    <content type="html">&lt;p&gt;If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIKIT_EXTERN int UIApplicationMain (

   int argc, 
   char *argv[], 
   NSString * __nullable principalClassName, 
   NSString * __nullable delegateClassName
);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责-三件-事情：&quot;&gt;&lt;a href=&quot;#那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责-三件-事情：&quot; class=&quot;headerlink&quot; title=&quot;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责 三件 事情：&quot;&gt;&lt;/a&gt;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责 三件 事情：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1）从给定的类名初始化应用程序对象，也就是初始化UIApplication或者子类对象的一个实例，
如果你在这里给定的是nil，那么 系统会默认UIApplication类，也就主要是这个类来控制以及协调应用程序的运行。
在后续的工作中，你可以用静态方法sharedApplication 来获取应用程序的句柄。 
2）从给定的应用程序委托类，初始化一个应用程序委托。并把该委托设置为应用程序的委托，这里就有如果传入参数为nil，会调用函数访问 Info.plist文件来寻找主nib文件，获取应用程序委托。 
3）启动主事件循环，并开始接收事件。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;UIApplication（或-者子类）对象的职责，这个对象主要做下面几件事：&quot;&gt;&lt;a href=&quot;#UIApplication（或-者子类）对象的职责，这个对象主要做下面几件事：&quot; class=&quot;headerlink&quot; title=&quot;UIApplication（或 者子类）对象的职责，这个对象主要做下面几件事：&quot;&gt;&lt;/a&gt;UIApplication（或 者子类）对象的职责，这个对象主要做下面几件事：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1）负责处理到来的用户事件，并分发事件消息到应该处理该消息的目标对象（sender,  action)。 
2）管理以及控制视图，包括呈现、控制行为、当前显示视图等。 
3）该对象有一个应用程序委托对象，当一些生命周期内重要事件（可以包括系统事件或者生命周期控制事件）发生时，应用程序通知该对象。
例如，应用程序启动、内存不够了或者应用程序结束等，让这些事件发生时，应用程序委托去响应。 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot;&gt;&lt;a href=&quot;#我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot; class=&quot;headerlink&quot; title=&quot;我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot;&gt;&lt;/a&gt;我们可以从应用程序的单例类对象中得到应用程序委托的对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UIApplicationDelegate* myDelegate = [[UIApplication sharedApplication] delegate]; 

UIApplication 接收到所有的系统事件和生命周期事件时，都会把事件传递给UIApplicationDelegate进行处理，
对于用户输入 事件，则传递给相应的目标对象去处理
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;创建UIApplication对象并指定其代理&quot;&gt;&lt;a href=&quot;#创建UIApplication对象并指定其代理&quot; class=&quot;headerlink&quot; title=&quot;创建UIApplication对象并指定其代理&quot;&gt;&lt;/a&gt;创建UIApplication对象并指定其代理&lt;/h3&gt;&lt;p&gt;通过UIApplicationMain函数创建UIApplication对象并 指定其代理对象AppDelegate;第三个参数为指定 UIApplication的子类来生成UIApplication对象，为nil时由 UIApplication类初始化默认对象；第四个参数为指定代理 对象。&lt;/p&gt;
&lt;h3 id=&quot;UIApplication的代理对象&quot;&gt;&lt;a href=&quot;#UIApplication的代理对象&quot; class=&quot;headerlink&quot; title=&quot;UIApplication的代理对象&quot;&gt;&lt;/a&gt;UIApplication的代理对象&lt;/h3&gt;&lt;p&gt;作为UIApplication的代理类，必须要先实现 UIApplicationDelegate协议，协议里明确了作为代理应 该做或可以做哪些事情。 UIApplication对象负责监听应用程序的生命周期事件， 并将生命周期事件交由UIApplication代理对象处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIKIT_EXTERN int UIApplicationMain (

   int argc, 
   char *argv[], 
   NSString * __nullable principalClassName, 
   NSString * __nullable delegateClassName
);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC关键字</title>
    <link href="http://yoursite.com/2016/04/15/OC%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/04/15/OC关键字/</id>
    <published>2016-04-15T14:50:55.000Z</published>
    <updated>2016-04-15T14:53:08.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;import和-include的区别&quot;&gt;&lt;a href=&quot;#import和-include的区别&quot; class=&quot;headerlink&quot; title=&quot;#import和#include的区别&quot;&gt;&lt;/a&gt;#import和#include的区别&lt;/h3&gt;&lt;p&gt;  当我们在代码中使用两次#include的时候会报错：因为#include相当于拷贝头文件中的声明内容，所以会报重复定义的错误但是使用两次#import的话，不会报错，所以他可以解决重复导入的问题，他会做一次判断，如果已经导入一次就不导入了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;class&quot;&gt;&lt;a href=&quot;#class&quot; class=&quot;headerlink&quot; title=&quot;@class&quot;&gt;&lt;/a&gt;@class&lt;/h3&gt;&lt;p&gt;  不会将Student.h拷贝过来，只是告诉编译器Student这个类在别的地方中有定义，这样就不知道这个类中任何信息(哪些属性和方法) &lt;/p&gt;
&lt;p&gt;#import指令是Object-C针对#include的改进版本，#import确保引用的文件只会被引用一次，这样就不会陷入递归包含的问题中。&lt;/p&gt;
&lt;h3 id=&quot;import与-class二者的区别在于：&quot;&gt;&lt;a href=&quot;#import与-class二者的区别在于：&quot; class=&quot;headerlink&quot; title=&quot;#import与@class二者的区别在于：&quot;&gt;&lt;/a&gt;#import与@class二者的区别在于：&lt;/h3&gt;&lt;p&gt;　　 &lt;/p&gt;
&lt;p&gt; #import会链入该头文件的全部信息，包括实体变量和方法等；而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑。在头文件中， 一般只需要知道被引用的类的名称就可以了。&lt;br&gt;　　&lt;br&gt; 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;import和-include的区别&quot;&gt;&lt;a href=&quot;#import和-include的区别&quot; class=&quot;headerlink&quot; title=&quot;#import和#include的区别&quot;&gt;&lt;/a&gt;#import和#include的区别&lt;/h3&gt;&lt;p&gt;  当我们在代码中使用两次#include的时候会报错：因为#include相当于拷贝头文件中的声明内容，所以会报重复定义的错误但是使用两次#import的话，不会报错，所以他可以解决重复导入的问题，他会做一次判断，如果已经导入一次就不导入了&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC的实例方法和类方法的区别</title>
    <link href="http://yoursite.com/2016/04/15/OC%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/15/OC的实例方法和类方法的区别/</id>
    <published>2016-04-15T14:48:32.000Z</published>
    <updated>2016-04-15T14:50:21.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;-对象方法&lt;/strong&gt; 即OO的基本精神之一 —— 封装／信息隐藏，这个需要你对OO有理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+类方法&lt;/strong&gt; 一般用作命名空间，用以组织一组功能函数；又或用作类的工厂函数，用以产生类的对象；不管哪种，都需要有大型项目的经验，才知道如何组织程序的复杂性及使用设计模式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;类方法和实例方法&quot;&gt;&lt;a href=&quot;#类方法和实例方法&quot; class=&quot;headerlink&quot; title=&quot;类方法和实例方法&quot;&gt;&lt;/a&gt;类方法和实例方法&lt;/h3&gt;&lt;p&gt;实例方法是— ， 类开头是+&lt;br&gt;实例方法是用实例对象访问，类方法的对象是类而不是实例，通常创建对象或者工具类。&lt;/p&gt;
&lt;p&gt;在实例方法里，根据继承原理发送消息给self和super其实都是发送给self&lt;/p&gt;
&lt;p&gt;在类方法里面self是其他的类的类方法，在类方法中给self发送消息只能发类方法，self是类super也是&lt;/p&gt;
&lt;p&gt;什么时候用类方法：要创建一个实例时候获取一个共享实例，或者获取关于类的一些共有信息&lt;/p&gt;
&lt;p&gt;1、类方法是属于整个类，而不属于某个对象。&lt;br&gt;2、类方法只能访问类成员变量，不能访问实例变量，而实例方法可以访问类成员变量和实例变量。&lt;br&gt;3、类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问。&lt;br&gt;4、类方法只能访问类方法，而实例方法可以访问类方法和实例方法。&lt;br&gt;5、类方法不能被覆盖，实例方法可以被覆盖。 &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;-对象方法&lt;/strong&gt; 即OO的基本精神之一 —— 封装／信息隐藏，这个需要你对OO有理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+类方法&lt;/strong&gt; 一般用作命名空间，用以组织一组功能函数；又或用作类的工厂函数，用以产生类的对象；不管哪种，都需要有大型项目的经验，才知道如何组织程序的复杂性及使用设计模式&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSSet_集合（无序）</title>
    <link href="http://yoursite.com/2016/04/15/NSSet-%E9%9B%86%E5%90%88%EF%BC%88%E6%97%A0%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2016/04/15/NSSet-集合（无序）/</id>
    <published>2016-04-15T14:46:28.000Z</published>
    <updated>2016-04-15T14:47:26.000Z</updated>
    
    <content type="html">&lt;p&gt;NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;//判断是否含有age字符串
if([set containsObject:@&amp;quot;age&amp;quot;]) {
    NSLog(@&amp;quot;set包含age&amp;quot;);
}

//判断set 是否等于set1
if ([set isEqualToSet:set1]) {
    NSLog(@&amp;quot;set 等于 set1&amp;quot;);
}

//判断set是否是否是set1的子集合
if ([set isSubsetOfSet:set1]) {
    NSLog(@&amp;quot;set isSubsetOfSet set1&amp;quot;);
}

//获取所有set对象
NSArray *array = [set allObjects];
NSLog(@&amp;quot;array:%@&amp;quot;, array);

//迭代遍历
NSEnumerator *enumerator = [set objectEnumerator];
for (NSObject *object in enumerator) {
    NSLog(@&amp;quot;set1里的对象:%@&amp;quot;, object);
}

//添加对象到集合里面
[set setByAddingObject:@&amp;quot;123&amp;quot;];

// 类方法处理方式
NSSet *set3 = [NSSet set];
NSSet *set4 = [NSSet setWithObject:@&amp;quot;123&amp;quot;];
NSSet *set5 = [NSSet setWithObjects:@&amp;quot;1&amp;quot;, @&amp;quot;2&amp;quot;, nil];
NSSet *set6 = [NSSet setWithArray:array];
NSSet *set7 = [NSSet setWithSet:set6];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSMutableSet的使用&quot;&gt;&lt;a href=&quot;#NSMutableSet的使用&quot; class=&quot;headerlink&quot; title=&quot;NSMutableSet的使用&quot;&gt;&lt;/a&gt;NSMutableSet的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSMutableSet继承NSSet，它可以使用NSSet的方法。

[NSMutableSet setWithCapacity:6]:创建可变集合对象，并且初始化长度为6。
[set addObject: obj] : 向集合中动态的添加对象。
[set removeObject:obj]:删除集合中的一个对象。
[set removeAllObjects]:删除集合中的所有对象。
[set unionSet:obj]:向集合中添加一个obj集合的所有数据。
[set minusSet:obj]:向集合中删除一个obj集合的所有数据。
[set intersectSet]:向集合中删除一个不包含obj集合的所有数据。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中 @synthesize 和 @dynamic 的区别</title>
    <link href="http://yoursite.com/2016/04/14/iOS%E4%B8%AD-synthesize-%E5%92%8C-dynamic-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/14/iOS中-synthesize-和-dynamic-的区别/</id>
    <published>2016-04-14T13:28:35.000Z</published>
    <updated>2016-04-14T13:40:13.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其主要的作用就是用在NSManagerObject对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，core data 框架会在程序运行的时候为此类属性生成getter和setter方法。&lt;/p&gt;
&lt;p&gt;被指定为动态实现的方法的dynamicMethod的参数有如下的要求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A.第一个、第二个参数必须是id、SEL；
B.第三个参数开始，你可以按照原方法（例如：setHeight:(float)）的参数定义。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再接下来，你需要覆盖NSObject 的类方法resolveInstanceMethod，这个方法会把需要动态实现的方法（setHeight:）的选择器传递进来，我们判断一下是否是需要动态实现的选择器，如果是就把处理权转交给dynamicMethod。&lt;/p&gt;
&lt;h3 id=&quot;如何转交呢？&quot;&gt;&lt;a href=&quot;#如何转交呢？&quot; class=&quot;headerlink&quot; title=&quot;如何转交呢？&quot;&gt;&lt;/a&gt;如何转交呢？&lt;/h3&gt;&lt;p&gt;这里我们就要用到运行时函数class_addMethod(Class,SEL,IMP,char[])。&lt;/p&gt;
&lt;p&gt;运行时函数位于objc/runtime.h，正如名字一样，这里面都是C 语言的函数。按照这些函数的功能的不同，主要分为如下几类：操作类型、操作对象、操作协议等。大多数的函数都可以通过名字看出是什么意思，例如：class_addProtocol 动态的为一个类型在运行时增加协议、objc_getProtocol 把一个字符串转换为协议等。&lt;/p&gt;
&lt;p&gt;言归正传，我们来解释一下这里需要用到的class_addmethod 方法，这个方法有四个参数，Class 表示你要为哪个类型增加方法，SEL 参数表示你要增加的方法的选择器，IMP 表示你要添加的方法的运行时的具体实现的函数指针。其实在这里你能够看出SEL 并不能在运行时找到真正要调用的方法，IMP 才可以真正的找到实现方法的。&lt;/p&gt;
&lt;p&gt;现在我们来正式的看以下第四个参数v@:f 的含义，它描述了IMP 指向的函数的描述信息，按照@encode 指令编译之后的字符说明，第一个字符v 表示返回值为void，剩余的字符为dynamicMethod 函数的参数描述，@表示第一个参数id，:自然就是第二个参数SEL，f 就是第三个参数float。由于前面说过动态方法的实现的前两个参数必须是id、SEL，所以第四个参数中的字符串的第二、三个字符一定是@:。我们看到resolveInstanceMethod 方法的返回值为BOOL，也就是这个方法返回YES 表示找到了动态方法的具体实现，否则就表示没有在运行时找到真实的实现，程序就汇报错。&lt;/p&gt;
&lt;p&gt;经过了上面的处理，Objective-C 的运行时只要发现你调用了@dynamic 标注的属性的setter、getter 方法，就会自动到resolveInstanceMethod 里去寻找真实的实现。这也就是说你在main.m 中调用peson.height 的时候，实际上dynamicMethod 函数被调用了。实际上除了@dynamic 标注的属性之外，如果你调用了类型中不存在的方法，也会被 resolveInstanceMethod 或者resolveClassMethod 截获，但由于你没有处理，所以会报告不能识别的消息的错误。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;譬如：从网络下载一个升级包，不需要退出原有的程序，就可以动态的替换掉旧的功能等类似的需求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数－ 函数调用2</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8D-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A82/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数－-函数调用2/</id>
    <published>2016-04-14T13:21:38.000Z</published>
    <updated>2016-04-14T13:47:29.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;补充：respondsToSelector&quot;&gt;&lt;a href=&quot;#补充：respondsToSelector&quot; class=&quot;headerlink&quot; title=&quot;补充：respondsToSelector&quot;&gt;&lt;/a&gt;补充：respondsToSelector&lt;/h3&gt;&lt;p&gt;   +(BOOL)respondsToSelector:(SEL)aSelector &lt;/p&gt;
&lt;p&gt;这个函数大家再熟悉不过了，用来检查对象是否实现了某函数。&lt;/p&gt;
&lt;p&gt;此函数通常是不需要重载的，但是在动态实现了查找过程后，需要重载此函数让对外接口查找动态实现函数的时候返回YES，保证对外接口的行为统一。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; - (BOOL) respondsToSelector:(SEL)aSelector
    {
       if (@selector(setTitle:) == aSelector ||
       @selector(title) == aSelector ||
       @selector(setAuthor:) == aSelector ||
       @selector(author) == aSelector)
      {
        return YES;
      }

       return [super respondsToSelector: aSelector];
    }

  //全局函数
 1.void dynamicMethodIMP(id self, SEL _cmd)
        {
           // implementation ....
        }

 2.+ (BOOL) resolveInstanceMethod:(SEL)aSEL
       {
        if (aSEL == @selector(resolveThisMethodDynamically))
        {
            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &amp;quot;v@:&amp;quot;);
            return YES;
         }
         return [super resolveInstanceMethod:aSel];
       }

  //将消息转出某对象
3.- (id)forwardingTargetForSelector:(SEL)aSelector
      {
       NSLog(@&amp;quot;MyTestObject _cmd: %@&amp;quot;, NSStringFromSelector(_cmd));

        NoneClass *none = [[NoneClass alloc] init];
        if ([none respondsToSelector: aSelector]) {
          return none;
       }

       return [super forwardingTargetForSelector: aSelector];
      }

4.- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector
    {
      NSString *sel = NSStringFromSelector(selector);
      if ([sel rangeOfString:@&amp;quot;set&amp;quot;].location == 0) {
        //动态造一个 setter函数
        return [NSMethodSignature signatureWithObjCTypes:&amp;quot;v@:@&amp;quot;];
      } else {
        //动态造一个 getter函数
        return [NSMethodSignature signatureWithObjCTypes:&amp;quot;@@:&amp;quot;];
      }
   }

5.- (void)forwardInvocation:(NSInvocation *)invocation
      {
       //拿到函数名
       NSString *key = NSStringFromSelector([invocation selector]);
       if ([key rangeOfString:@&amp;quot;set&amp;quot;].location == 0) {
          //setter函数形如 setXXX: 拆掉 set和冒号 
          key = [[key substringWithRange:NSMakeRange(3, [key length]-4)] lowercaseString];
          NSString *obj;
          //从参数列表中找到值
          [invocation getArgument:&amp;amp;obj atIndex:2];
          [data setObject:obj forKey:key];
        } else {
          //getter函数就相对简单了，直接把函数名做 key就好了。
          NSString *obj = [data objectForKey:key];
          [invocation setReturnValue:&amp;amp;obj];
        }
      }
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;补充：respondsToSelector&quot;&gt;&lt;a href=&quot;#补充：respondsToSelector&quot; class=&quot;headerlink&quot; title=&quot;补充：respondsToSelector&quot;&gt;&lt;/a&gt;补充：respondsToSelector&lt;/h3&gt;&lt;p&gt;   +(BOOL)respondsToSelector:(SEL)aSelector &lt;/p&gt;
&lt;p&gt;这个函数大家再熟悉不过了，用来检查对象是否实现了某函数。&lt;/p&gt;
&lt;p&gt;此函数通常是不需要重载的，但是在动态实现了查找过程后，需要重载此函数让对外接口查找动态实现函数的时候返回YES，保证对外接口的行为统一。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数－ 函数调用</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8D-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数－-函数调用/</id>
    <published>2016-04-14T13:20:13.000Z</published>
    <updated>2016-04-14T13:48:24.000Z</updated>
    
    <content type="html">&lt;p&gt;  Objective-C是一门动态语言，一个函数是由一个selector(SEL)，和一个implement(IML)组成的。Selector相当于门牌号，而Implement才是真正的住户（函数实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  和现实生活一样，门牌可以随便发（@selector(XXX)），但是不一定都找得到住户，如果找不到系统会给程序几次机会来程序正常运行，实在没出路了才会抛出异常。下图是objc_msgSend调用时，查找SEL的IML的过程。咱们以这个流程为例看看其中涉及的很有用的函数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/img/objc_msgSend.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;resolveInstanceMethod-函数&quot;&gt;&lt;a href=&quot;#resolveInstanceMethod-函数&quot; class=&quot;headerlink&quot; title=&quot;resolveInstanceMethod 函数&quot;&gt;&lt;/a&gt;resolveInstanceMethod 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+ (BOOL)resolveInstanceMethod:(SEL)name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数在运行时(runtime)，没有找到SEL的IML时就会执行。这个函数是给类利用class_addMethod添加函数的机会。根据文档，如果实现了添加函数代码则返回YES，未实现返回NO。&lt;/p&gt;
&lt;h3 id=&quot;forwardingTargetForSelector-函数&quot;&gt;&lt;a href=&quot;#forwardingTargetForSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;forwardingTargetForSelector 函数&quot;&gt;&lt;/a&gt;forwardingTargetForSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;流程到了这里，系统给了个将这个SEL转给其他对象的机会。返回参数是一个对象，如果这个对象非nil、非self的话，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。&lt;/p&gt;
&lt;h3 id=&quot;methodSignatureForSelector-函数&quot;&gt;&lt;a href=&quot;#methodSignatureForSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;methodSignatureForSelector 函数&quot;&gt;&lt;/a&gt;methodSignatureForSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数和后面的forwardInvocation:是最后一个寻找IML的机会。这个函数让重载方有机会抛出一个函数的签名，再由后面的forwardInvocation:去执行。&lt;/p&gt;
&lt;h3 id=&quot;forwardInvocation-函数&quot;&gt;&lt;a href=&quot;#forwardInvocation-函数&quot; class=&quot;headerlink&quot; title=&quot;forwardInvocation 函数&quot;&gt;&lt;/a&gt;forwardInvocation 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真正执行从methodSignatureForSelector:返回的NSMethodSignature。在这个函数里可以将NSInvocation多次转发到多个对象中，这也是这种方式灵活的地方。（forwardingTargetForSelector只能以Selector的形式转向一个对象）&lt;/p&gt;
&lt;h3 id=&quot;doesNotRecognizeSelector-函数&quot;&gt;&lt;a href=&quot;#doesNotRecognizeSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;doesNotRecognizeSelector 函数&quot;&gt;&lt;/a&gt;doesNotRecognizeSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)doesNotRecognizeSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为找不到函数实现的最后一步，NSObject实现这个函数只有一个功能，就是抛出异常。&lt;/p&gt;
&lt;p&gt;虽然理论上可以重载这个函数实现保证不抛出异常（不调用super实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;在一个函数找不到时，Objective-C提供了三种方式去补救：&lt;/p&gt;
&lt;p&gt;1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数&lt;/p&gt;
&lt;p&gt;2、调用forwardingTargetForSelector让别的对象去执行这个函数&lt;/p&gt;
&lt;p&gt;3、调用methodSignatureForSelector（函数符号制造器）和forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。&lt;/p&gt;
&lt;p&gt;如果都不中，调用doesNotRecognizeSelector抛出异常。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  Objective-C是一门动态语言，一个函数是由一个selector(SEL)，和一个implement(IML)组成的。Selector相当于门牌号，而Implement才是真正的住户（函数实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数load 和 initialize</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0load-%E5%92%8C-initialize/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数load-和-initialize/</id>
    <published>2016-04-14T13:17:18.000Z</published>
    <updated>2016-04-14T13:43:09.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;初始化阶段-－－-load-函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-load-函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ load 函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ load 函数&lt;/h3&gt;&lt;p&gt; +(void)load&lt;/p&gt;
&lt;p&gt;当类被引用进程序的时候会执行这个函数。&lt;/p&gt;
&lt;p&gt;在一个程序开始运行之前（在main函数开始执行之前）,在库开始被程序加载，load函数就会开始被执行。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们开发的程序都可以认为是一个库，但是库又不会独立存在（我们的程序还会引用其他库，也可能被其他函数引用），所以库的初始化顺序可以如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 初始化我们引用的库
2. 执行我们自己库的Objective-C的load函数
3. 执行C++和C的static初始化变量
4. 初始化引用我们库的其他库
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在我们的编写的库中，会有很多类重写load函数，他们之间的执行顺序是不确定的。&lt;/p&gt;
&lt;p&gt;当父类和子类都实现load函数时，父类的load函数会被先执行。load函数是系统自动加载的，因此不需要调用父类的load函数，否则父类的load函数会多次执行。&lt;/p&gt;
&lt;p&gt;在Category中写load函数是不会替换原始类中的load函数的，原始类和Category中的load函数都会被执行，原始类的load会先被执行，再执行Category中的load函数。当有多个Category都实现了load函数，这几个load函数执行顺序不确定。&lt;/p&gt;
&lt;h3 id=&quot;初始化阶段-－－-Initialize函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-Initialize函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ Initialize函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ Initialize函数&lt;/h3&gt;&lt;p&gt; +(void)initialize&lt;/p&gt;
&lt;p&gt;当类第一次被执行到的时候这个函数会被执行。&lt;/p&gt;
&lt;p&gt;如果类包含继承关系，父类的initialize函数会比子类先执行。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。&lt;/p&gt;
&lt;p&gt;假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。&lt;/p&gt;
&lt;h3 id=&quot;Load-or-Initialize&quot;&gt;&lt;a href=&quot;#Load-or-Initialize&quot; class=&quot;headerlink&quot; title=&quot;Load or Initialize&quot;&gt;&lt;/a&gt;Load or Initialize&lt;/h3&gt;&lt;p&gt;这两个函数没有交集，也没有执行的先后顺序，他们各自遵循着各自的调用原则。因此在写逻辑的时候，不能有逻辑依赖load函数比initialize函数先行调用。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;将针对于类修改放在intialize中，将针对Category的修改放在load中。&lt;/p&gt;
&lt;p&gt;但是假如我们是修改系统的类，一般会通过添加Category来添加功能，但是如果修改initialize会导致原生的intialize不会执行，所以&lt;strong&gt;放在load中&lt;/strong&gt;会比较妥当。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初始化阶段-－－-load-函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-load-函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ load 函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ load 函数&lt;/h3&gt;&lt;p&gt; +(void)load&lt;/p&gt;
&lt;p&gt;当类被引用进程序的时候会执行这个函数。&lt;/p&gt;
&lt;p&gt;在一个程序开始运行之前（在main函数开始执行之前）,在库开始被程序加载，load函数就会开始被执行。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>定时器NSTimer</title>
    <link href="http://yoursite.com/2016/04/08/%E5%AE%9A%E6%97%B6%E5%99%A8NSTimer/"/>
    <id>http://yoursite.com/2016/04/08/定时器NSTimer/</id>
    <published>2016-04-08T14:13:12.000Z</published>
    <updated>2016-04-08T14:19:48.000Z</updated>
    
    <content type="html">&lt;p&gt;定时器类具有五种初始化方法，包含四种工厂方法和一个实例化方法。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 invocation:invocation repeats:NO];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer2 = [NSTimer scheduledTimerWithTimeInterval:2.0 invocation:invocation repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer3 = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(myLog) userInfo:@”123” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer4 = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(myLog) userInfo:@”456” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer5 = [[NSTimer alloc] initWithFireDate:date interval:2.0 target:self selector:@selector(myLog) userInfo:@”789” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法
 target : 需要执行方法的对象。
 selector : 需要执行的方法
 repeats : 是否需要循环
 userInfo : 用户信息

方法中需要调用的对象：

      NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(initW)]];
      [invocation setTarget:self];
      [invocation setSelector:@selector(myLog)];

  需要分别实现 **initW **和 **myLog** 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;将-NSTimer-对象加入Runloop&quot;&gt;&lt;a href=&quot;#将-NSTimer-对象加入Runloop&quot; class=&quot;headerlink&quot; title=&quot;将 NSTimer 对象加入Runloop&quot;&gt;&lt;/a&gt;将 NSTimer 对象加入Runloop&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[NSRunLoop mainRunLoop] addTimer:timer3 forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;释放方法&quot;&gt;&lt;a href=&quot;#释放方法&quot; class=&quot;headerlink&quot; title=&quot;释放方法&quot;&gt;&lt;/a&gt;释放方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[timer invalidate];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;启动方法&quot;&gt;&lt;a href=&quot;#启动方法&quot; class=&quot;headerlink&quot; title=&quot;启动方法&quot;&gt;&lt;/a&gt;启动方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. [timer2 fire];

2. timer4.fireDate = [NSDate distantPast];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;定时器类具有五种初始化方法，包含四种工厂方法和一个实例化方法。
    
    </summary>
    
    
      <category term="［定时器］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>路径类NSURL的使用</title>
    <link href="http://yoursite.com/2016/04/07/%E8%B7%AF%E5%BE%84%E7%B1%BBNSURL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/07/路径类NSURL的使用/</id>
    <published>2016-04-07T13:00:28.000Z</published>
    <updated>2016-04-07T13:01:20.000Z</updated>
    
    <content type="html">&lt;p&gt;NSURL 类作为路径和地址的表示类，在各种场合都发挥很大的作用。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;共有18中初始化方法 （9种实例化方法 + 9种工厂方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init...
URLWith...
fileURLWith...
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;比较方法&quot;&gt;&lt;a href=&quot;#比较方法&quot; class=&quot;headerlink&quot; title=&quot;比较方法&quot;&gt;&lt;/a&gt;比较方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;isEqual:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查询一个NSURL&quot;&gt;&lt;a href=&quot;#查询一个NSURL&quot; class=&quot;headerlink&quot; title=&quot;查询一个NSURL&quot;&gt;&lt;/a&gt;查询一个NSURL&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;checkResourceIsReachableAndReturnError:  返回一个文件URL指向的资源是否可达
isFileReferenceURL
isFileURL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h3&gt;&lt;p&gt;NSURLFileScheme  : 文件URL的scheme&lt;br&gt;还有一堆文件资源的key，如 属性修改日期、访问日期、内容修改日期、创建日期、自定义Icon、文件标识符、文件类型、文件安全、是否隐藏扩展名、是否是文件夹等&lt;/p&gt;
&lt;h3 id=&quot;NSURL的属性：&quot;&gt;&lt;a href=&quot;#NSURL的属性：&quot; class=&quot;headerlink&quot; title=&quot;NSURL的属性：&quot;&gt;&lt;/a&gt;NSURL的属性：&lt;/h3&gt;&lt;p&gt;例如：scheme、user、password、host、port、path、pathComponents、pathExtension、lastPathComponent、parameterString、fragment&lt;/p&gt;
&lt;h3 id=&quot;get和set-File-System-Resource-Properties-这部分需要加强理解&quot;&gt;&lt;a href=&quot;#get和set-File-System-Resource-Properties-这部分需要加强理解&quot; class=&quot;headerlink&quot; title=&quot;get和set File System Resource Properties(这部分需要加强理解)&quot;&gt;&lt;/a&gt;get和set File System Resource Properties(这部分需要加强理解)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString *size = Nil;
NSError *error = [[NSError alloc] initWithDomain:@&amp;quot;1&amp;quot; code:1 userInfo:Nil];

NSURL *samplePath = [[NSURL alloc] initWithString:@&amp;quot;file://Users/Users/zxq/Desktop/1.pdf&amp;quot;];

//获取文件的大小
[samplePath getResourceValue:&amp;amp;size forKey:NSURLFileSizeKey error:&amp;amp;error];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLTotalFileSizeKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取文件地址
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLPathKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取最后修改的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLCreationDateKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取文件名
[samplePath getResourceValue:&amp;amp;size forKey:NSURLNameKey error:&amp;amp;error];
NSLog(@&amp;quot;Error == %@&amp;quot;, error);
NSLog(@&amp;quot;size == %@&amp;quot;, size);


//是否可达
NSLog(@&amp;quot;%d&amp;quot;, [samplePath checkPromisedItemIsReachableAndReturnError:&amp;amp;error]);

NSLog(@&amp;quot;%d&amp;quot;, [samplePath isFileReferenceURL]);
NSLog(@&amp;quot;%d&amp;quot;, [samplePath isFileURL]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;NSURL 类作为路径和地址的表示类，在各种场合都发挥很大的作用。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;共有18中初始化方法 （9种实例化方法 + 9种工厂方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init...
URLWith...
fileURLWith...
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［NSURL］" scheme="http://yoursite.com/tags/%EF%BC%BBNSURL%EF%BC%BD/"/>
    
  </entry>
  
</feed>
