<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-13T11:14:02.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> initWithNibName 和 loadNibNamed 的区别和联系</title>
    <link href="http://yoursite.com/2016/08/13/initWithNibName-%E5%92%8C-loadNibNamed-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2016/08/13/initWithNibName-和-loadNibNamed-的区别和联系/</id>
    <published>2016-08-13T11:13:03.000Z</published>
    <updated>2016-08-13T11:14:02.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;联系&quot;&gt;&lt;a href=&quot;#联系&quot; class=&quot;headerlink&quot; title=&quot;联系&quot;&gt;&lt;/a&gt;联系&lt;/h3&gt;&lt;p&gt; 可以使用此方法加载用户界面（xib文件）到我们的代码中，这样，可以通过操作这个加载进来的（xib）对象，来操作xib文件内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h3&gt;&lt;p&gt;1.集成类不一样&lt;/p&gt;
&lt;p&gt;initWithNibName要加载的xib的类为我们定义的视图控制器类&lt;br&gt;loadNibNamed要加载的xib的类为NSOjbect&lt;/p&gt;
&lt;p&gt;2.加载方式不同&lt;/p&gt;
&lt;p&gt;initWithNibName方法：是延迟加载，这个View上的控件是 nil 的，只有到 需要显示时，才会不是 nil&lt;br&gt;loadNibNamed方法：即时加载，用该方法加载的xib对象中的各个元素都已经存在。&lt;/p&gt;
&lt;h3 id=&quot;获取想要的-view&quot;&gt;&lt;a href=&quot;#获取想要的-view&quot; class=&quot;headerlink&quot; title=&quot;获取想要的 view&quot;&gt;&lt;/a&gt;获取想要的 view&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSArray* nib = [[NSBundle mainBundle] loadNibNamed／@&amp;quot;CustomCell&amp;quot; owner:self options:nil];
for(id item in nib) {

    if([is isKindOfClass:[youview class]]) {

    //找到了你自己需要得view
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;联系&quot;&gt;&lt;a href=&quot;#联系&quot; class=&quot;headerlink&quot; title=&quot;联系&quot;&gt;&lt;/a&gt;联系&lt;/h3&gt;&lt;p&gt; 可以使用此方法加载用户界面（xib文件）到我们的代码中，这样，可以通过操作这个加载进来的（xib）对象，来操作xib文件内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通知iOS</title>
    <link href="http://yoursite.com/2016/08/13/%E9%80%9A%E7%9F%A5iOS/"/>
    <id>http://yoursite.com/2016/08/13/通知iOS/</id>
    <published>2016-08-13T11:07:36.000Z</published>
    <updated>2016-08-13T11:09:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;发送通知-（在程序任何一个地方都可以发送通知）&quot;&gt;&lt;a href=&quot;#发送通知-（在程序任何一个地方都可以发送通知）&quot; class=&quot;headerlink&quot; title=&quot;发送通知 （在程序任何一个地方都可以发送通知）&quot;&gt;&lt;/a&gt;发送通知 （在程序任何一个地方都可以发送通知）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)getNotofocation {
    //发出通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;A类通知&amp;quot; object:self userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;注册通知&quot;&gt;&lt;a href=&quot;#注册通知&quot; class=&quot;headerlink&quot; title=&quot;注册通知&quot;&gt;&lt;/a&gt;注册通知&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver: self selector: @selector(callBack) name: @&amp;quot;A类通知&amp;quot;  object: nil  userInfo: nil];

Name: 消息名称 
object: 消息发送者 
userInfo: 消息传递的数据信息
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;定义回调&quot;&gt;&lt;a href=&quot;#定义回调&quot; class=&quot;headerlink&quot; title=&quot;定义回调&quot;&gt;&lt;/a&gt;定义回调&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)callBack {

    NSLog(@&amp;quot;我收到通知了！&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注销通知&quot;&gt;&lt;a href=&quot;#注销通知&quot; class=&quot;headerlink&quot; title=&quot;注销通知&quot;&gt;&lt;/a&gt;注销通知&lt;/h3&gt;&lt;p&gt;   a. 最优的方法，在 UIViewController.m 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc {

 [[NSNotificationCenter defaultCenter] removeObserver:self];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   b. 单个移除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;Notification_GetUserProfileSuccess&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;发送通知-（在程序任何一个地方都可以发送通知）&quot;&gt;&lt;a href=&quot;#发送通知-（在程序任何一个地方都可以发送通知）&quot; class=&quot;headerlink&quot; title=&quot;发送通知 （在程序任何一个地方都可以发送通知）&quot;&gt;&lt;/a&gt;发送通知 （在程序任何一个地方都可以发送通知）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)getNotofocation {
    //发出通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;A类通知&amp;quot; object:self userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>控制器初始化方法</title>
    <link href="http://yoursite.com/2016/08/13/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/13/控制器初始化方法/</id>
    <published>2016-08-13T11:03:07.000Z</published>
    <updated>2016-08-13T11:06:34.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;控制器初始化方法&quot;&gt;&lt;a href=&quot;#控制器初始化方法&quot; class=&quot;headerlink&quot; title=&quot;控制器初始化方法&quot;&gt;&lt;/a&gt;控制器初始化方法&lt;/h3&gt;&lt;h4 id=&quot;viewWillAppear&quot;&gt;&lt;a href=&quot;#viewWillAppear&quot; class=&quot;headerlink&quot; title=&quot;viewWillAppear&quot;&gt;&lt;/a&gt;viewWillAppear&lt;/h4&gt;&lt;p&gt;视图即将可见时调用。默认情况下不执行任何操作。 Called when the view is about to made visible. Default does nothing&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;viewDidAppear&quot;&gt;&lt;a href=&quot;#viewDidAppear&quot; class=&quot;headerlink&quot; title=&quot;viewDidAppear&quot;&gt;&lt;/a&gt;viewDidAppear&lt;/h4&gt;&lt;p&gt;视图已完全过渡到屏幕上时调用。。默认情况下不执行任何操作。 Called when the view has been fully transitioned onto the screen. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewWillDisappear&quot;&gt;&lt;a href=&quot;#viewWillDisappear&quot; class=&quot;headerlink&quot; title=&quot;viewWillDisappear&quot;&gt;&lt;/a&gt;viewWillDisappear&lt;/h4&gt;&lt;p&gt;视图被消失时调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作。 Called when the view is dismissed, covered or otherwise hidden. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewDidDisappear&quot;&gt;&lt;a href=&quot;#viewDidDisappear&quot; class=&quot;headerlink&quot; title=&quot;viewDidDisappear&quot;&gt;&lt;/a&gt;viewDidDisappear&lt;/h4&gt;&lt;p&gt;视图被消失后调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作。 Called after the view was dismissed, covered or otherwise hidden. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewDidLoad&quot;&gt;&lt;a href=&quot;#viewDidLoad&quot; class=&quot;headerlink&quot; title=&quot;viewDidLoad&quot;&gt;&lt;/a&gt;viewDidLoad&lt;/h4&gt;&lt;p&gt;在视图加载后被调用，如果是在代码中创建的视图加载器，他将会在loadView方法后被调用，如果是从nib视图页面输出，他将会在视图设置好后后被调用。&lt;br&gt;Called after the view has been loaded. For view controllers created in code, this is after -loadView. For view controllers unarchived from a nib, this is after the view is set.&lt;/p&gt;
&lt;h4 id=&quot;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot;&gt;&lt;a href=&quot;#「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot; class=&quot;headerlink&quot; title=&quot;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot;&gt;&lt;/a&gt;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&lt;/h4&gt;&lt;h4 id=&quot;视图控制器发生旋转调用的方法&quot;&gt;&lt;a href=&quot;#视图控制器发生旋转调用的方法&quot; class=&quot;headerlink&quot; title=&quot;视图控制器发生旋转调用的方法&quot;&gt;&lt;/a&gt;视图控制器发生旋转调用的方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&amp;lt;UIViewControllerTransitionCoordinator&amp;gt;)coordinator {

     NSLog(@&amp;quot;%f&amp;quot;, size.height);
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;当一个视图控制器被创建，并在屏幕上显示的时候。-代码的执行顺序&quot;&gt;&lt;a href=&quot;#当一个视图控制器被创建，并在屏幕上显示的时候。-代码的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序&quot;&gt;&lt;/a&gt;当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、 alloc                   创建对象，分配空间

2、init (initWithNibName)    初始化对象，初始化数据

3、loadView                  从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图

4、viewDidLoad               载入完成，可以进行自定义数据以及动态创建其他控件

5、viewWillAppear            视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了

6、viewDidAppear             视图已在屏幕上渲染完成
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot;&gt;&lt;a href=&quot;#当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot; class=&quot;headerlink&quot; title=&quot;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot;&gt;&lt;/a&gt;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、viewWillDisappear          视图将被从屏幕上移除之前执行

2、viewDidDisappear           视图已经被从屏幕上移除，用户看不到这个视图了

3、dealloc                    视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;控制器初始化方法&quot;&gt;&lt;a href=&quot;#控制器初始化方法&quot; class=&quot;headerlink&quot; title=&quot;控制器初始化方法&quot;&gt;&lt;/a&gt;控制器初始化方法&lt;/h3&gt;&lt;h4 id=&quot;viewWillAppear&quot;&gt;&lt;a href=&quot;#viewWillAppear&quot; class=&quot;headerlink&quot; title=&quot;viewWillAppear&quot;&gt;&lt;/a&gt;viewWillAppear&lt;/h4&gt;&lt;p&gt;视图即将可见时调用。默认情况下不执行任何操作。 Called when the view is about to made visible. Default does nothing&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应者</title>
    <link href="http://yoursite.com/2016/08/07/%E5%93%8D%E5%BA%94%E8%80%85/"/>
    <id>http://yoursite.com/2016/08/07/响应者/</id>
    <published>2016-08-07T11:25:04.000Z</published>
    <updated>2016-08-07T11:27:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;响应者对象（Response-object）&quot;&gt;&lt;a href=&quot;#响应者对象（Response-object）&quot; class=&quot;headerlink&quot; title=&quot;响应者对象（Response object）&quot;&gt;&lt;/a&gt;响应者对象（Response object）&lt;/h3&gt;&lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一响应者（First-responder）&quot;&gt;&lt;a href=&quot;#第一响应者（First-responder）&quot; class=&quot;headerlink&quot; title=&quot;第一响应者（First responder）&quot;&gt;&lt;/a&gt;第一响应者（First responder）&lt;/h3&gt;&lt;p&gt;当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。&lt;/p&gt;
&lt;h3 id=&quot;响应者链（Responder-chain）&quot;&gt;&lt;a href=&quot;#响应者链（Responder-chain）&quot; class=&quot;headerlink&quot; title=&quot;响应者链（Responder chain）&quot;&gt;&lt;/a&gt;响应者链（Responder chain）&lt;/h3&gt;&lt;p&gt;响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件&lt;/p&gt;
&lt;h3 id=&quot;管理事件分发&quot;&gt;&lt;a href=&quot;#管理事件分发&quot; class=&quot;headerlink&quot; title=&quot;管理事件分发&quot;&gt;&lt;/a&gt;管理事件分发&lt;/h3&gt;&lt;p&gt;视图对触摸事件是否需要作处回应可以通过设置视图的userInteractionEnabled属性。默认状态为YES，如果设置为NO，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏（setHidden：YES）或者透明（alpha值为0）也不会收事件。不过这个属性只对视图有效，如果想要整个程序都步响应事件，可以调用UIApplication的beginIngnoringInteractionEvents方法来完全停止事件接收和分发。通过endIngnoringInteractionEvents方法来恢复让程序接收和分发事件。如果要让视图接收多点触摸，需要设置它的multipleTouchEnabled属性为YES，默认状态下这个属性值为NO，即视图默认不接收多点触摸。&lt;/p&gt;
&lt;h3 id=&quot;处理用户的触摸事件&quot;&gt;&lt;a href=&quot;#处理用户的触摸事件&quot; class=&quot;headerlink&quot; title=&quot;处理用户的触摸事件&quot;&gt;&lt;/a&gt;处理用户的触摸事件&lt;/h3&gt;&lt;p&gt;首先触摸的对象是视图，而视图的类UIView继承了UIRespnder类，但是要对事件作出处理，还需要重写UIResponder类中定义的事件处理函数。根据不通的触摸状态，程序会调用相应的处理函数，这些函数包括以下几个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;

当手指接触屏幕时，就会调用touchesBegan:withEvent方法；

当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；

当手指离开屏幕时，就会调用touchesEnded:withEvent方法；

当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。而这几个方法被调用时，正好对应了UITouch类中phase属性的4个枚举值。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的四个事件方法，在开发过程中并不要求全部实现，可以根据需要重写特定的方法。对于这4个方法，都有两个相同的参数：NSSet类型的touches和UIEvent类型的event。其中touches表示触摸产生的所有UITouch对象，而event表示特定的事件。因为UIEvent包含了整个触摸过程中所有的触摸对象，因此可以调用allTouches方法获取该事件内所有的触摸对象，也可以调用touchesForVIew：或者touchesForWindows：取出特定视图或者窗口上的触摸对象。在这几个事件中，都可以拿到触摸对象，然后根据其位置，状态，时间属性做逻辑处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;响应者对象（Response-object）&quot;&gt;&lt;a href=&quot;#响应者对象（Response-object）&quot; class=&quot;headerlink&quot; title=&quot;响应者对象（Response object）&quot;&gt;&lt;/a&gt;响应者对象（Response object）&lt;/h3&gt;&lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定时器用法总结</title>
    <link href="http://yoursite.com/2016/08/07/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/08/07/定时器用法总结/</id>
    <published>2016-08-07T11:18:19.000Z</published>
    <updated>2016-08-07T11:19:17.000Z</updated>
    
    <content type="html">&lt;p&gt;NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下：&lt;/p&gt;
&lt;h3 id=&quot;方法-1&quot;&gt;&lt;a href=&quot;#方法-1&quot; class=&quot;headerlink&quot; title=&quot;方法 1&quot;&gt;&lt;/a&gt;方法 1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSInvocation *invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(f)]];
[invo setTarget:self];
[invo setSelector:@selector(myLog)];
time = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES];
[time fire];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;方法-2&quot;&gt;&lt;a href=&quot;#方法-2&quot; class=&quot;headerlink&quot; title=&quot;方法 2&quot;&gt;&lt;/a&gt;方法 2&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;time = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
[time fire];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法-3&quot;&gt;&lt;a href=&quot;#方法-3&quot; class=&quot;headerlink&quot; title=&quot;方法 3&quot;&gt;&lt;/a&gt;方法 3&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;time = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:YES];
[time fire];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法-4&quot;&gt;&lt;a href=&quot;#方法-4&quot; class=&quot;headerlink&quot; title=&quot;方法 4&quot;&gt;&lt;/a&gt;方法 4&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSInvocation *invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(myLog)]];
[invo setTarget:self];
[invo setSelector:@selector(myLog)];
time = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES];
[time fire];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法-5&quot;&gt;&lt;a href=&quot;#方法-5&quot; class=&quot;headerlink&quot; title=&quot;方法 5&quot;&gt;&lt;/a&gt;方法 5&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;time = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(myLog) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;关于内存释放&quot;&gt;&lt;a href=&quot;#关于内存释放&quot; class=&quot;headerlink&quot; title=&quot;关于内存释放&quot;&gt;&lt;/a&gt;关于内存释放&lt;/h3&gt;&lt;p&gt;   如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[timer invalidate];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下：&lt;/p&gt;
&lt;h3 id=&quot;方法-1&quot;&gt;&lt;a href=&quot;#方法-1&quot; class=&quot;headerlink&quot; title=&quot;方法 1&quot;&gt;&lt;/a&gt;方法 1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSInvocation *invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(f)]];
[invo setTarget:self];
[invo setSelector:@selector(myLog)];
time = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES];
[time fire];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 中实现多线程</title>
    <link href="http://yoursite.com/2016/08/07/Objective-C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/07/Objective-C-中实现多线程/</id>
    <published>2016-08-07T11:13:29.000Z</published>
    <updated>2016-08-07T11:17:16.000Z</updated>
    
    <content type="html">&lt;p&gt;在多核 CPU 时代，由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。&lt;/p&gt;
&lt;h3 id=&quot;performSelectors&quot;&gt;&lt;a href=&quot;#performSelectors&quot; class=&quot;headerlink&quot; title=&quot;performSelectors&quot;&gt;&lt;/a&gt;performSelectors&lt;/h3&gt;&lt;p&gt; NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在指定线程中，或者立即，或者延迟执行某个方法调用。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)performSelector:(SEL)aSelector
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument withObject:(id)anArgument
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay: (NSTimeInterval)delay inModes:(NSArray *)modes

// 在指定线程中执行方法
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject: (id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array
// 在主线程中执行方法
- (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array

// 在后台线程中执行方法
- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  这一系列方法简单易用:指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。&lt;/p&gt;
&lt;h3 id=&quot;NSThread&quot;&gt;&lt;a href=&quot;#NSThread&quot; class=&quot;headerlink&quot; title=&quot;NSThread&quot;&gt;&lt;/a&gt;NSThread&lt;/h3&gt;&lt;p&gt;   NSThread 是 OS X 和 iOS 都提供的一个线程对象，它是线程的一个轻量级实现。在执行一些轻量级的简单任务时，NSThread 很有用，但用户仍然需要自己管理线程生命周期，进行线程间同步。比如，线程状态，依赖性，线程间同步等线程相关的主题 NSThread 都没有涉及。比如，涉及到线程间同步仍然需要配合使用 NSLock，NSCondition 或者 @synchronized。所以，遇到复杂任务时，轻量级的 NSThread 可能并不合适。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)run {
    while (TRUE) {
        [_lock lock];
        if(_cake &amp;gt; 0){
            [NSThread sleepForTimeInterval:0.5];
            _cake--;
            _occupied = kSum - _cake;
            NSLog(@&amp;quot;Taken by %@\nCurrent free:%ld, occupied: %ld&amp;quot;, [[NSThread currentThread] name], _cake, _occupied);
        }
        [_lock unlock];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSOperation&quot;&gt;&lt;a href=&quot;#NSOperation&quot; class=&quot;headerlink&quot; title=&quot;NSOperation&quot;&gt;&lt;/a&gt;NSOperation&lt;/h3&gt;&lt;p&gt;NSOperation 做的事情比 NSThread 更多一些。通过继承 NSOperation，可以使子类获得一些线程相关的特性，进而可以安全地管理线程生命周期。&lt;br&gt;比如，以线程安全的方式建立状态，取消线程。配合 NSOperationQueue，可以控制线程间的优先级和依赖性。这就给出了一套线程管理的基本方法。NSOperation 代表了一个独立的计算单元。一般，我们会把计算任务封装进 NSOperation 这个对象。NSOperation 是抽象类，但同时也提供了两个可以直接使用的实体子类：NSInvocationOperation 和 NSBlockOperation。NSInvocationOperation 用于将计算任务封装进方法，NSBlockOperation 用于将计算任务封装进 block。NSOperationQueue 则用于执行计算任务，管理计算任务的优先级，处理计算任务之间的依赖性。NSOperation 被添加到 NSOperationQueue 中之后，队列会按优先级和进入顺序调度任务，NSOperation 对象会被自动执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSOperation 提供以下任务优先级，以这些优先级设置变量 queuePriority 即可加快或者推迟操作的执行：
NSOperationQueuePriorityVeryHigh
NSOperationQueuePriorityHigh
NSOperationQueuePriorityNormal
NSOperationQueuePriorityLow
NSOperationQueuePriorityVeryLow

NSOperation 使用状态机模型来表示状态。通常，你可以使用 KVO（Key-Value Observing）观察任务的执行状态。这是其他多线程工具所不具备的功能。NSOperation 提供以下状态：
    isReady
    isExecuting
    isFinished
NSOperation 对象之间的依赖性可以用如下代码表示：
 [refreshUIOperation addDependency:requestDataOperation]; [operationQueue addOperation:requestDataOperation]; [operationQueue addOperation:refreshUIOperation];
除非 requestDataOperation 的状态 isFinished 返回 YES，不然 refreshUIOperation 这个操作不会开始。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在多核 CPU 时代，由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。&lt;/p&gt;
&lt;h3 id=&quot;performSelectors&quot;&gt;&lt;a href=&quot;#performSelectors&quot; class=&quot;headerlink&quot; title=&quot;performSelectors&quot;&gt;&lt;/a&gt;performSelectors&lt;/h3&gt;&lt;p&gt; NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在指定线程中，或者立即，或者延迟执行某个方法调用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结4</title>
    <link href="http://yoursite.com/2016/08/07/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%934/"/>
    <id>http://yoursite.com/2016/08/07/iOS特别技能点总结4/</id>
    <published>2016-08-07T11:06:12.000Z</published>
    <updated>2016-08-07T11:10:29.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot;&gt;&lt;a href=&quot;#iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot; class=&quot;headerlink&quot; title=&quot;iOS－获取的NSDate date时间与实际相差8个小时解决方案&quot;&gt;&lt;/a&gt;iOS－获取的NSDate date时间与实际相差8个小时解决方案&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDate *date = [NSDate date];
NSTimeZone *zone = [NSTimeZone systemTimeZone];
NSInteger interval = [zone secondsFromGMTForDate: date];
NSDate *localeDate = [date  dateByAddingTimeInterval: interval]; 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;iOS编程-XCode-Debug忽略SIGPIPE信号&quot;&gt;&lt;a href=&quot;#iOS编程-XCode-Debug忽略SIGPIPE信号&quot; class=&quot;headerlink&quot; title=&quot;iOS编程-XCode Debug忽略SIGPIPE信号&quot;&gt;&lt;/a&gt;iOS编程-XCode Debug忽略SIGPIPE信号&lt;/h3&gt;&lt;p&gt;在 main.m 中添加&lt;br&gt;     signal(SIGPIPE, SIG_IGN);&lt;br&gt;debug的时候, 忽略SIGPIPE是不起作用的. &lt;/p&gt;
&lt;h3 id=&quot;UITableView最上面tableHeaderView留空间的两种方法&quot;&gt;&lt;a href=&quot;#UITableView最上面tableHeaderView留空间的两种方法&quot; class=&quot;headerlink&quot; title=&quot;UITableView最上面tableHeaderView留空间的两种方法&quot;&gt;&lt;/a&gt;UITableView最上面tableHeaderView留空间的两种方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. UIView *headerView = [[UIView alloc] initWithFrame: CGRectMake(0, 0, 320, 44)];
   m_tableView.tableHeaderView = headerView;

2. m_tableView.contentInset = UIEdgeInsetsMake(44, 0, 0, 0);
   m_tableView.scrollIndicatorInsets = UIEdgeInsetsMake(44, 0, 0, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;iOS-函数&quot;&gt;&lt;a href=&quot;#iOS-函数&quot; class=&quot;headerlink&quot; title=&quot;iOS 函数&quot;&gt;&lt;/a&gt;iOS 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// ceil：如果参数是小数，则求最小的整数但不小于本身
NSLog(@&amp;quot;%f&amp;quot;,  ceilf(1.0000002)); // 7
NSLog(@&amp;quot;%f&amp;quot;,   ceil(1.000000000000001)); // 15
NSLog(@&amp;quot;%Lf&amp;quot;, ceill(1.000000000000001)); // 15

// round：如果参数是小数，则求本身的四舍五入。
NSLog(@&amp;quot;%f&amp;quot;, round(10.0000000004));
NSLog(@&amp;quot;%f&amp;quot;, roundf(10.5));
NSLog(@&amp;quot;%Lf&amp;quot;, roundl(10));

// floor：如果参数是小数，则求最大的整数但不大于本身.
NSLog(@&amp;quot;%f&amp;quot;, floor(10.00001));
NSLog(@&amp;quot;%f&amp;quot;, floorf(12.4));
NSLog(@&amp;quot;%Lf&amp;quot;, floorl(10.54));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ios9中设置状态栏颜色与隐藏&quot;&gt;&lt;a href=&quot;#ios9中设置状态栏颜色与隐藏&quot; class=&quot;headerlink&quot; title=&quot;ios9中设置状态栏颜色与隐藏&quot;&gt;&lt;/a&gt;ios9中设置状态栏颜色与隐藏&lt;/h3&gt;&lt;p&gt;1.iOS中设置状态栏的样式由 最顶层的UIWindow所在的控制器控制处理。&lt;br&gt;2.ios9之前可以不用设置window的根控制器，ios9必须设置根控制器。&lt;br&gt;3.ios9后设置状态栏的样式(隐藏)时，在最顶层的UIWindow所在的控制器中通过下面两个方法处理  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UIStatusBarStyle)preferredStatusBarStyle {   //设置样式
 return  UIStatusBarStyleLightContent;
}

- (BOOL)prefersStatusBarHidden { //设置隐藏显示
 return NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   通过&lt;br&gt;    [[UIApplication sharedApplication] setStatusBarHidden:BOOL];&lt;br&gt;    [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyle)];&lt;br&gt;   设置不太好使。&lt;br&gt;4.ios9中如果创建多个window，则改变状态栏的样式，只能在最顶层的window中的控制器中设置状态栏样式才有效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：设置两个Window,通过在最顶层的window中的控制器中设置状态栏样式更改转态栏
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot;&gt;&lt;a href=&quot;#iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot; class=&quot;headerlink&quot; title=&quot;iOS－获取的NSDate date时间与实际相差8个小时解决方案&quot;&gt;&lt;/a&gt;iOS－获取的NSDate date时间与实际相差8个小时解决方案&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDate *date = [NSDate date];
NSTimeZone *zone = [NSTimeZone systemTimeZone];
NSInteger interval = [zone secondsFromGMTForDate: date];
NSDate *localeDate = [date  dateByAddingTimeInterval: interval]; 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多种方式搭建tableViewCell</title>
    <link href="http://yoursite.com/2016/07/30/%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAtableViewCell/"/>
    <id>http://yoursite.com/2016/07/30/多种方式搭建tableViewCell/</id>
    <published>2016-07-30T13:46:44.000Z</published>
    <updated>2016-07-30T13:52:22.000Z</updated>
    
    <content type="html">&lt;p&gt;创建 UITableViewCell 的方式主要有四种，使用系统自带的 cell 样式，自定义的继承 UITableViewCell 的方式 ， xib 创建 cell 和 sb 中创建 cell。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单的代码添加&quot;&gt;&lt;a href=&quot;#简单的代码添加&quot; class=&quot;headerlink&quot; title=&quot;简单的代码添加&quot;&gt;&lt;/a&gt;简单的代码添加&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//直接在UITableViewCell的生成方法中实现，代码如下
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *identifier = @&amp;quot;cell&amp;quot;;
    UITableViewCell  *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
    if (cell == nil) {

        cell = [[UITableViewCell  alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
        UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(190, 0, 130, cell.frame.size.height)];
        label1.tag = 1;
        [cell.contentView addSubview:label1];
    }
    UILabel *label3 = (UILabel *)[cell.contentView viewWithTag:1];
    label3.text = @&amp;quot;44444&amp;quot;;
    return cell;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义的继承UITableViewCell的类&quot;&gt;&lt;a href=&quot;#自定义的继承UITableViewCell的类&quot; class=&quot;headerlink&quot; title=&quot;自定义的继承UITableViewCell的类&quot;&gt;&lt;/a&gt;自定义的继承UITableViewCell的类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;.h
   @interface Cell3 : UITableViewCell {

       UILabel *_label1;
       UILabel *_label2;
   }

   - (void)setLabel1Text:(NSString *)text1
              label2Text:(NSString *)text2;

   @end

.m
   @implementation Cell3

   - (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
   {
       self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
       if (self) {

           _label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 160, self.frame.size.height)];
           [self.contentView addSubview:_label1];
           _label2 = [[UILabel alloc] initWithFrame:CGRectMake(160, 0, 160, self.frame.size.height)];
           [self.contentView addSubview:_label2];
       }
       return self;
   }

   - (void)setLabel1Text:(NSString *)text1 label2Text:(NSString *)text2
   {
       _label1.text = text1;
       _label2.text = text2;
   }

控制器中的写法

   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
   {
       static NSString *identifier = @&amp;quot;cell&amp;quot;;
       Cell3 *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
       if (cell == nil) {

           cell = [[Cell3 alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
       }
       [cell setLabel1Text:@&amp;quot;2222&amp;quot; label2Text:@&amp;quot;3333&amp;quot;];
       return cell;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;xib-创建-cell&quot;&gt;&lt;a href=&quot;#xib-创建-cell&quot; class=&quot;headerlink&quot; title=&quot;xib 创建 cell&quot;&gt;&lt;/a&gt;xib 创建 cell&lt;/h3&gt;&lt;p&gt;  1.先在 xib 中设置 Identifier 设置&lt;/p&gt;
&lt;p&gt;  2.声明 [self.tableView registerNib:[UINib nibWithNibName:@”Cell2” bundle:[NSBundle mainBundle]] forCellReuseIdentifier:@”Cell2”];&lt;/p&gt;
&lt;p&gt;  3.在控制器的 UITableView 代理中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {

      Cell2 *cell = [tableView dequeueReusableCellWithIdentifier:@&amp;quot;Cell2&amp;quot;];
      cell.numLabe.text = @&amp;quot;123&amp;quot;;
      return cell;
   }
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;创建 UITableViewCell 的方式主要有四种，使用系统自带的 cell 样式，自定义的继承 UITableViewCell 的方式 ， xib 创建 cell 和 sb 中创建 cell。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> 库管理工具</title>
    <link href="http://yoursite.com/2016/07/18/%E5%BA%93%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2016/07/18/库管理工具/</id>
    <published>2016-07-18T14:12:13.000Z</published>
    <updated>2016-07-18T14:15:56.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Cocoapods安装步骤&quot;&gt;&lt;a href=&quot;#Cocoapods安装步骤&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods安装步骤&quot;&gt;&lt;/a&gt;Cocoapods安装步骤&lt;/h3&gt;&lt;p&gt;1.升级Ruby环境  sudo gem update – system&lt;/p&gt;
&lt;p&gt;2.安装CocoaPods时我们要访问cocoapods.org，用淘宝的RubyGems镜像来代替官方版本，执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gem sources --remove https://rubygems.org/
//等有反应之后再敲入以下命令
$ gem sources -a https://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;为了验证你的Ruby镜像是并且仅是taobao，可以用以下命令查看： $ gem sources -l&lt;/p&gt;
&lt;p&gt;3.安装 Cocoapods&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo gem install -n /usr/local/bin cocoapods
再加一句，完美解决
sudo xcode-select --switch /Applications/Xcode.app

在终端中输入如下命令来完成安装：

//将 CocoaPods Specs repository复制到你电脑上~/.cocoapods目录下
pod setup

如果安装失败 ~/.cocoapods 里面是空的，就需要重新setup
命令如下：


pod repo remove master  
pod setup
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Cocoapods使用&quot;&gt;&lt;a href=&quot;#Cocoapods使用&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods使用&quot;&gt;&lt;/a&gt;Cocoapods使用&lt;/h3&gt;&lt;p&gt;1.使用search命令搜索类库名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pod search AFNetworking
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.打开xcode,新建一个工程，工程名为CocoapodsSample。&lt;/p&gt;
&lt;p&gt;  使用命令cd，cd后面跟的是工程目录名，可以直接拉进来，回车后，输入命令创建Podfile文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ touch Podfile
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.使用vim编辑podfile文件，使用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vim Podfile

然后在Podfile文件中输入以下文字：

platform :ios, &amp;apos;7.0&amp;apos;
pod &amp;quot;AFNetworking&amp;quot;, &amp;quot;2.5.0&amp;quot;

在编辑完后按 esc,然后按&amp;quot;:&amp;quot;,这个时候输入wq保存退出
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.这时候，你就可以利用CocoPods下载AFNetworking类库了。还是在终端中的当前项目目录下，运行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pod install 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 如果有一些包已经存在了，或者我们更改了Podfile里面的版本，可以使用以下命令更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pod update
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 注：&lt;br&gt;  关于Podfile文件编辑时，第三方库版本号的各种写法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pod ‘AFNetworking’      //不显式指定依赖库版本，表示每次都获取最新版本
pod ‘AFNetworking’,  ‘2.0’     //只使用2.0版本
pod ‘AFNetworking’, ‘&amp;gt;2.0′     //使用高于2.0的版本
pod ‘AFNetworking’, ‘&amp;gt;=2.0′     //使用大于或等于2.0的版本
pod ‘AFNetworking’, ‘&amp;lt;2.0′     //使用小于2.0的版本
pod ‘AFNetworking’, ‘&amp;lt;=2.0′     //使用小于或等于2.0的版本
pod ‘AFNetworking’, ‘~&amp;gt;0.1.2′     //使用大于等于0.1.2但小于0.2的版本，相当于&amp;gt;=0.1.2并且&amp;lt;0.2.0
pod ‘AFNetworking’, ‘~&amp;gt;0.1′     //使用大于等于0.1但小于1.0的版本
pod ‘AFNetworking’, ‘~&amp;gt;0′     //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Cocoapods安装步骤&quot;&gt;&lt;a href=&quot;#Cocoapods安装步骤&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods安装步骤&quot;&gt;&lt;/a&gt;Cocoapods安装步骤&lt;/h3&gt;&lt;p&gt;1.升级Ruby环境  sudo gem update – system&lt;/p&gt;
&lt;p&gt;2.安装CocoaPods时我们要访问cocoapods.org，用淘宝的RubyGems镜像来代替官方版本，执行以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ gem sources --remove https://rubygems.org/
//等有反应之后再敲入以下命令
$ gem sources -a https://ruby.taobao.org/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>视图控制器的父-子关系</title>
    <link href="http://yoursite.com/2016/07/10/%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E7%88%B6-%E5%AD%90%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2016/07/10/视图控制器的父-子关系/</id>
    <published>2016-07-10T12:58:37.000Z</published>
    <updated>2016-07-10T13:15:31.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;addChildViewController-优点&quot;&gt;&lt;a href=&quot;#addChildViewController-优点&quot; class=&quot;headerlink&quot; title=&quot;addChildViewController 优点&quot;&gt;&lt;/a&gt;addChildViewController 优点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.页面逻辑很清晰，相应的View对应相应的ViewController。
2.当某个子View没有显示时，将不会被Load，减少了内存的使用。
3.当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;在iOS-5-0及以后，iOS为UIViewController类添加了新的属性和方法：&quot;&gt;&lt;a href=&quot;#在iOS-5-0及以后，iOS为UIViewController类添加了新的属性和方法：&quot; class=&quot;headerlink&quot; title=&quot;在iOS 5.0及以后，iOS为UIViewController类添加了新的属性和方法：&quot;&gt;&lt;/a&gt;在iOS 5.0及以后，iOS为UIViewController类添加了新的属性和方法：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;@property(nonatomic,readonly) NSArray *childViewControllers
- (void)addChildViewController:(UIViewController *)childController
- (void) removeFromParentViewController
- (void)transitionFromViewController：：：：：：
- (void)willMoveToParentViewController:(UIViewController *)parent
- (void)didMoveToParentViewController:(UIViewController *)parent
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，就能够将一个页面中的UIViewController控制起来，而不是混乱的共用一个UIViewController，最重要的是，编程习惯的革命：&lt;br&gt;&lt;strong&gt;降低了功能的耦合度！&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-父视图控制器-addChildViewController-子视图控制器&quot;&gt;&lt;a href=&quot;#1-父视图控制器-addChildViewController-子视图控制器&quot; class=&quot;headerlink&quot; title=&quot;1. [父视图控制器 addChildViewController:子视图控制器];&quot;&gt;&lt;/a&gt;1. [父视图控制器 addChildViewController:子视图控制器];&lt;/h4&gt;&lt;p&gt;在此，图控制器A添加了另一个图控制器B，那么A充当父视图控制器，B充当子视图控制器。父视图控制器充当了视图控制器容器的角色。当要添加的子视图控制器已经包含在视图控制器容器中，那么，相当于先从父视图控制器中删除，然后重新添加到父视图控制器中。&lt;/p&gt;
&lt;h4 id=&quot;2-void-removeFromParentViewController-从父视图控制器中删除。&quot;&gt;&lt;a href=&quot;#2-void-removeFromParentViewController-从父视图控制器中删除。&quot; class=&quot;headerlink&quot; title=&quot;2. - (void)removeFromParentViewController 从父视图控制器中删除。&quot;&gt;&lt;/a&gt;2. - (void)removeFromParentViewController 从父视图控制器中删除。&lt;/h4&gt;&lt;h4 id=&quot;3-void-transitionFromViewController：：：：：：&quot;&gt;&lt;a href=&quot;#3-void-transitionFromViewController：：：：：：&quot; class=&quot;headerlink&quot; title=&quot;3.- (void)transitionFromViewController：：：：：：&quot;&gt;&lt;/a&gt;3.- (void)transitionFromViewController：：：：：：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt; - (void)transitionFromViewController:(UIViewController *)fromViewController 
  toViewController:(UIViewController *)toViewController  duration:(NSTimeInterval)duration  
  options:(UIViewAnimationOptions)options  animations:(void (^)(void))animations  
  completion:(void (^)(BOOL finished))completion
交换两个子视图控制器的位置（由于添加的顺序不同，所以子试图控制器在父视图控制器中存在层次关系）
fromViewController：当前显示的子试图控制器，将被替换为非显示状态
toViewController：将要显示的子视图控制器
duration：交换动画持续的时间，单位秒
options：动画的方式
animations：动画Block
completion：完成后执行的Block
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;4-void-willMoveToParentViewController-UIViewController-parent&quot;&gt;&lt;a href=&quot;#4-void-willMoveToParentViewController-UIViewController-parent&quot; class=&quot;headerlink&quot; title=&quot;4. - (void)willMoveToParentViewController:(UIViewController *)parent&quot;&gt;&lt;/a&gt;4. - (void)willMoveToParentViewController:(UIViewController *)parent&lt;/h4&gt;&lt;p&gt;当一个视图控制器从视图控制器容器中被添加或者被删除之前，该方法被调用&lt;br&gt;parent：父视图控制器，如果没有父视图控制器，将为nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当我们向我们的视图控制器容器中调用removeFromParentViewController方法时，必须要先调用该方法，且parent参数为nil：
[将要删除的视图控制器 willMoveToParentViewController:nil];
2. 当我们调用addChildViewController方法时，不需要显示调用。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;5-void-didMoveToParentViewController-UIViewController-parent&quot;&gt;&lt;a href=&quot;#5-void-didMoveToParentViewController-UIViewController-parent&quot; class=&quot;headerlink&quot; title=&quot;5. - (void)didMoveToParentViewController:(UIViewController *)parent&quot;&gt;&lt;/a&gt;5. - (void)didMoveToParentViewController:(UIViewController *)parent&lt;/h4&gt;&lt;p&gt; 当从一个视图控制容器中添加或者移除viewController后，该方法被调用。&lt;br&gt; parent：父视图控制器，如果没有父视图控制器，将为nil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 当我们向我们的视图控制器容器中调用addChildViewController方法时，必须要先调用该方法，且parent参数为 self：
2. 当我们调用removeFromParentViewController方法时，不需要显示调用该方法。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注: 需要在transitionFromViewController方法之前调用：[子视图控制器 willMoveToParentViewController:nil];&lt;br&gt;    之后，调用[子视图控制器didMoveToParentViewController:父视图控制器];&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;addChildViewController-优点&quot;&gt;&lt;a href=&quot;#addChildViewController-优点&quot; class=&quot;headerlink&quot; title=&quot;addChildViewController 优点&quot;&gt;&lt;/a&gt;addChildViewController 优点&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.页面逻辑很清晰，相应的View对应相应的ViewController。
2.当某个子View没有显示时，将不会被Load，减少了内存的使用。
3.当内存紧张时，没有Load的View将被首先释放，优化了程序的内存释放机制。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC的三大新特性</title>
    <link href="http://yoursite.com/2016/06/30/OC%E7%9A%84%E4%B8%89%E5%A4%A7%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/06/30/OC的三大新特性/</id>
    <published>2016-06-30T12:00:50.000Z</published>
    <updated>2016-06-30T12:05:05.000Z</updated>
    
    <content type="html">&lt;p&gt;三个主要的新特性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nullability             判空性
Lightweight Generics    轻量级泛型
__kindof
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Nullability&quot;&gt;&lt;a href=&quot;#Nullability&quot; class=&quot;headerlink&quot; title=&quot;Nullability&quot;&gt;&lt;/a&gt;Nullability&lt;/h3&gt;&lt;p&gt;接口中 nullable 的是少数，所以为了防止写一大堆 nonnull，Foundation 还提供了一对儿宏，包在里面的对象默认加 nonnull 修饰符，只需要把 nullable 的指出来就行，黑话叫 Audited Regions。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NS_ASSUME_NONNULL_BEGIN
NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。不过我想更大的意义在于能够更加清楚的描述接口，是主调者和被调者间的一个协议，比多少句文档描述都来得清晰。&lt;/p&gt;
&lt;p&gt;打个比方：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable instancetype)URLWithString:(NSString *)URLString;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;NSURL 的这个 API 前面加了 nullable 后，更加显式的指出了这个接口可能因为 URLString 的格式错误而创建失败，使用时自然而然的就考虑到了判空处理。&lt;/p&gt;
&lt;p&gt;不仅是属性和方法中的对象，对于局部的对象、甚至 c 指针都可以用带双下划线的修饰符，可以理解成能用 const 关键字的地方都能用 Nullability。&lt;/p&gt;
&lt;p&gt;所以 Nullability 总的来说就是，写着丑B，用着舒服 - -&lt;/p&gt;
&lt;h3 id=&quot;Lightweight-Generics-轻量级泛型&quot;&gt;&lt;a href=&quot;#Lightweight-Generics-轻量级泛型&quot; class=&quot;headerlink&quot; title=&quot;Lightweight Generics  轻量级泛型&quot;&gt;&lt;/a&gt;Lightweight Generics  轻量级泛型&lt;/h3&gt;&lt;p&gt;轻量是因为这是个纯编译器的语法支持（llvm 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSArray&amp;lt;nsstring *&amp;gt; *strings = @[@&amp;quot;sun&amp;quot;, @&amp;quot;yuan&amp;quot;];
@property (readonly) NSArray&amp;lt;nsurl *&amp;gt; *imageURLs;

自定义一个 Stack 容器类：

@interface Stack&amp;lt;objecttype&amp;gt; : NSObject

- (void)pushObject:(ObjectType)object;

- (ObjectType)popObject;

@property (nonatomic, readonly) NSArray&amp;lt;objecttype&amp;gt; *allObjects;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 ok，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 只接受 NSNumber * 的泛型
@interface Stack&amp;lt;objecttype: nsnumber *&amp;gt; : NSObject


__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）

__contravariant - 逆变性，父类型可以强转到子类型（WTF?）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符&lt;/p&gt;
&lt;h3 id=&quot;kindof&quot;&gt;&lt;a href=&quot;#kindof&quot; class=&quot;headerlink&quot; title=&quot;__kindof&quot;&gt;&lt;/a&gt;__kindof&lt;/h3&gt;&lt;p&gt;__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;既明确表明了返回值，又让使用者不必写强转。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;三个主要的新特性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Nullability             判空性
Lightweight Generics    轻量级泛型
__kindof
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> storyboard之prepareForSegue</title>
    <link href="http://yoursite.com/2016/06/02/storyboard%E4%B9%8BprepareForSegue/"/>
    <id>http://yoursite.com/2016/06/02/storyboard之prepareForSegue/</id>
    <published>2016-06-02T13:41:03.000Z</published>
    <updated>2016-06-02T13:43:30.000Z</updated>
    
    <content type="html">&lt;p&gt;storyboard 解决的是页面之间的跳转问题。 一个颇为复杂的页面跳转，一旦使用了storyboard，就会四两拨千斤。你只需简单地拖拽，即可完成UIViewController 之间的跳转。 这里面有个神器，一个极为重要的method :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {}

第一个参数是 segue， 第二个参数是 sender。 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个method 主要解决2个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;（1） 获取所要跳转到的视图控制器 （ViewController）；
（2） 同时，将上一个视图的数据，传递给下一个视图。 （比如： 上一个视图是TableView， 那么，就要将点击cell的行号传递到下一个视图）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; UIViewController *destination = segue.destinationViewController;&lt;br&gt; 只要是 prepareForSegue：sender： 总会声明一个目标视图控制器（destination viewcontroller）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一种灵活的传递方法，通过遵循 KVC （Key -Value- Coding）规则来传值。 具体来说， 就是通过 [viewController setValue: forKey: ] 来存储数据。  既然提供了存储方式，就有对应的获取的方式。 以技术用语表达，就是： 读写操作是成对出现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;该方法的触发条件&quot;&gt;&lt;a href=&quot;#该方法的触发条件&quot; class=&quot;headerlink&quot; title=&quot;该方法的触发条件&quot;&gt;&lt;/a&gt;该方法的触发条件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;当前的视图控制器即将被另一个视图控制器所替代时，segue将处于激活状态，从而调用prepareForSegue:sender: 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h3&gt;&lt;p&gt; 为了区分视图的跳转，可以用上一个、下一个来表示，也可以用源视图、目标视图来表示。 即： sourceViewController 和destinationViewController。  目标视图控制器是指：即将显示（加载）的视图， 而源视图控制器是指：即将被取代的视图控制器。&lt;/p&gt;
&lt;p&gt; segue虽然实现的是视图之间的跳转，其实是视图控制器之间的切换。 &lt;strong&gt;更确切地说，segue 实现的是Secene（场景）之间的跳转。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; Scene 是由：  View 、 ViewController、First Responder、Exit  组成的。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;storyboard 解决的是页面之间的跳转问题。 一个颇为复杂的页面跳转，一旦使用了storyboard，就会四两拨千斤。你只需简单地拖拽，即可完成UIViewController 之间的跳转。 这里面有个神器，一个极为重要的method :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {}

第一个参数是 segue， 第二个参数是 sender。 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pragma声明</title>
    <link href="http://yoursite.com/2016/06/02/pragma%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2016/06/02/pragma声明/</id>
    <published>2016-06-02T13:35:43.000Z</published>
    <updated>2016-06-02T13:37:36.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;pragma-声明是彰显-Objective-C-工艺的标志之一。&quot;&gt;&lt;a href=&quot;#pragma-声明是彰显-Objective-C-工艺的标志之一。&quot; class=&quot;headerlink&quot; title=&quot;#pragma 声明是彰显 Objective-C 工艺的标志之一。&quot;&gt;&lt;/a&gt;#pragma 声明是彰显 Objective-C 工艺的标志之一。&lt;/h3&gt;&lt;p&gt;虽然 #pragma 最初的目的是为了使得源代码在不同的编译器下兼容的，但精明的Xcode编码器将 #pragma 使用到了极致。在现在的背景下，#pragma 避开了注释和代码之间的界限。作为预处理指令，#pragma 在编译时进行计算。但它并不像如 #ifdef…#endif 之类的宏，#pragma 的使用方式不会改变你的应用运行时的行为。相反的，#pragma 声明主要由 Xcode 用来完成两个主要任务：整理代码和防止编译器警告。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;整理你的代码&quot;&gt;&lt;a href=&quot;#整理你的代码&quot; class=&quot;headerlink&quot; title=&quot;整理你的代码&quot;&gt;&lt;/a&gt;整理你的代码&lt;/h3&gt;&lt;p&gt;代码整理是一个卫生的问题。你如何组织你的代码反映的是你和你的工作。缺少惯性和内部一致性的代码表明要么有疏忽要么无能－－更糟的是，使得一个项目难以维持和协作。&lt;/p&gt;
&lt;p&gt;在你的 @implementation 中使用 #pragma mark 来将代码分割成逻辑区块。这些逻辑区块不仅仅使得阅读代码本身容易许多，也为Xcode源导航增加了视觉线索（#pragma mark 声明前有一个水平分割并由破折号（－）开始）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#pragma mark - UITableViewDataSource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你的代码应该干净到你可以吃掉它。所以花点时间整理你的.m文件让它们比你生成它们时还干净。&lt;/p&gt;
&lt;h3 id=&quot;防止警告&quot;&gt;&lt;a href=&quot;#防止警告&quot; class=&quot;headerlink&quot; title=&quot;防止警告&quot;&gt;&lt;/a&gt;防止警告&lt;/h3&gt;&lt;p&gt;#pragma mark十分主流。另一方面，用#pragma声明来防止来自编译器或者静态分析器的警告现在还是很新鲜的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 开启Xcode的困难模式

小提示：试试设置-Weverything标志，并在你的build setting里选择“Treat Warnings as Errors”。这将会开启Xcode的困难模式。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可是有的时候并没有办法避免编译器警告。弃用通知和保留周期误报是这个情况可能发生的常见情况。在这些罕见的，你绝对肯定一个特定的编译器或者稳态分析器警告需要被抑制时，#pragma就派上用场了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代码片段：

    // completionBlock在AFURLConnectionOperation中被手动的设置为nil来打破保留周期。
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored &amp;quot;-Warc-retain-cycles&amp;quot;
        self.completionBlock = ^ {
            ...
        };
    #pragma clang diagnostic pop
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pragma-声明是彰显-Objective-C-工艺的标志之一。&quot;&gt;&lt;a href=&quot;#pragma-声明是彰显-Objective-C-工艺的标志之一。&quot; class=&quot;headerlink&quot; title=&quot;#pragma 声明是彰显 Objective-C 工艺的标志之一。&quot;&gt;&lt;/a&gt;#pragma 声明是彰显 Objective-C 工艺的标志之一。&lt;/h3&gt;&lt;p&gt;虽然 #pragma 最初的目的是为了使得源代码在不同的编译器下兼容的，但精明的Xcode编码器将 #pragma 使用到了极致。在现在的背景下，#pragma 避开了注释和代码之间的界限。作为预处理指令，#pragma 在编译时进行计算。但它并不像如 #ifdef…#endif 之类的宏，#pragma 的使用方式不会改变你的应用运行时的行为。相反的，#pragma 声明主要由 Xcode 用来完成两个主要任务：整理代码和防止编译器警告。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>极光推送实现步骤</title>
    <link href="http://yoursite.com/2016/05/29/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2016/05/29/极光推送实现步骤/</id>
    <published>2016-05-29T12:24:30.000Z</published>
    <updated>2016-05-29T12:42:21.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-创建应用程序ID&quot;&gt;&lt;a href=&quot;#1-创建应用程序ID&quot; class=&quot;headerlink&quot; title=&quot;1. 创建应用程序ID&quot;&gt;&lt;/a&gt;1. 创建应用程序ID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;登陆 iOS Dev Center 选择进入iOS Provisioning Portal  ---&amp;gt; 点击App IDs进入App ID列表
 ---&amp;gt; 为 App 开启 Push Notification 功能。如果是已经创建的 App ID 也可以通过设置开启 Push Notification 功能。
  --&amp;gt; 根据实际情况完善 App ID 信息并提交,注意此处需要指定具体的 Bundle ID 不要使用通配符。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;2-配置和下载证书&quot;&gt;&lt;a href=&quot;#2-配置和下载证书&quot; class=&quot;headerlink&quot; title=&quot;2. 配置和下载证书&quot;&gt;&lt;/a&gt;2. 配置和下载证书&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Certificate --&amp;gt; All --&amp;gt; 新建证书需要注意选择证书种类（开发证书用于开发和调试使用，生产证书用于 App Store 发布）
--&amp;gt; 点击 Continue 后选择证书对应的应用ID，然后继续会出现“About Creating a Certificate Signing Request (CSR)”。 
--&amp;gt;  根据它的说明创建打开KeychainAccess 创建 Certificate Signing Request 
--&amp;gt; 填写“User Email Address”和“Common Name” 后选择 Saved to disk 进行保存 。 
--&amp;gt; 继续返回Apple developer 网站点击 Continue ，上传刚刚生成的 .certSigningRequest 文件生成 APNs Push Certificate。
下载并双击打开证书，证书打开时会启动“钥匙串访问”工具。在“钥匙串访问”中你的证书会显示在“我的证书”中，
注意选择“My Certificates” 和&amp;quot;login&amp;quot; 
--&amp;gt;  导出 .p12 证书文件(将文件保存为Personal Information Exchange (.p12)格式。)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-上传证书&quot;&gt;&lt;a href=&quot;#3-上传证书&quot; class=&quot;headerlink&quot; title=&quot;3. 上传证书&quot;&gt;&lt;/a&gt;3. 上传证书&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在 JPush 管理 Portal 上，针对某应用程序，上传上面步骤得到 .p12 证书文件。
这是 iOS SDK 能够接收到 JPush 推送消息的必要步骤。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Provisioning-Profile的创建&quot;&gt;&lt;a href=&quot;#Provisioning-Profile的创建&quot; class=&quot;headerlink&quot; title=&quot;Provisioning Profile的创建&quot;&gt;&lt;/a&gt;Provisioning Profile的创建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;创建Provisioning Profile的前提，已在Apple Developer网站创建待发布应用所使用的Bundle ID的App ID，
且为该App ID创建了APNs证书
 --&amp;gt; 在苹果开发者账号的Provisioning Profile页面点击&amp;quot;+&amp;quot;按钮，创建Provisioning Profile 
 --&amp;gt; 选择此Provisioning Profile的环境后点击[Continue]： 
 --&amp;gt;  选择要创建Provisioning Profile的App ID后点击[Continue]：
 --&amp;gt; 选择所属的开发者证书，（这里创建了多个开发者证书，建议只创建一个，方便管理）为了方便，
 选择了[Select All],再点击[Continue]进入下一步
--&amp;gt; 为该Provisioning Profile选择将要安装的设备（一般选择[Select All]），点击[Continue] 
--&amp;gt; 给该Provisioning Profile填写Profile Name，点击[generate]完成创建 
--&amp;gt; 填写完Profile Name后点击[generate]完成创建，之后点击[DownLoad]下载Provisioning Profile 
--&amp;gt; 双击下载下来的Provisioning Profile，添加到xcode。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;XCode的证书配置教程&quot;&gt;&lt;a href=&quot;#XCode的证书配置教程&quot; class=&quot;headerlink&quot; title=&quot;XCode的证书配置教程&quot;&gt;&lt;/a&gt;XCode的证书配置教程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.打开xxx-info.plist的Bundle identifier项把上传到JPush 控制台的bundle id填写进去
2.点击项目，选择目标TARGETS后进入Build Setting 界面，搜索“Code signing”配置注册的证书
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;客户端设置&quot;&gt;&lt;a href=&quot;#客户端设置&quot; class=&quot;headerlink&quot; title=&quot;客户端设置&quot;&gt;&lt;/a&gt;客户端设置&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;开启Remote notifications
需要在Xcode 中修改应用的 Capabilities 开启Remote notifications
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取自定义消息推送内容&quot;&gt;&lt;a href=&quot;#获取自定义消息推送内容&quot; class=&quot;headerlink&quot; title=&quot;获取自定义消息推送内容&quot;&gt;&lt;/a&gt;获取自定义消息推送内容&lt;/h3&gt;&lt;p&gt;功能说明: 只有在前端运行的时候才能收到自定义消息的推送。从jpush服务器获取用户推送的自定义消息内容和标题以及附加字段等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;获取iOS的推送内容需要在delegate类中注册通知并实现回调方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取-RegistrationID&quot;&gt;&lt;a href=&quot;#获取-RegistrationID&quot; class=&quot;headerlink&quot; title=&quot;获取 RegistrationID&quot;&gt;&lt;/a&gt;获取 RegistrationID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+(NSString *)registrationID
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;标签与别名-API-iOS&quot;&gt;&lt;a href=&quot;#标签与别名-API-iOS&quot; class=&quot;headerlink&quot; title=&quot;标签与别名 API (iOS)&quot;&gt;&lt;/a&gt;标签与别名 API (iOS)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+ (void)setTags:(NSSet *)tags alias:(NSString *)alias callbackSelector:(SEL)cbSelector object:(id)theTarget;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建应用程序ID&quot;&gt;&lt;a href=&quot;#1-创建应用程序ID&quot; class=&quot;headerlink&quot; title=&quot;1. 创建应用程序ID&quot;&gt;&lt;/a&gt;1. 创建应用程序ID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;登陆 iOS Dev Center 选择进入iOS Provisioning Portal  ---&amp;gt; 点击App IDs进入App ID列表
 ---&amp;gt; 为 App 开启 Push Notification 功能。如果是已经创建的 App ID 也可以通过设置开启 Push Notification 功能。
  --&amp;gt; 根据实际情况完善 App ID 信息并提交,注意此处需要指定具体的 Bundle ID 不要使用通配符。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结3</title>
    <link href="http://yoursite.com/2016/05/22/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%933/"/>
    <id>http://yoursite.com/2016/05/22/iOS特别技能点总结3/</id>
    <published>2016-05-22T02:42:01.000Z</published>
    <updated>2016-05-22T02:54:25.000Z</updated>
    
    <content type="html">&lt;p&gt;CFAbsoluteTimeGetCurrent()&lt;br&gt; 获取系统运行的当前绝对时间&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;nsarray-类定义的方法&quot;&gt;&lt;a href=&quot;#nsarray-类定义的方法&quot; class=&quot;headerlink&quot; title=&quot;nsarray 类定义的方法&quot;&gt;&lt;/a&gt;nsarray 类定义的方法&lt;/h3&gt;&lt;p&gt;1.makeObjectsPerformSelector:@select（aMethod）&lt;br&gt;简介：让数组中的每个元素 都调用 aMethod &lt;/p&gt;
&lt;p&gt;2.makeObjectsPerformSelector:@select（aMethod） withObject:oneObject&lt;br&gt;简介：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod&lt;/p&gt;
&lt;h3 id=&quot;支付宝的接入注意点总结&quot;&gt;&lt;a href=&quot;#支付宝的接入注意点总结&quot; class=&quot;headerlink&quot; title=&quot;支付宝的接入注意点总结&quot;&gt;&lt;/a&gt;支付宝的接入注意点总结&lt;/h3&gt;&lt;p&gt;1.确保需要的库全部导入&lt;/p&gt;
&lt;p&gt;2.partner ,seller ,privateKey   三个参数的完整&lt;/p&gt;
&lt;p&gt;3.支付完成跳回程序需要设置 appScheme ， 最好使用英文，中文识别可能出错，造成无法跳回。 &lt;/p&gt;
&lt;h3 id=&quot;去除点击-cell-的效果&quot;&gt;&lt;a href=&quot;#去除点击-cell-的效果&quot; class=&quot;headerlink&quot; title=&quot;去除点击 cell 的效果&quot;&gt;&lt;/a&gt;去除点击 cell 的效果&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[tableView deselectRowAtIndexPath:indexPath animated:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;时间日期的格式转化&quot;&gt;&lt;a href=&quot;#时间日期的格式转化&quot; class=&quot;headerlink&quot; title=&quot;时间日期的格式转化&quot;&gt;&lt;/a&gt;时间日期的格式转化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSNumber *startTime = [temp objectForKey:@&amp;quot;addtime&amp;quot;];
NSDate *startTimeDate = [NSDate dateWithTimeIntervalSince1970:[startTime intValue]];
NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
[formatter setDateFormat:@&amp;quot;yyyy-MM-dd HH:mm&amp;quot;];//设置源时间字符串的格式
NSString *targetTime = [formatter stringFromDate:startTimeDate];//将时间转化成目标时间字符串
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;修改-tableCell-里面的图片圆角&quot;&gt;&lt;a href=&quot;#修改-tableCell-里面的图片圆角&quot; class=&quot;headerlink&quot; title=&quot;修改 tableCell 里面的图片圆角&quot;&gt;&lt;/a&gt;修改 tableCell 里面的图片圆角&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在 cell 的 .m 文件里面修改

- (void)awakeFromNib {
    _imgHead.clipsToBounds = YES;
    _imgHead.layer.cornerRadius = 30;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;下拉刷新的时候如何防止-crash-（不判断是否有新数据加入，直接刷新，会有轻微的不适感）&quot;&gt;&lt;a href=&quot;#下拉刷新的时候如何防止-crash-（不判断是否有新数据加入，直接刷新，会有轻微的不适感）&quot; class=&quot;headerlink&quot; title=&quot;下拉刷新的时候如何防止 crash （不判断是否有新数据加入，直接刷新，会有轻微的不适感）&quot;&gt;&lt;/a&gt;下拉刷新的时候如何防止 crash （不判断是否有新数据加入，直接刷新，会有轻微的不适感）&lt;/h3&gt;&lt;p&gt;   在下拉刷新的时候，需要将数组内所有的数据移除，并且将界面刷新一遍，这样可以防止 crash。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.trainRoutineArray removeAllObjects];
[self.table reloadData];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;在解析-json-数据的时候需要在循环体内初始化-Model-，这样才是正确的，在外部初始化会导致添加的数据重复。&quot;&gt;&lt;a href=&quot;#在解析-json-数据的时候需要在循环体内初始化-Model-，这样才是正确的，在外部初始化会导致添加的数据重复。&quot; class=&quot;headerlink&quot; title=&quot;在解析 json 数据的时候需要在循环体内初始化 Model ，这样才是正确的，在外部初始化会导致添加的数据重复。&quot;&gt;&lt;/a&gt;在解析 json 数据的时候需要在循环体内初始化 Model ，这样才是正确的，在外部初始化会导致添加的数据重复。&lt;/h3&gt;&lt;p&gt;   原因： 在外部初始化，会导致内存空间只分配一次，在第一次赋值之后，会因为 Model 里面的 NSString 类型的数据无法被第二次赋值，造成了第二次添加数据到数组的时候还是第一次的数据。&lt;/p&gt;
&lt;p&gt;   常用日期结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yyyy-MM-dd HH:mm:ss.SSS
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  iOS-NSDateFormatter 格式说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;G: 公元时代，例如AD公元
yy:年的后2位
yyyy:完整年
MM:月，显示为1-12
MMM:月，显示为英文月份简写,如 Jan
MMMM:月，显示为英文月份全称，如 Janualy
dd:日，2位数表示，如02
d:日，1-2位显示，如 2
EEE:简写星期几，如Sun
EEEE:全写星期几，如Sunday
aa:上下午，AM/PM
H:时，24小时制，0-23
K：时，12小时制，0-11
m:分，1-2位
mm:分，2位
s:秒，1-2位
ss:秒，2位
S:毫秒
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误： &lt;em&gt; Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSCFNumber length]: unrecognized selector sent to instance 0x15580c90’ &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;原因： 因为在接收的 Model 里面有些数据类型跟 json 数据的字段类型不同 （一般是非字符串的类型造成的）&lt;br&gt;解决方案： 将 json 数据里面的 int 或者 double 类型直接使用中间类型 NSNumber 类型来接收，并转化成 NSString 类型。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;上传图片&quot;&gt;&lt;a href=&quot;#上传图片&quot; class=&quot;headerlink&quot; title=&quot;上传图片&quot;&gt;&lt;/a&gt;上传图片&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[afManager POST:url parameters:parameters constructingBodyWithBlock:^(id&amp;lt;AFMultipartFormData&amp;gt; formData) {

     NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
     formatter.dateFormat = @&amp;quot;yyyyMMddHHmmss&amp;quot;;
     NSString *str = [formatter stringFromDate:[NSDate date]];

     [formData appendPartWithFileData:filename name:@&amp;quot;file&amp;quot; fileName:[NSString stringWithFormat:@&amp;quot;%@image1.png&amp;quot;,str] mimeType:@&amp;quot;image/png&amp;quot;];
 } success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {

     if (success) {

         success(responseObject);
      }

 } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {

     if (failure) {

       failure(error);
    }
 }];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;CFAbsoluteTimeGetCurrent()&lt;br&gt; 获取系统运行的当前绝对时间&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>方法性能方法</title>
    <link href="http://yoursite.com/2016/05/20/%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/20/方法性能方法/</id>
    <published>2016-05-20T14:59:25.000Z</published>
    <updated>2016-05-20T15:01:59.000Z</updated>
    
    <content type="html">&lt;p&gt;性能测试   &lt;/p&gt;
&lt;p&gt;通常enumerateObjectsUsingBlock: 和 (for(… in …)在效率上基本一致，有时会快些。主要是因为它们都是基于 NSFastEnumeration 实现的. 快速迭代在处理的过程中需要多一次转换，当然也会消耗掉一些时间. 基于Block的迭代可以达到本机存储一样快的遍历集合. 对于字典同样适用，而数组的迭代却不行。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;（ &lt;a href=&quot;http://stackoverflow.com/questions/4486622/when-to-use-enumerateobjectsusingblock-vs-for&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/4486622/when-to-use-enumerateobjectsusingblock-vs-for&lt;/a&gt; ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSMutableArray *test = [NSMutableArray array];
for (int i= 0; i &amp;lt; 10000000; i++) {
    [test addObject:@(i)];
}
int sum = 0;

double date_s = CFAbsoluteTimeGetCurrent();
for (int i = 0;i &amp;lt; test.count; i++) {
    sum += 1;
}
double date_e =  CFAbsoluteTimeGetCurrent();
NSLog(@&amp;quot;ForLoop Time: %f&amp;quot;, date_e - date_s);

date_s =  CFAbsoluteTimeGetCurrent();
for (id obj in test) {
    sum += 1;
}
date_e =  CFAbsoluteTimeGetCurrent();
NSLog(@&amp;quot;Enumeration Time: %f&amp;quot;, date_e - date_s);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  注意”enumerateObjectsUsingBlock” 修改局部变量时， 你需要声明局部变量为 __block 类型.&lt;/p&gt;
&lt;p&gt;  enumerateObjectsWithOptions:usingBlock: 支持并发迭代或反向迭代，并发迭代时效率也非常高.&lt;/p&gt;
&lt;p&gt;  对于字典而言, enumerateObjectsWithOptions:usingBlock 也是唯一的方式可以并发实现恢复Key-Value值.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;性能测试   &lt;/p&gt;
&lt;p&gt;通常enumerateObjectsUsingBlock: 和 (for(… in …)在效率上基本一致，有时会快些。主要是因为它们都是基于 NSFastEnumeration 实现的. 快速迭代在处理的过程中需要多一次转换，当然也会消耗掉一些时间. 基于Block的迭代可以达到本机存储一样快的遍历集合. 对于字典同样适用，而数组的迭代却不行。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结2</title>
    <link href="http://yoursite.com/2016/05/20/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%932/"/>
    <id>http://yoursite.com/2016/05/20/iOS特别技能点总结2/</id>
    <published>2016-05-20T14:53:45.000Z</published>
    <updated>2016-05-20T14:58:01.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;iOS-通知&quot;&gt;&lt;a href=&quot;#iOS-通知&quot; class=&quot;headerlink&quot; title=&quot;iOS 通知&quot;&gt;&lt;/a&gt;iOS 通知&lt;/h3&gt;&lt;p&gt;1.在数据发生变化的界面进行通知注册和发送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; NSArray *saveImageArray = [[NSArray alloc] initWithObjects:@&amp;quot;123&amp;quot;, nil];
[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;postData&amp;quot; object:saveImageArray];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.在通知接收界面进行通知监测和作出反应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self
                                      selector:@selector(PostImage:)//接收消息方法
                                          name:@&amp;quot;postData&amp;quot;//消息识别名称
                                        object:nil];
//实现方法
-(void)PostImage:(NSArray *)array {

    self.messageSign.hidden = NO;
    NSLog(@&amp;quot;array ===  %@&amp;quot;, array);
    //接收传送过来的消息
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.在接收通知的界面消失的时候进行–通知观察者的移除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //移除observer   
[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;postData&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;界面间的跳转-–-（storyboard方式搭建界面）&quot;&gt;&lt;a href=&quot;#界面间的跳转-–-（storyboard方式搭建界面）&quot; class=&quot;headerlink&quot; title=&quot;界面间的跳转 – （storyboard方式搭建界面）&quot;&gt;&lt;/a&gt;界面间的跳转 – （storyboard方式搭建界面）&lt;/h3&gt;&lt;p&gt;1.界面间有 segue 的界面跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self performSegueWithIdentifier:@&amp;quot;segue的Identifier&amp;quot; sender:nil]; // 添加在需要跳转的地方

// 有 segue 的跳转都会调用到的方法
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {

   // 传送的数据
   ViewController *lVC = [segue destinationViewController];
   VC.team_id = self.team_id1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.界面间没有连线或者在不同的 storyboard 界面跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取要跳转的 Storyboard
UIStoryboard *scoreStoryboard = [UIStoryboard storyboardWithName:@&amp;quot;Personal&amp;quot; bundle:nil];

// 需要在目标界面设置 Storyboard ID
PayViewController *payVC = [scoreStoryboard instantiateViewControllerWithIdentifier:@&amp;quot;PayViewController&amp;quot;];
payVC.diamondCount = 1;

[self.navigationController pushViewController:payVC animated:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误 ：UIImage stringByDeletingPathExtension]: unrecognized selector sent to instance 0xbe79910&lt;/p&gt;
&lt;p&gt;原因 ：你所使用的对象已经是 UIImage ，不能再分割成其他对象&lt;/p&gt;
&lt;p&gt;解决方案： 寻找使用了这个对象的地方，并修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;单独对一些文件设置-ARC-或者设置-非ARC&quot;&gt;&lt;a href=&quot;#单独对一些文件设置-ARC-或者设置-非ARC&quot; class=&quot;headerlink&quot; title=&quot;单独对一些文件设置 ARC 或者设置 非ARC&quot;&gt;&lt;/a&gt;单独对一些文件设置 ARC 或者设置 非ARC&lt;/h3&gt;&lt;p&gt;1.如果项目建立时未使用ARC，想将其改为ARC，可以在building setting中修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在Building Setting中搜索auto reference

将Objective-C Automatic Reference Counting一行设置为YES即可
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.因为之前没有ARC机制，好多比较好的类库都是使用的非ARC，或是有些大牛还是不喜欢用ARC，封装的类也是非ARC的，想要在自己的ARC项目中使用这些非ARC类库，只需要简单的设置一下就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在TARGETS-Bulid Phares-Compile Sources中找到非ARC的文件，双击，在弹出的框中添加

   -fno-objc-arc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.UIImage转化成NSData&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSData *data;
if (UIImagePNGRepresentation(image) == nil) {

      data = UIImageJPEGRepresentation(image, 1);
    } else {

      data = UIImagePNGRepresentation(image);
} 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;iOS-通知&quot;&gt;&lt;a href=&quot;#iOS-通知&quot; class=&quot;headerlink&quot; title=&quot;iOS 通知&quot;&gt;&lt;/a&gt;iOS 通知&lt;/h3&gt;&lt;p&gt;1.在数据发生变化的界面进行通知注册和发送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; NSArray *saveImageArray = [[NSArray alloc] initWithObjects:@&amp;quot;123&amp;quot;, nil];
[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;postData&amp;quot; object:saveImageArray];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式kvo</title>
    <link href="http://yoursite.com/2016/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fkvo/"/>
    <id>http://yoursite.com/2016/05/17/设计模式kvo/</id>
    <published>2016-05-17T13:32:36.000Z</published>
    <updated>2016-05-17T13:33:52.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;KVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。&lt;/p&gt;
&lt;p&gt;   在初始化方法中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_tableView addObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; options:NSKeyValueObservingOptionNew context:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;   在dealloc中移除KVO监听：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_tableView removeObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; context:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  添加默认的响应回调方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {

  [self doSomethingWhenContentOffsetChanges];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;p&gt;1.当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断如下：

 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {

       if (object == _tableView &amp;amp;&amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) {

           [self doSomethingWhenContentOffsetChanges];
        }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass…中，上述处理砍断了这个链。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;合理的处理方式应该是这样的：

   - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
     {
       if (object == _tableView &amp;amp;&amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) {

           [self doSomethingWhenContentOffsetChanges];
       } else {

          [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
       }
     }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 我们可以分别在父类以及本类中定义各自的context字符串，比如在本类中定义context为@&amp;quot;ThisIsMyKVOContextNotSuper&amp;quot;;然后在dealloc中remove observer时指定移除的自身添加的observer。
这样iOS就能知道移除的是自己的kvo，而不是父类中的kvo，避免二次remove造成crash。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;KVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。&lt;/p&gt;
&lt;p&gt;   在初始化方法中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_tableView addObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; options:NSKeyValueObservingOptionNew context:nil];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>预编译指令</title>
    <link href="http://yoursite.com/2016/05/16/%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/05/16/预编译指令/</id>
    <published>2016-05-16T13:38:49.000Z</published>
    <updated>2016-05-16T13:43:13.000Z</updated>
    
    <content type="html">&lt;p&gt;常见的预处理功能&lt;/p&gt;
&lt;p&gt;预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ 文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

＊ 条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

＊ 布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

＊ 宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; 预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。可见预处理过程先于编译器对源代码进行处理。&lt;/p&gt;
&lt;p&gt; 预处理指令是以#开头的代码行，#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。正行语句构成了一条预处理指令，该指令酱紫啊编译器进行编译之前对源代码做某些转换，下面是一些&lt;/p&gt;
&lt;h3 id=&quot;常用的预处理指令&quot;&gt;&lt;a href=&quot;#常用的预处理指令&quot; class=&quot;headerlink&quot; title=&quot;常用的预处理指令&quot;&gt;&lt;/a&gt;常用的预处理指令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#   空指令，没有任何效果

#include 包含一个源代码文件

#define 定义宏

#undef 取消定义宏

#if 如果条件为真，则编译下面的代码

#elif 如果前面的#if不为真，则编译下面的代码

#endif 结束一个#if...#elif条件编译块

#ifdef 如果已经定义了某个宏，则编译下面的代码

#ifndef 如果没有定义某个宏，则编译下面的代码

#error 停止编译并显示错误信息

#pragma 为编译程序提供非常规的控制流信息
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 这些指令的主要目的是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。&lt;/p&gt;
&lt;h3 id=&quot;预定义标识符&quot;&gt;&lt;a href=&quot;#预定义标识符&quot; class=&quot;headerlink&quot; title=&quot;预定义标识符&quot;&gt;&lt;/a&gt;预定义标识符&lt;/h3&gt;&lt;p&gt;  为了处理一些有用的信息，预处理定义了一些预处理标识符，虽然各种编译器的预处理标识符不尽相同，但是他们都会处理下面的4种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__FILE__ 正在编译的文件的名字
__LINE__ 正在编译的文件的行号
__DATE__ 编译时刻的日期字符串，例如： &amp;quot;25 Jan 2006&amp;quot;
__TIME__ 编译时刻的时间字符串，例如： &amp;quot;12:30:55&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;常见的预处理功能&lt;/p&gt;
&lt;p&gt;预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ 文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

＊ 条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

＊ 布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

＊ 宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结</title>
    <link href="http://yoursite.com/2016/05/07/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/05/07/iOS特别技能点总结/</id>
    <published>2016-05-07T11:33:38.000Z</published>
    <updated>2016-05-16T13:55:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;修改状态栏颜色&quot;&gt;&lt;a href=&quot;#修改状态栏颜色&quot; class=&quot;headerlink&quot; title=&quot;修改状态栏颜色&quot;&gt;&lt;/a&gt;修改状态栏颜色&lt;/h3&gt;&lt;p&gt;1.在 info.plist 添加 View controller-based status bar appearance 并设置为 NO（白色），YES（黑色）， 如果为NO，并在 Appdelegate 里面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
则可设置为白色。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.在有 navigationbar 的时候需要 添加方法 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UIStatusBarStyle)preferredStatusBarStyle {

return UIStatusBarStyleLightContent;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且在 viewDidload 中添加：self.navigationController.navigationBar.barStyle = UIBarStyleBlack;&lt;/p&gt;
&lt;p&gt;这样可以设置为白色&lt;/p&gt;
&lt;h3 id=&quot;修改-Bar-Button-Item-的颜色&quot;&gt;&lt;a href=&quot;#修改-Bar-Button-Item-的颜色&quot; class=&quot;headerlink&quot; title=&quot;修改 Bar Button Item 的颜色&quot;&gt;&lt;/a&gt;修改 Bar Button Item 的颜色&lt;/h3&gt;&lt;p&gt;如果要修改 Right Bar Button Items 的颜色，需要在 Bar Button Item 里面修改它的 Tint 的颜色。因为自定义右按钮Right Bar Button Items 有两个图层：Bar Button Item 和 View。&lt;/p&gt;
&lt;h3 id=&quot;警告：Plain-style-unsupported-in-a-Navigation-item&quot;&gt;&lt;a href=&quot;#警告：Plain-style-unsupported-in-a-Navigation-item&quot; class=&quot;headerlink&quot; title=&quot;警告：Plain style unsupported in a Navigation item&quot;&gt;&lt;/a&gt;警告：Plain style unsupported in a Navigation item&lt;/h3&gt;&lt;p&gt; 解决方法： 将 plain 设置成：Bordered 。&lt;/p&gt;
&lt;h3 id=&quot;怎样设置UITableView的cell之间的距离&quot;&gt;&lt;a href=&quot;#怎样设置UITableView的cell之间的距离&quot; class=&quot;headerlink&quot; title=&quot;怎样设置UITableView的cell之间的距离?&quot;&gt;&lt;/a&gt;怎样设置UITableView的cell之间的距离?&lt;/h3&gt;&lt;p&gt;分为两种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 分组表格    - 每段一个cell设置表头的高度 
2. 非分组表格  - 将tableViewCell的背景色，contentView的背景色设置为透明，在contentView中添加一个UIImageView做为背景，使UIImageView的高度小于cell的高度，这样创建出的tableView就可以使每个cell之间看起来有一定间隔。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;performSegueWithIdentifier-produce-no-segue-with-identifier-error&quot;&gt;&lt;a href=&quot;#performSegueWithIdentifier-produce-no-segue-with-identifier-error&quot; class=&quot;headerlink&quot; title=&quot;performSegueWithIdentifier produce no segue with identifier error&quot;&gt;&lt;/a&gt;performSegueWithIdentifier produce no segue with identifier error&lt;/h3&gt;&lt;p&gt;   解决方法：先检查要跳转的界面和目的界面的表格的协议（delegate和datasource）是否有代理。然后检查是否给控制器添加了类。&lt;/p&gt;
&lt;p&gt;1.在 ios 中如果遇到添加的图片没有显示出来，可以先检查图片的名称是否正确，&lt;br&gt; 然后检查图片的格式是否是 PNG 格式，最后检查是否已经添加到工程当中了。&lt;/p&gt;
&lt;p&gt;2.在tableView 中 cell 的跳转，需要使用控制器间的跳转。 &lt;/p&gt;
&lt;p&gt;3.异常：Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘&lt;em&gt;*&lt;/em&gt; -[UIViewController tableView:numberOfRowsInSection:]: unrecognized selector sent to instance 0x3b02120’&lt;/p&gt;
&lt;p&gt;   解决方法：检测视图控制器是否绑定了具体的类。&lt;/p&gt;
&lt;p&gt;4.this class is not key value coding-compliant for the key XXX错误的解决方法&lt;/p&gt;
&lt;p&gt;   解决方法：在设置IBAction和IBOutlet时有多余的连线，按下ctrl键检查控件的连接将多余的连续删除后程序正常运行。&lt;/p&gt;
&lt;p&gt;5.this class is not key value coding-compliant for the key leftTitle.&lt;/p&gt;
&lt;p&gt;   解决方法： 因为sb 或者 xib 中的控件链接的属性有些没有出现在页面绑定的控制器上，造成引用上的健值错误。&lt;/p&gt;
&lt;p&gt;6.OC之OBJC2_UNAVAILABLE&lt;/p&gt;
&lt;p&gt;  意即在OBJC2.0中，这些东西将被删除。&lt;/p&gt;
&lt;h3 id=&quot;去除-tableView-的-sectionView-的粘性&quot;&gt;&lt;a href=&quot;#去除-tableView-的-sectionView-的粘性&quot; class=&quot;headerlink&quot; title=&quot;去除 tableView 的 sectionView 的粘性&quot;&gt;&lt;/a&gt;去除 tableView 的 sectionView 的粘性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

   CGFloat sectionHeaderHeight = 45;
   if (scrollView.contentOffset.y &amp;lt;= sectionHeaderHeight&amp;amp;&amp;amp;scrollView.contentOffset.y &amp;gt;= 0) {

       scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
   }
   else if (scrollView.contentOffset.y &amp;gt;= sectionHeaderHeight) {

       scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;修改-textField-的-placeholder-的字体颜色，大小&quot;&gt;&lt;a href=&quot;#修改-textField-的-placeholder-的字体颜色，大小&quot; class=&quot;headerlink&quot; title=&quot;修改 textField 的 placeholder 的字体颜色，大小&quot;&gt;&lt;/a&gt;修改 textField 的 placeholder 的字体颜色，大小&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[textField setValue:[UIColor redColor] forKeyPath:@&amp;quot;_placeholderLabel.textColor&amp;quot;];  

[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&amp;quot;_placeholderLabel.font&amp;quot;]; 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;修改状态栏颜色&quot;&gt;&lt;a href=&quot;#修改状态栏颜色&quot; class=&quot;headerlink&quot; title=&quot;修改状态栏颜色&quot;&gt;&lt;/a&gt;修改状态栏颜色&lt;/h3&gt;&lt;p&gt;1.在 info.plist 添加 View controller-based status bar appearance 并设置为 NO（白色），YES（黑色）， 如果为NO，并在 Appdelegate 里面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
则可设置为白色。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
