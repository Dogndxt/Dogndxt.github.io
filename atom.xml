<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-06-02T13:43:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> storyboard之prepareForSegue</title>
    <link href="http://yoursite.com/2016/06/02/storyboard%E4%B9%8BprepareForSegue/"/>
    <id>http://yoursite.com/2016/06/02/storyboard之prepareForSegue/</id>
    <published>2016-06-02T13:41:03.000Z</published>
    <updated>2016-06-02T13:43:30.000Z</updated>
    
    <content type="html">&lt;p&gt;storyboard 解决的是页面之间的跳转问题。 一个颇为复杂的页面跳转，一旦使用了storyboard，就会四两拨千斤。你只需简单地拖拽，即可完成UIViewController 之间的跳转。 这里面有个神器，一个极为重要的method :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {}

第一个参数是 segue， 第二个参数是 sender。 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;这个method 主要解决2个问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;（1） 获取所要跳转到的视图控制器 （ViewController）；
（2） 同时，将上一个视图的数据，传递给下一个视图。 （比如： 上一个视图是TableView， 那么，就要将点击cell的行号传递到下一个视图）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; UIViewController *destination = segue.destinationViewController;&lt;br&gt; 只要是 prepareForSegue：sender： 总会声明一个目标视图控制器（destination viewcontroller）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一种灵活的传递方法，通过遵循 KVC （Key -Value- Coding）规则来传值。 具体来说， 就是通过 [viewController setValue: forKey: ] 来存储数据。  既然提供了存储方式，就有对应的获取的方式。 以技术用语表达，就是： 读写操作是成对出现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;该方法的触发条件&quot;&gt;&lt;a href=&quot;#该方法的触发条件&quot; class=&quot;headerlink&quot; title=&quot;该方法的触发条件&quot;&gt;&lt;/a&gt;该方法的触发条件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;当前的视图控制器即将被另一个视图控制器所替代时，segue将处于激活状态，从而调用prepareForSegue:sender: 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;本质&quot;&gt;&lt;a href=&quot;#本质&quot; class=&quot;headerlink&quot; title=&quot;本质&quot;&gt;&lt;/a&gt;本质&lt;/h3&gt;&lt;p&gt; 为了区分视图的跳转，可以用上一个、下一个来表示，也可以用源视图、目标视图来表示。 即： sourceViewController 和destinationViewController。  目标视图控制器是指：即将显示（加载）的视图， 而源视图控制器是指：即将被取代的视图控制器。&lt;/p&gt;
&lt;p&gt; segue虽然实现的是视图之间的跳转，其实是视图控制器之间的切换。 &lt;strong&gt;更确切地说，segue 实现的是Secene（场景）之间的跳转。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt; Scene 是由：  View 、 ViewController、First Responder、Exit  组成的。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;storyboard 解决的是页面之间的跳转问题。 一个颇为复杂的页面跳转，一旦使用了storyboard，就会四两拨千斤。你只需简单地拖拽，即可完成UIViewController 之间的跳转。 这里面有个神器，一个极为重要的method :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {}

第一个参数是 segue， 第二个参数是 sender。 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pragma声明</title>
    <link href="http://yoursite.com/2016/06/02/pragma%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2016/06/02/pragma声明/</id>
    <published>2016-06-02T13:35:43.000Z</published>
    <updated>2016-06-02T13:37:36.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;pragma-声明是彰显-Objective-C-工艺的标志之一。&quot;&gt;&lt;a href=&quot;#pragma-声明是彰显-Objective-C-工艺的标志之一。&quot; class=&quot;headerlink&quot; title=&quot;#pragma 声明是彰显 Objective-C 工艺的标志之一。&quot;&gt;&lt;/a&gt;#pragma 声明是彰显 Objective-C 工艺的标志之一。&lt;/h3&gt;&lt;p&gt;虽然 #pragma 最初的目的是为了使得源代码在不同的编译器下兼容的，但精明的Xcode编码器将 #pragma 使用到了极致。在现在的背景下，#pragma 避开了注释和代码之间的界限。作为预处理指令，#pragma 在编译时进行计算。但它并不像如 #ifdef…#endif 之类的宏，#pragma 的使用方式不会改变你的应用运行时的行为。相反的，#pragma 声明主要由 Xcode 用来完成两个主要任务：整理代码和防止编译器警告。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;整理你的代码&quot;&gt;&lt;a href=&quot;#整理你的代码&quot; class=&quot;headerlink&quot; title=&quot;整理你的代码&quot;&gt;&lt;/a&gt;整理你的代码&lt;/h3&gt;&lt;p&gt;代码整理是一个卫生的问题。你如何组织你的代码反映的是你和你的工作。缺少惯性和内部一致性的代码表明要么有疏忽要么无能－－更糟的是，使得一个项目难以维持和协作。&lt;/p&gt;
&lt;p&gt;在你的 @implementation 中使用 #pragma mark 来将代码分割成逻辑区块。这些逻辑区块不仅仅使得阅读代码本身容易许多，也为Xcode源导航增加了视觉线索（#pragma mark 声明前有一个水平分割并由破折号（－）开始）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#pragma mark - UITableViewDataSource
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你的代码应该干净到你可以吃掉它。所以花点时间整理你的.m文件让它们比你生成它们时还干净。&lt;/p&gt;
&lt;h3 id=&quot;防止警告&quot;&gt;&lt;a href=&quot;#防止警告&quot; class=&quot;headerlink&quot; title=&quot;防止警告&quot;&gt;&lt;/a&gt;防止警告&lt;/h3&gt;&lt;p&gt;#pragma mark十分主流。另一方面，用#pragma声明来防止来自编译器或者静态分析器的警告现在还是很新鲜的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 开启Xcode的困难模式

小提示：试试设置-Weverything标志，并在你的build setting里选择“Treat Warnings as Errors”。这将会开启Xcode的困难模式。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可是有的时候并没有办法避免编译器警告。弃用通知和保留周期误报是这个情况可能发生的常见情况。在这些罕见的，你绝对肯定一个特定的编译器或者稳态分析器警告需要被抑制时，#pragma就派上用场了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代码片段：

    // completionBlock在AFURLConnectionOperation中被手动的设置为nil来打破保留周期。
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored &amp;quot;-Warc-retain-cycles&amp;quot;
        self.completionBlock = ^ {
            ...
        };
    #pragma clang diagnostic pop
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;pragma-声明是彰显-Objective-C-工艺的标志之一。&quot;&gt;&lt;a href=&quot;#pragma-声明是彰显-Objective-C-工艺的标志之一。&quot; class=&quot;headerlink&quot; title=&quot;#pragma 声明是彰显 Objective-C 工艺的标志之一。&quot;&gt;&lt;/a&gt;#pragma 声明是彰显 Objective-C 工艺的标志之一。&lt;/h3&gt;&lt;p&gt;虽然 #pragma 最初的目的是为了使得源代码在不同的编译器下兼容的，但精明的Xcode编码器将 #pragma 使用到了极致。在现在的背景下，#pragma 避开了注释和代码之间的界限。作为预处理指令，#pragma 在编译时进行计算。但它并不像如 #ifdef…#endif 之类的宏，#pragma 的使用方式不会改变你的应用运行时的行为。相反的，#pragma 声明主要由 Xcode 用来完成两个主要任务：整理代码和防止编译器警告。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>极光推送实现步骤</title>
    <link href="http://yoursite.com/2016/05/29/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2016/05/29/极光推送实现步骤/</id>
    <published>2016-05-29T12:24:30.000Z</published>
    <updated>2016-05-29T12:42:21.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-创建应用程序ID&quot;&gt;&lt;a href=&quot;#1-创建应用程序ID&quot; class=&quot;headerlink&quot; title=&quot;1. 创建应用程序ID&quot;&gt;&lt;/a&gt;1. 创建应用程序ID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;登陆 iOS Dev Center 选择进入iOS Provisioning Portal  ---&amp;gt; 点击App IDs进入App ID列表
 ---&amp;gt; 为 App 开启 Push Notification 功能。如果是已经创建的 App ID 也可以通过设置开启 Push Notification 功能。
  --&amp;gt; 根据实际情况完善 App ID 信息并提交,注意此处需要指定具体的 Bundle ID 不要使用通配符。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;2-配置和下载证书&quot;&gt;&lt;a href=&quot;#2-配置和下载证书&quot; class=&quot;headerlink&quot; title=&quot;2. 配置和下载证书&quot;&gt;&lt;/a&gt;2. 配置和下载证书&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Certificate --&amp;gt; All --&amp;gt; 新建证书需要注意选择证书种类（开发证书用于开发和调试使用，生产证书用于 App Store 发布）
--&amp;gt; 点击 Continue 后选择证书对应的应用ID，然后继续会出现“About Creating a Certificate Signing Request (CSR)”。 
--&amp;gt;  根据它的说明创建打开KeychainAccess 创建 Certificate Signing Request 
--&amp;gt; 填写“User Email Address”和“Common Name” 后选择 Saved to disk 进行保存 。 
--&amp;gt; 继续返回Apple developer 网站点击 Continue ，上传刚刚生成的 .certSigningRequest 文件生成 APNs Push Certificate。
下载并双击打开证书，证书打开时会启动“钥匙串访问”工具。在“钥匙串访问”中你的证书会显示在“我的证书”中，
注意选择“My Certificates” 和&amp;quot;login&amp;quot; 
--&amp;gt;  导出 .p12 证书文件(将文件保存为Personal Information Exchange (.p12)格式。)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-上传证书&quot;&gt;&lt;a href=&quot;#3-上传证书&quot; class=&quot;headerlink&quot; title=&quot;3. 上传证书&quot;&gt;&lt;/a&gt;3. 上传证书&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在 JPush 管理 Portal 上，针对某应用程序，上传上面步骤得到 .p12 证书文件。
这是 iOS SDK 能够接收到 JPush 推送消息的必要步骤。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Provisioning-Profile的创建&quot;&gt;&lt;a href=&quot;#Provisioning-Profile的创建&quot; class=&quot;headerlink&quot; title=&quot;Provisioning Profile的创建&quot;&gt;&lt;/a&gt;Provisioning Profile的创建&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;创建Provisioning Profile的前提，已在Apple Developer网站创建待发布应用所使用的Bundle ID的App ID，
且为该App ID创建了APNs证书
 --&amp;gt; 在苹果开发者账号的Provisioning Profile页面点击&amp;quot;+&amp;quot;按钮，创建Provisioning Profile 
 --&amp;gt; 选择此Provisioning Profile的环境后点击[Continue]： 
 --&amp;gt;  选择要创建Provisioning Profile的App ID后点击[Continue]：
 --&amp;gt; 选择所属的开发者证书，（这里创建了多个开发者证书，建议只创建一个，方便管理）为了方便，
 选择了[Select All],再点击[Continue]进入下一步
--&amp;gt; 为该Provisioning Profile选择将要安装的设备（一般选择[Select All]），点击[Continue] 
--&amp;gt; 给该Provisioning Profile填写Profile Name，点击[generate]完成创建 
--&amp;gt; 填写完Profile Name后点击[generate]完成创建，之后点击[DownLoad]下载Provisioning Profile 
--&amp;gt; 双击下载下来的Provisioning Profile，添加到xcode。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;XCode的证书配置教程&quot;&gt;&lt;a href=&quot;#XCode的证书配置教程&quot; class=&quot;headerlink&quot; title=&quot;XCode的证书配置教程&quot;&gt;&lt;/a&gt;XCode的证书配置教程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1.打开xxx-info.plist的Bundle identifier项把上传到JPush 控制台的bundle id填写进去
2.点击项目，选择目标TARGETS后进入Build Setting 界面，搜索“Code signing”配置注册的证书
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;客户端设置&quot;&gt;&lt;a href=&quot;#客户端设置&quot; class=&quot;headerlink&quot; title=&quot;客户端设置&quot;&gt;&lt;/a&gt;客户端设置&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;开启Remote notifications
需要在Xcode 中修改应用的 Capabilities 开启Remote notifications
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取自定义消息推送内容&quot;&gt;&lt;a href=&quot;#获取自定义消息推送内容&quot; class=&quot;headerlink&quot; title=&quot;获取自定义消息推送内容&quot;&gt;&lt;/a&gt;获取自定义消息推送内容&lt;/h3&gt;&lt;p&gt;功能说明: 只有在前端运行的时候才能收到自定义消息的推送。从jpush服务器获取用户推送的自定义消息内容和标题以及附加字段等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;获取iOS的推送内容需要在delegate类中注册通知并实现回调方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取-RegistrationID&quot;&gt;&lt;a href=&quot;#获取-RegistrationID&quot; class=&quot;headerlink&quot; title=&quot;获取 RegistrationID&quot;&gt;&lt;/a&gt;获取 RegistrationID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+(NSString *)registrationID
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;标签与别名-API-iOS&quot;&gt;&lt;a href=&quot;#标签与别名-API-iOS&quot; class=&quot;headerlink&quot; title=&quot;标签与别名 API (iOS)&quot;&gt;&lt;/a&gt;标签与别名 API (iOS)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+ (void)setTags:(NSSet *)tags alias:(NSString *)alias callbackSelector:(SEL)cbSelector object:(id)theTarget;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建应用程序ID&quot;&gt;&lt;a href=&quot;#1-创建应用程序ID&quot; class=&quot;headerlink&quot; title=&quot;1. 创建应用程序ID&quot;&gt;&lt;/a&gt;1. 创建应用程序ID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;登陆 iOS Dev Center 选择进入iOS Provisioning Portal  ---&amp;gt; 点击App IDs进入App ID列表
 ---&amp;gt; 为 App 开启 Push Notification 功能。如果是已经创建的 App ID 也可以通过设置开启 Push Notification 功能。
  --&amp;gt; 根据实际情况完善 App ID 信息并提交,注意此处需要指定具体的 Bundle ID 不要使用通配符。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结3</title>
    <link href="http://yoursite.com/2016/05/22/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%933/"/>
    <id>http://yoursite.com/2016/05/22/iOS特别技能点总结3/</id>
    <published>2016-05-22T02:42:01.000Z</published>
    <updated>2016-05-22T02:54:25.000Z</updated>
    
    <content type="html">&lt;p&gt;CFAbsoluteTimeGetCurrent()&lt;br&gt; 获取系统运行的当前绝对时间&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;nsarray-类定义的方法&quot;&gt;&lt;a href=&quot;#nsarray-类定义的方法&quot; class=&quot;headerlink&quot; title=&quot;nsarray 类定义的方法&quot;&gt;&lt;/a&gt;nsarray 类定义的方法&lt;/h3&gt;&lt;p&gt;1.makeObjectsPerformSelector:@select（aMethod）&lt;br&gt;简介：让数组中的每个元素 都调用 aMethod &lt;/p&gt;
&lt;p&gt;2.makeObjectsPerformSelector:@select（aMethod） withObject:oneObject&lt;br&gt;简介：让数组中的每个元素 都调用 aMethod  并把 withObject 后边的 oneObject 对象做为参数传给方法aMethod&lt;/p&gt;
&lt;h3 id=&quot;支付宝的接入注意点总结&quot;&gt;&lt;a href=&quot;#支付宝的接入注意点总结&quot; class=&quot;headerlink&quot; title=&quot;支付宝的接入注意点总结&quot;&gt;&lt;/a&gt;支付宝的接入注意点总结&lt;/h3&gt;&lt;p&gt;1.确保需要的库全部导入&lt;/p&gt;
&lt;p&gt;2.partner ,seller ,privateKey   三个参数的完整&lt;/p&gt;
&lt;p&gt;3.支付完成跳回程序需要设置 appScheme ， 最好使用英文，中文识别可能出错，造成无法跳回。 &lt;/p&gt;
&lt;h3 id=&quot;去除点击-cell-的效果&quot;&gt;&lt;a href=&quot;#去除点击-cell-的效果&quot; class=&quot;headerlink&quot; title=&quot;去除点击 cell 的效果&quot;&gt;&lt;/a&gt;去除点击 cell 的效果&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[tableView deselectRowAtIndexPath:indexPath animated:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;时间日期的格式转化&quot;&gt;&lt;a href=&quot;#时间日期的格式转化&quot; class=&quot;headerlink&quot; title=&quot;时间日期的格式转化&quot;&gt;&lt;/a&gt;时间日期的格式转化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSNumber *startTime = [temp objectForKey:@&amp;quot;addtime&amp;quot;];
NSDate *startTimeDate = [NSDate dateWithTimeIntervalSince1970:[startTime intValue]];
NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
[formatter setDateFormat:@&amp;quot;yyyy-MM-dd HH:mm&amp;quot;];//设置源时间字符串的格式
NSString *targetTime = [formatter stringFromDate:startTimeDate];//将时间转化成目标时间字符串
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;修改-tableCell-里面的图片圆角&quot;&gt;&lt;a href=&quot;#修改-tableCell-里面的图片圆角&quot; class=&quot;headerlink&quot; title=&quot;修改 tableCell 里面的图片圆角&quot;&gt;&lt;/a&gt;修改 tableCell 里面的图片圆角&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在 cell 的 .m 文件里面修改

- (void)awakeFromNib {
    _imgHead.clipsToBounds = YES;
    _imgHead.layer.cornerRadius = 30;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;下拉刷新的时候如何防止-crash-（不判断是否有新数据加入，直接刷新，会有轻微的不适感）&quot;&gt;&lt;a href=&quot;#下拉刷新的时候如何防止-crash-（不判断是否有新数据加入，直接刷新，会有轻微的不适感）&quot; class=&quot;headerlink&quot; title=&quot;下拉刷新的时候如何防止 crash （不判断是否有新数据加入，直接刷新，会有轻微的不适感）&quot;&gt;&lt;/a&gt;下拉刷新的时候如何防止 crash （不判断是否有新数据加入，直接刷新，会有轻微的不适感）&lt;/h3&gt;&lt;p&gt;   在下拉刷新的时候，需要将数组内所有的数据移除，并且将界面刷新一遍，这样可以防止 crash。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.trainRoutineArray removeAllObjects];
[self.table reloadData];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;在解析-json-数据的时候需要在循环体内初始化-Model-，这样才是正确的，在外部初始化会导致添加的数据重复。&quot;&gt;&lt;a href=&quot;#在解析-json-数据的时候需要在循环体内初始化-Model-，这样才是正确的，在外部初始化会导致添加的数据重复。&quot; class=&quot;headerlink&quot; title=&quot;在解析 json 数据的时候需要在循环体内初始化 Model ，这样才是正确的，在外部初始化会导致添加的数据重复。&quot;&gt;&lt;/a&gt;在解析 json 数据的时候需要在循环体内初始化 Model ，这样才是正确的，在外部初始化会导致添加的数据重复。&lt;/h3&gt;&lt;p&gt;   原因： 在外部初始化，会导致内存空间只分配一次，在第一次赋值之后，会因为 Model 里面的 NSString 类型的数据无法被第二次赋值，造成了第二次添加数据到数组的时候还是第一次的数据。&lt;/p&gt;
&lt;p&gt;   常用日期结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;yyyy-MM-dd HH:mm:ss.SSS
yyyy-MM-dd HH:mm:ss
yyyy-MM-dd
MM dd yyyy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  iOS-NSDateFormatter 格式说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;G: 公元时代，例如AD公元
yy:年的后2位
yyyy:完整年
MM:月，显示为1-12
MMM:月，显示为英文月份简写,如 Jan
MMMM:月，显示为英文月份全称，如 Janualy
dd:日，2位数表示，如02
d:日，1-2位显示，如 2
EEE:简写星期几，如Sun
EEEE:全写星期几，如Sunday
aa:上下午，AM/PM
H:时，24小时制，0-23
K：时，12小时制，0-11
m:分，1-2位
mm:分，2位
s:秒，1-2位
ss:秒，2位
S:毫秒
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误： &lt;em&gt; Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘-[__NSCFNumber length]: unrecognized selector sent to instance 0x15580c90’ &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;原因： 因为在接收的 Model 里面有些数据类型跟 json 数据的字段类型不同 （一般是非字符串的类型造成的）&lt;br&gt;解决方案： 将 json 数据里面的 int 或者 double 类型直接使用中间类型 NSNumber 类型来接收，并转化成 NSString 类型。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;上传图片&quot;&gt;&lt;a href=&quot;#上传图片&quot; class=&quot;headerlink&quot; title=&quot;上传图片&quot;&gt;&lt;/a&gt;上传图片&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[afManager POST:url parameters:parameters constructingBodyWithBlock:^(id&amp;lt;AFMultipartFormData&amp;gt; formData) {

     NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
     formatter.dateFormat = @&amp;quot;yyyyMMddHHmmss&amp;quot;;
     NSString *str = [formatter stringFromDate:[NSDate date]];

     [formData appendPartWithFileData:filename name:@&amp;quot;file&amp;quot; fileName:[NSString stringWithFormat:@&amp;quot;%@image1.png&amp;quot;,str] mimeType:@&amp;quot;image/png&amp;quot;];
 } success:^(AFHTTPRequestOperation * _Nonnull operation, id  _Nonnull responseObject) {

     if (success) {

         success(responseObject);
      }

 } failure:^(AFHTTPRequestOperation * _Nonnull operation, NSError * _Nonnull error) {

     if (failure) {

       failure(error);
    }
 }];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;CFAbsoluteTimeGetCurrent()&lt;br&gt; 获取系统运行的当前绝对时间&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>方法性能方法</title>
    <link href="http://yoursite.com/2016/05/20/%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/20/方法性能方法/</id>
    <published>2016-05-20T14:59:25.000Z</published>
    <updated>2016-05-20T15:01:59.000Z</updated>
    
    <content type="html">&lt;p&gt;性能测试   &lt;/p&gt;
&lt;p&gt;通常enumerateObjectsUsingBlock: 和 (for(… in …)在效率上基本一致，有时会快些。主要是因为它们都是基于 NSFastEnumeration 实现的. 快速迭代在处理的过程中需要多一次转换，当然也会消耗掉一些时间. 基于Block的迭代可以达到本机存储一样快的遍历集合. 对于字典同样适用，而数组的迭代却不行。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;（ &lt;a href=&quot;http://stackoverflow.com/questions/4486622/when-to-use-enumerateobjectsusingblock-vs-for&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/4486622/when-to-use-enumerateobjectsusingblock-vs-for&lt;/a&gt; ）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSMutableArray *test = [NSMutableArray array];
for (int i= 0; i &amp;lt; 10000000; i++) {
    [test addObject:@(i)];
}
int sum = 0;

double date_s = CFAbsoluteTimeGetCurrent();
for (int i = 0;i &amp;lt; test.count; i++) {
    sum += 1;
}
double date_e =  CFAbsoluteTimeGetCurrent();
NSLog(@&amp;quot;ForLoop Time: %f&amp;quot;, date_e - date_s);

date_s =  CFAbsoluteTimeGetCurrent();
for (id obj in test) {
    sum += 1;
}
date_e =  CFAbsoluteTimeGetCurrent();
NSLog(@&amp;quot;Enumeration Time: %f&amp;quot;, date_e - date_s);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  注意”enumerateObjectsUsingBlock” 修改局部变量时， 你需要声明局部变量为 __block 类型.&lt;/p&gt;
&lt;p&gt;  enumerateObjectsWithOptions:usingBlock: 支持并发迭代或反向迭代，并发迭代时效率也非常高.&lt;/p&gt;
&lt;p&gt;  对于字典而言, enumerateObjectsWithOptions:usingBlock 也是唯一的方式可以并发实现恢复Key-Value值.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;性能测试   &lt;/p&gt;
&lt;p&gt;通常enumerateObjectsUsingBlock: 和 (for(… in …)在效率上基本一致，有时会快些。主要是因为它们都是基于 NSFastEnumeration 实现的. 快速迭代在处理的过程中需要多一次转换，当然也会消耗掉一些时间. 基于Block的迭代可以达到本机存储一样快的遍历集合. 对于字典同样适用，而数组的迭代却不行。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结2</title>
    <link href="http://yoursite.com/2016/05/20/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%932/"/>
    <id>http://yoursite.com/2016/05/20/iOS特别技能点总结2/</id>
    <published>2016-05-20T14:53:45.000Z</published>
    <updated>2016-05-20T14:58:01.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;iOS-通知&quot;&gt;&lt;a href=&quot;#iOS-通知&quot; class=&quot;headerlink&quot; title=&quot;iOS 通知&quot;&gt;&lt;/a&gt;iOS 通知&lt;/h3&gt;&lt;p&gt;1.在数据发生变化的界面进行通知注册和发送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; NSArray *saveImageArray = [[NSArray alloc] initWithObjects:@&amp;quot;123&amp;quot;, nil];
[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;postData&amp;quot; object:saveImageArray];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.在通知接收界面进行通知监测和作出反应&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver:self
                                      selector:@selector(PostImage:)//接收消息方法
                                          name:@&amp;quot;postData&amp;quot;//消息识别名称
                                        object:nil];
//实现方法
-(void)PostImage:(NSArray *)array {

    self.messageSign.hidden = NO;
    NSLog(@&amp;quot;array ===  %@&amp;quot;, array);
    //接收传送过来的消息
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.在接收通知的界面消失的时候进行–通知观察者的移除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; //移除observer   
[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;postData&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;界面间的跳转-–-（storyboard方式搭建界面）&quot;&gt;&lt;a href=&quot;#界面间的跳转-–-（storyboard方式搭建界面）&quot; class=&quot;headerlink&quot; title=&quot;界面间的跳转 – （storyboard方式搭建界面）&quot;&gt;&lt;/a&gt;界面间的跳转 – （storyboard方式搭建界面）&lt;/h3&gt;&lt;p&gt;1.界面间有 segue 的界面跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self performSegueWithIdentifier:@&amp;quot;segue的Identifier&amp;quot; sender:nil]; // 添加在需要跳转的地方

// 有 segue 的跳转都会调用到的方法
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {

   // 传送的数据
   ViewController *lVC = [segue destinationViewController];
   VC.team_id = self.team_id1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.界面间没有连线或者在不同的 storyboard 界面跳转&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取要跳转的 Storyboard
UIStoryboard *scoreStoryboard = [UIStoryboard storyboardWithName:@&amp;quot;Personal&amp;quot; bundle:nil];

// 需要在目标界面设置 Storyboard ID
PayViewController *payVC = [scoreStoryboard instantiateViewControllerWithIdentifier:@&amp;quot;PayViewController&amp;quot;];
payVC.diamondCount = 1;

[self.navigationController pushViewController:payVC animated:YES];
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;错误 ：UIImage stringByDeletingPathExtension]: unrecognized selector sent to instance 0xbe79910&lt;/p&gt;
&lt;p&gt;原因 ：你所使用的对象已经是 UIImage ，不能再分割成其他对象&lt;/p&gt;
&lt;p&gt;解决方案： 寻找使用了这个对象的地方，并修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;单独对一些文件设置-ARC-或者设置-非ARC&quot;&gt;&lt;a href=&quot;#单独对一些文件设置-ARC-或者设置-非ARC&quot; class=&quot;headerlink&quot; title=&quot;单独对一些文件设置 ARC 或者设置 非ARC&quot;&gt;&lt;/a&gt;单独对一些文件设置 ARC 或者设置 非ARC&lt;/h3&gt;&lt;p&gt;1.如果项目建立时未使用ARC，想将其改为ARC，可以在building setting中修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在Building Setting中搜索auto reference

将Objective-C Automatic Reference Counting一行设置为YES即可
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.因为之前没有ARC机制，好多比较好的类库都是使用的非ARC，或是有些大牛还是不喜欢用ARC，封装的类也是非ARC的，想要在自己的ARC项目中使用这些非ARC类库，只需要简单的设置一下就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;在TARGETS-Bulid Phares-Compile Sources中找到非ARC的文件，双击，在弹出的框中添加

   -fno-objc-arc
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.UIImage转化成NSData&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSData *data;
if (UIImagePNGRepresentation(image) == nil) {

      data = UIImageJPEGRepresentation(image, 1);
    } else {

      data = UIImagePNGRepresentation(image);
} 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;iOS-通知&quot;&gt;&lt;a href=&quot;#iOS-通知&quot; class=&quot;headerlink&quot; title=&quot;iOS 通知&quot;&gt;&lt;/a&gt;iOS 通知&lt;/h3&gt;&lt;p&gt;1.在数据发生变化的界面进行通知注册和发送&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; NSArray *saveImageArray = [[NSArray alloc] initWithObjects:@&amp;quot;123&amp;quot;, nil];
[[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;postData&amp;quot; object:saveImageArray];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式kvo</title>
    <link href="http://yoursite.com/2016/05/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8Fkvo/"/>
    <id>http://yoursite.com/2016/05/17/设计模式kvo/</id>
    <published>2016-05-17T13:32:36.000Z</published>
    <updated>2016-05-17T13:33:52.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;KVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。&lt;/p&gt;
&lt;p&gt;   在初始化方法中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_tableView addObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; options:NSKeyValueObservingOptionNew context:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;   在dealloc中移除KVO监听：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_tableView removeObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; context:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  添加默认的响应回调方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {

  [self doSomethingWhenContentOffsetChanges];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h3&gt;&lt;p&gt;1.当你在controller中添加多个KVO时，所有的回调都是走同上述函数，那就必须对触发回调函数的来源进行判断。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断如下：

 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {

       if (object == _tableView &amp;amp;&amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) {

           [self doSomethingWhenContentOffsetChanges];
        }
   }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.假设当前类(在例子中为UITableViewController)还有父类，并且父类也有自己绑定了一些其他KVO呢？我们看到，上述回调函数体中只有一个判断，如果这个if不成立，这次KVO事件的触发就会到此中断了。但事实上，若当前类无法捕捉到这个KVO，那很有可能是在他的superClass，或者super-superClass…中，上述处理砍断了这个链。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;合理的处理方式应该是这样的：

   - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context
     {
       if (object == _tableView &amp;amp;&amp;amp; [keyPath isEqualToString:@&amp;quot;contentOffset&amp;quot;]) {

           [self doSomethingWhenContentOffsetChanges];
       } else {

          [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
       }
     }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.潜在的问题有可能出现在dealloc中对KVO的注销上。KVO的一种缺陷(其实不能称为缺陷，应该称为特性)是，当对同一个keypath进行两次removeObserver时会导致程序crash，这种情况常常出现在父类有一个kvo，父类在dealloc中remove了一次，子类又remove了一次的情况下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 我们可以分别在父类以及本类中定义各自的context字符串，比如在本类中定义context为@&amp;quot;ThisIsMyKVOContextNotSuper&amp;quot;;然后在dealloc中remove observer时指定移除的自身添加的observer。
这样iOS就能知道移除的是自己的kvo，而不是父类中的kvo，避免二次remove造成crash。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;KVO，全称为Key-Value Observing，是iOS中的一种设计模式，用于检测对象的某些属性的实时变化情况并作出响应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，假设我们的目标是在一个UITableViewController内对tableview的contentOffset进行实时监测，很容易地使用KVO来实现为。&lt;/p&gt;
&lt;p&gt;   在初始化方法中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[_tableView addObserver:self forKeyPath:@&amp;quot;contentOffset&amp;quot; options:NSKeyValueObservingOptionNew context:nil];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>预编译指令</title>
    <link href="http://yoursite.com/2016/05/16/%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/05/16/预编译指令/</id>
    <published>2016-05-16T13:38:49.000Z</published>
    <updated>2016-05-16T13:43:13.000Z</updated>
    
    <content type="html">&lt;p&gt;常见的预处理功能&lt;/p&gt;
&lt;p&gt;预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ 文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

＊ 条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

＊ 布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

＊ 宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; 预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。可见预处理过程先于编译器对源代码进行处理。&lt;/p&gt;
&lt;p&gt; 预处理指令是以#开头的代码行，#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。正行语句构成了一条预处理指令，该指令酱紫啊编译器进行编译之前对源代码做某些转换，下面是一些&lt;/p&gt;
&lt;h3 id=&quot;常用的预处理指令&quot;&gt;&lt;a href=&quot;#常用的预处理指令&quot; class=&quot;headerlink&quot; title=&quot;常用的预处理指令&quot;&gt;&lt;/a&gt;常用的预处理指令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#   空指令，没有任何效果

#include 包含一个源代码文件

#define 定义宏

#undef 取消定义宏

#if 如果条件为真，则编译下面的代码

#elif 如果前面的#if不为真，则编译下面的代码

#endif 结束一个#if...#elif条件编译块

#ifdef 如果已经定义了某个宏，则编译下面的代码

#ifndef 如果没有定义某个宏，则编译下面的代码

#error 停止编译并显示错误信息

#pragma 为编译程序提供非常规的控制流信息
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 这些指令的主要目的是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。&lt;/p&gt;
&lt;h3 id=&quot;预定义标识符&quot;&gt;&lt;a href=&quot;#预定义标识符&quot; class=&quot;headerlink&quot; title=&quot;预定义标识符&quot;&gt;&lt;/a&gt;预定义标识符&lt;/h3&gt;&lt;p&gt;  为了处理一些有用的信息，预处理定义了一些预处理标识符，虽然各种编译器的预处理标识符不尽相同，但是他们都会处理下面的4种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__FILE__ 正在编译的文件的名字
__LINE__ 正在编译的文件的行号
__DATE__ 编译时刻的日期字符串，例如： &amp;quot;25 Jan 2006&amp;quot;
__TIME__ 编译时刻的时间字符串，例如： &amp;quot;12:30:55&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;常见的预处理功能&lt;/p&gt;
&lt;p&gt;预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ 文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

＊ 条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

＊ 布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

＊ 宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结</title>
    <link href="http://yoursite.com/2016/05/07/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/05/07/iOS特别技能点总结/</id>
    <published>2016-05-07T11:33:38.000Z</published>
    <updated>2016-05-16T13:55:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;修改状态栏颜色&quot;&gt;&lt;a href=&quot;#修改状态栏颜色&quot; class=&quot;headerlink&quot; title=&quot;修改状态栏颜色&quot;&gt;&lt;/a&gt;修改状态栏颜色&lt;/h3&gt;&lt;p&gt;1.在 info.plist 添加 View controller-based status bar appearance 并设置为 NO（白色），YES（黑色）， 如果为NO，并在 Appdelegate 里面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
则可设置为白色。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.在有 navigationbar 的时候需要 添加方法 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UIStatusBarStyle)preferredStatusBarStyle {

return UIStatusBarStyleLightContent;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且在 viewDidload 中添加：self.navigationController.navigationBar.barStyle = UIBarStyleBlack;&lt;/p&gt;
&lt;p&gt;这样可以设置为白色&lt;/p&gt;
&lt;h3 id=&quot;修改-Bar-Button-Item-的颜色&quot;&gt;&lt;a href=&quot;#修改-Bar-Button-Item-的颜色&quot; class=&quot;headerlink&quot; title=&quot;修改 Bar Button Item 的颜色&quot;&gt;&lt;/a&gt;修改 Bar Button Item 的颜色&lt;/h3&gt;&lt;p&gt;如果要修改 Right Bar Button Items 的颜色，需要在 Bar Button Item 里面修改它的 Tint 的颜色。因为自定义右按钮Right Bar Button Items 有两个图层：Bar Button Item 和 View。&lt;/p&gt;
&lt;h3 id=&quot;警告：Plain-style-unsupported-in-a-Navigation-item&quot;&gt;&lt;a href=&quot;#警告：Plain-style-unsupported-in-a-Navigation-item&quot; class=&quot;headerlink&quot; title=&quot;警告：Plain style unsupported in a Navigation item&quot;&gt;&lt;/a&gt;警告：Plain style unsupported in a Navigation item&lt;/h3&gt;&lt;p&gt; 解决方法： 将 plain 设置成：Bordered 。&lt;/p&gt;
&lt;h3 id=&quot;怎样设置UITableView的cell之间的距离&quot;&gt;&lt;a href=&quot;#怎样设置UITableView的cell之间的距离&quot; class=&quot;headerlink&quot; title=&quot;怎样设置UITableView的cell之间的距离?&quot;&gt;&lt;/a&gt;怎样设置UITableView的cell之间的距离?&lt;/h3&gt;&lt;p&gt;分为两种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 分组表格    - 每段一个cell设置表头的高度 
2. 非分组表格  - 将tableViewCell的背景色，contentView的背景色设置为透明，在contentView中添加一个UIImageView做为背景，使UIImageView的高度小于cell的高度，这样创建出的tableView就可以使每个cell之间看起来有一定间隔。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;performSegueWithIdentifier-produce-no-segue-with-identifier-error&quot;&gt;&lt;a href=&quot;#performSegueWithIdentifier-produce-no-segue-with-identifier-error&quot; class=&quot;headerlink&quot; title=&quot;performSegueWithIdentifier produce no segue with identifier error&quot;&gt;&lt;/a&gt;performSegueWithIdentifier produce no segue with identifier error&lt;/h3&gt;&lt;p&gt;   解决方法：先检查要跳转的界面和目的界面的表格的协议（delegate和datasource）是否有代理。然后检查是否给控制器添加了类。&lt;/p&gt;
&lt;p&gt;1.在 ios 中如果遇到添加的图片没有显示出来，可以先检查图片的名称是否正确，&lt;br&gt; 然后检查图片的格式是否是 PNG 格式，最后检查是否已经添加到工程当中了。&lt;/p&gt;
&lt;p&gt;2.在tableView 中 cell 的跳转，需要使用控制器间的跳转。 &lt;/p&gt;
&lt;p&gt;3.异常：Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘&lt;em&gt;*&lt;/em&gt; -[UIViewController tableView:numberOfRowsInSection:]: unrecognized selector sent to instance 0x3b02120’&lt;/p&gt;
&lt;p&gt;   解决方法：检测视图控制器是否绑定了具体的类。&lt;/p&gt;
&lt;p&gt;4.this class is not key value coding-compliant for the key XXX错误的解决方法&lt;/p&gt;
&lt;p&gt;   解决方法：在设置IBAction和IBOutlet时有多余的连线，按下ctrl键检查控件的连接将多余的连续删除后程序正常运行。&lt;/p&gt;
&lt;p&gt;5.this class is not key value coding-compliant for the key leftTitle.&lt;/p&gt;
&lt;p&gt;   解决方法： 因为sb 或者 xib 中的控件链接的属性有些没有出现在页面绑定的控制器上，造成引用上的健值错误。&lt;/p&gt;
&lt;p&gt;6.OC之OBJC2_UNAVAILABLE&lt;/p&gt;
&lt;p&gt;  意即在OBJC2.0中，这些东西将被删除。&lt;/p&gt;
&lt;h3 id=&quot;去除-tableView-的-sectionView-的粘性&quot;&gt;&lt;a href=&quot;#去除-tableView-的-sectionView-的粘性&quot; class=&quot;headerlink&quot; title=&quot;去除 tableView 的 sectionView 的粘性&quot;&gt;&lt;/a&gt;去除 tableView 的 sectionView 的粘性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

   CGFloat sectionHeaderHeight = 45;
   if (scrollView.contentOffset.y &amp;lt;= sectionHeaderHeight&amp;amp;&amp;amp;scrollView.contentOffset.y &amp;gt;= 0) {

       scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
   }
   else if (scrollView.contentOffset.y &amp;gt;= sectionHeaderHeight) {

       scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;修改-textField-的-placeholder-的字体颜色，大小&quot;&gt;&lt;a href=&quot;#修改-textField-的-placeholder-的字体颜色，大小&quot; class=&quot;headerlink&quot; title=&quot;修改 textField 的 placeholder 的字体颜色，大小&quot;&gt;&lt;/a&gt;修改 textField 的 placeholder 的字体颜色，大小&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[textField setValue:[UIColor redColor] forKeyPath:@&amp;quot;_placeholderLabel.textColor&amp;quot;];  

[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&amp;quot;_placeholderLabel.font&amp;quot;]; 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;修改状态栏颜色&quot;&gt;&lt;a href=&quot;#修改状态栏颜色&quot; class=&quot;headerlink&quot; title=&quot;修改状态栏颜色&quot;&gt;&lt;/a&gt;修改状态栏颜色&lt;/h3&gt;&lt;p&gt;1.在 info.plist 添加 View controller-based status bar appearance 并设置为 NO（白色），YES（黑色）， 如果为NO，并在 Appdelegate 里面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
则可设置为白色。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习（三）</title>
    <link href="http://yoursite.com/2016/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/05/深度学习（三）/</id>
    <published>2016-05-05T13:11:48.000Z</published>
    <updated>2016-05-05T13:23:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;关于特征&quot;&gt;&lt;a href=&quot;#关于特征&quot; class=&quot;headerlink&quot; title=&quot;关于特征&quot;&gt;&lt;/a&gt;关于特征&lt;/h3&gt;&lt;h4 id=&quot;4-1、特征表示的粒度&quot;&gt;&lt;a href=&quot;#4-1、特征表示的粒度&quot; class=&quot;headerlink&quot; title=&quot;4.1、特征表示的粒度&quot;&gt;&lt;/a&gt;4.1、特征表示的粒度&lt;/h4&gt;&lt;p&gt;学习算法在一个什么粒度上的特征表示，才有能发挥作用？就一个图片来说，像素级的特征根本没有价值。例如下面的摩托车，从像素级别，根本得不到任何信息，其无法进行摩托车和非摩托车的区分。而如果特征是一个具有结构性（或者说有含义）的时候，比如是否具有车把手（handle），是否具有车轮（wheel），就很容易把摩托车和非摩托车区分，学习算法才能发挥作用。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-2、初级（浅层）特征表示&quot;&gt;&lt;a href=&quot;#4-2、初级（浅层）特征表示&quot; class=&quot;headerlink&quot; title=&quot;4.2、初级（浅层）特征表示&quot;&gt;&lt;/a&gt;4.2、初级（浅层）特征表示&lt;/h4&gt;&lt;p&gt;1995 年前后，Bruno Olshausen和 David Field 两位学者任职 Cornell University，他们试图同时用生理学和计算机的手段，双管齐下，研究视觉问题。&lt;br&gt;他们收集了很多黑白风景照片，从这些照片中，提取出400个小碎片，每个照片碎片的尺寸均为 16x16 像素，不妨把这400个碎片标记为 S[i], i = 0,.. 399。接下来，再从这些黑白风景照片中，随机提取另一个碎片，尺寸也是 16x16 像素，不妨把这个碎片标记为 T。&lt;br&gt;他们提出的问题是，如何从这400个碎片中，选取一组碎片，S[k], 通过叠加的办法，合成出一个新的碎片，而这个新的碎片，应当与随机选择的目标碎片 T，尽可能相似，同时，S[k] 的数量尽可能少。用数学的语言来描述，就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sum_k (a[k] * S[k]) --&amp;gt; T, 其中 a[k] 是在叠加碎片 S[k] 时的权重系数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为解决这个问题，Bruno Olshausen和 David Field 发明了一个算法，稀疏编码（Sparse Coding）。&lt;br&gt;稀疏编码是一个重复迭代的过程，每次迭代分两步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）选择一组 S[k]，然后调整 a[k]，使得Sum_k (a[k] * S[k]) 最接近 T。
2）固定住 a[k]，在 400 个碎片中，选择其它更合适的碎片S’[k]，替代原先的 S[k]，使得Sum_k (a[k] * S’[k]) 最接近 T。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经过几次迭代后，最佳的 S[k] 组合，被遴选出来了。令人惊奇的是，被选中的 S[k]，基本上都是照片上不同物体的边缘线，这些线段形状相似，区别在于方向。&lt;/p&gt;
&lt;p&gt;Bruno Olshausen和 David Field 的算法结果，与 David Hubel 和Torsten Wiesel 的生理发现，不谋而合！&lt;br&gt;也就是说，复杂图形，往往由一些基本结构组成。&lt;/p&gt;
&lt;h4 id=&quot;4-3、结构性特征表示&quot;&gt;&lt;a href=&quot;#4-3、结构性特征表示&quot; class=&quot;headerlink&quot; title=&quot;4.3、结构性特征表示&quot;&gt;&lt;/a&gt;4.3、结构性特征表示&lt;/h4&gt;&lt;p&gt;小块的图形可以由基本edge构成，更结构化，更复杂的，具有概念性的图形如何表示呢？这就需要更高层次的特征表示，比如V2，V4。因此V1看像素级是像素级。V2看V1是像素级，这个是层次递进的，高层表达由底层表达的组合而成。专业点说就是基basis。V1取提出的basis是边缘，然后V2层是V1层这些basis的组合，这时候V2区得到的又是高一层的basis。即上一层的basis组合的结果，上上层又是上一层的组合basis……（所以有大牛说Deep learning就是“搞基”，因为难听，所以美其名曰Deep learning或者Unsupervised Feature Learning）&lt;/p&gt;
&lt;p&gt;直观上说，就是找到make sense的小patch再将其进行combine，就得到了上一层的feature，递归地向上learning feature。&lt;br&gt;在不同object上做training是，所得的edge basis 是非常相似的，但object parts和models 就会completely different了（那咱们分辨car或者face是不是容易多了）：&lt;/p&gt;
&lt;h4 id=&quot;4-4、需要有多少个特征？&quot;&gt;&lt;a href=&quot;#4-4、需要有多少个特征？&quot; class=&quot;headerlink&quot; title=&quot;4.4、需要有多少个特征？&quot;&gt;&lt;/a&gt;4.4、需要有多少个特征？&lt;/h4&gt;&lt;p&gt;我们知道需要层次的特征构建，由浅入深，但每一层该有多少个特征呢？&lt;br&gt;任何一种方法，特征越多，给出的参考信息就越多，准确性会得到提升。但特征多意味着计算复杂，探索的空间大，可以用来训练的数据在每个特征上就会稀疏，都会带来各种问题，并不一定特征越多越好。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于特征&quot;&gt;&lt;a href=&quot;#关于特征&quot; class=&quot;headerlink&quot; title=&quot;关于特征&quot;&gt;&lt;/a&gt;关于特征&lt;/h3&gt;&lt;h4 id=&quot;4-1、特征表示的粒度&quot;&gt;&lt;a href=&quot;#4-1、特征表示的粒度&quot; class=&quot;headerlink&quot; title=&quot;4.1、特征表示的粒度&quot;&gt;&lt;/a&gt;4.1、特征表示的粒度&lt;/h4&gt;&lt;p&gt;学习算法在一个什么粒度上的特征表示，才有能发挥作用？就一个图片来说，像素级的特征根本没有价值。例如下面的摩托车，从像素级别，根本得不到任何信息，其无法进行摩托车和非摩托车的区分。而如果特征是一个具有结构性（或者说有含义）的时候，比如是否具有车把手（handle），是否具有车轮（wheel），就很容易把摩托车和非摩托车区分，学习算法才能发挥作用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习（二）</title>
    <link href="http://yoursite.com/2016/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/05/深度学习（二）/</id>
    <published>2016-05-05T13:03:45.000Z</published>
    <updated>2016-05-05T13:13:10.000Z</updated>
    
    <content type="html">&lt;p&gt;那它是怎么学习的呢？怎么知道哪些特征好哪些不好呢？我们说机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为的学科。&lt;/p&gt;
&lt;h3 id=&quot;人脑视觉机理&quot;&gt;&lt;a href=&quot;#人脑视觉机理&quot; class=&quot;headerlink&quot; title=&quot;人脑视觉机理&quot;&gt;&lt;/a&gt;人脑视觉机理&lt;/h3&gt;&lt;p&gt;可视皮层是分级的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 神经-中枢-大脑的工作过程，或许是一个不断迭代、不断抽象的过程&lt;/strong&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;这里的关键词有两个，一个是抽象，一个是迭代。从原始信号，做低级抽象，逐渐向高级抽象迭代。&lt;strong&gt;人类的逻辑思维，经常使用高度抽象的概念&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总的来说，人的视觉系统的信息处理是分级的。从低级的V1区提取边缘特征，再到V2区的形状或者目标的部分等，再到更高层，整个目标、目标的行为等。也就是说高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。例如，单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/danao.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;那它是怎么学习的呢？怎么知道哪些特征好哪些不好呢？我们说机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为的学科。&lt;/p&gt;
&lt;h3 id=&quot;人脑视觉机理&quot;&gt;&lt;a href=&quot;#人脑视觉机理&quot; class=&quot;headerlink&quot; title=&quot;人脑视觉机理&quot;&gt;&lt;/a&gt;人脑视觉机理&lt;/h3&gt;&lt;p&gt;可视皮层是分级的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 神经-中枢-大脑的工作过程，或许是一个不断迭代、不断抽象的过程&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习（一）</title>
    <link href="http://yoursite.com/2016/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%EF%BC%8D%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/05/深度学习（－）/</id>
    <published>2016-05-05T12:46:40.000Z</published>
    <updated>2016-05-05T13:37:54.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; Artificial Intelligence，也就是人工智能&lt;/strong&gt;，就像长生不老和星际漫游一样，是人类最美好的梦想之一。&lt;/p&gt;
&lt;p&gt;  图灵（图灵，大家都知道吧。计算机和人工智能的鼻祖，分别对应于其著名的“图灵机”和“图灵测试”）在 1950 年的论文里，提出图灵试验的设想，即，隔墙对话，你将不知道与你谈话的，是人还是电脑。这无疑给计算机，尤其是人工智能，预设了一个很高的期望值。但是半个世纪过去了，人工智能的进展，远远没有达到图灵试验的标准。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  但是自 2006 年以来，机器学习领域，取得了突破性的进展。图灵试验，至少不是那么可望而不可及了。至于技术手段，不仅仅依赖于云计算对大数据的并行处理能力，而且依赖于算法。这个算法就是，Deep Learning。借助于 Deep Learning 算法，人类终于找到了如何处理“抽象概念”这个亘古难题的方法。&lt;/p&gt;
&lt;p&gt;  2012年6月，《纽约时报》披露了Google Brain项目，吸引了公众的广泛关注。这个项目是由著名的斯坦福大学的机器学习教授Andrew Ng和在大规模计算机系统方面的世界顶尖专家JeffDean共同主导，用16000个CPU Core的并行计算平台训练一种称为“深度神经网络”（DNN，Deep Neural Networks）的机器学习模型（内部共有10亿个节点。人脑中有150多亿个神经元），在语音识别和图像识别等领域获得了巨大的成功。&lt;/p&gt;
&lt;h3 id=&quot;机器学习（人工智能的核心）的背景&quot;&gt;&lt;a href=&quot;#机器学习（人工智能的核心）的背景&quot; class=&quot;headerlink&quot; title=&quot;机器学习（人工智能的核心）的背景&quot;&gt;&lt;/a&gt;机器学习（人工智能的核心）的背景&lt;/h3&gt;&lt;p&gt;  &lt;strong&gt; 机器学习（Machine Learning）是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能的学科。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  目前我们通过机器学习去解决这些问题的思路都是这样的（以视觉感知为例子）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/img/sfeature.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;   从开始的通过传感器（例如CMOS）来获得数据。然后经过预处理、特征提取、特征选择，再到推理、预测或者识别。最后一个部分，也就是机器学习的部分，绝大部分的工作是在这方面做的，也存在很多的paper和研究。&lt;/p&gt;
&lt;p&gt;  而中间的三部分，概括起来就是特征表达。良好的特征表达，对最终算法的准确性起了非常关键的作用，而且系统主要的计算和测试工作都耗在这一大部分。但，这块实际中一般都是人工完成的。靠人工提取特征。&lt;br&gt;&lt;img src=&quot;/img/manmade.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  截止现在，也出现了不少NB的特征（好的特征应具有不变性（大小、尺度和旋转等）和可区分性）：例如Sift的出现，是局部图像特征描述子研究领域一项里程碑式的工作。由于SIFT对尺度、旋转以及一定视角和光照变化等图像变化都具有不变性，并且SIFT具有很强的可区分性，的确让很多问题的解决变为可能。但它也不是万能的。&lt;/p&gt;
&lt;p&gt;  然而，手工地选取特征是一件非常费力、启发式（需要专业知识）的方法，能不能选取好很大程度上靠经验和运气，而且它的调节需要大量的时间。&lt;br&gt;  既然手工选取特征不太好，那么能不能自动地学习一些特征呢？&lt;br&gt;  答案是能！&lt;br&gt;  &lt;strong&gt;Deep Learning就是用来干这个事情的，看它的一个别名UnsupervisedFeature Learning，就可以顾名思义了，Unsupervised的意思就是不要人参与特征的选取过程&lt;/strong&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; Artificial Intelligence，也就是人工智能&lt;/strong&gt;，就像长生不老和星际漫游一样，是人类最美好的梦想之一。&lt;/p&gt;
&lt;p&gt;  图灵（图灵，大家都知道吧。计算机和人工智能的鼻祖，分别对应于其著名的“图灵机”和“图灵测试”）在 1950 年的论文里，提出图灵试验的设想，即，隔墙对话，你将不知道与你谈话的，是人还是电脑。这无疑给计算机，尤其是人工智能，预设了一个很高的期望值。但是半个世纪过去了，人工智能的进展，远远没有达到图灵试验的标准。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单一功能原则</title>
    <link href="http://yoursite.com/2016/05/01/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2016/05/01/单一功能原则/</id>
    <published>2016-05-01T13:29:49.000Z</published>
    <updated>2016-05-01T13:34:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个术语由&lt;strong&gt;罗伯特·C·马丁（Robert Cecil Martin）&lt;/strong&gt;在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。&lt;/p&gt;
&lt;p&gt;马丁表述该原则是基于的《结构化分析和系统规格》一书中的内聚原则（Cohesion）上。&lt;/p&gt;
&lt;p&gt;马丁把功能（职责）定义为：“&lt;strong&gt;改变的原因&lt;/strong&gt;”，并且总结出一个类或者模块应该&lt;strong&gt;有且只有一个&lt;/strong&gt;改变的原因。&lt;/p&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一，报表的内容可以改变（编辑）。
第二，报表的格式可以改变（打印）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。&lt;br&gt;单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。&lt;br&gt;
    
    </summary>
    
    
      <category term="［类的魔法］" scheme="http://yoursite.com/tags/%EF%BC%BB%E7%B1%BB%E7%9A%84%E9%AD%94%E6%B3%95%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>基本文件操作filehandle的用法</title>
    <link href="http://yoursite.com/2016/04/29/%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cfilehandle%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/29/基本文件操作filehandle的用法/</id>
    <published>2016-04-29T12:57:38.000Z</published>
    <updated>2016-04-29T13:00:52.000Z</updated>
    
    <content type="html">&lt;p&gt;利用NSFilehandle类提供的方法，允许更有效地使用文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一般而言，处理文件时都要经历以下三个步骤：

1.打开文件，并获取一个NSFileHandle对象，以便在后面的I/O操作中引用该文件

2.对打开的文件执行I/O操作（读取、写入、更新）

3.关闭文件
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; NSFileHandle用于以标准输入、标准输出、标准错误和空设置的方法。他们的格式为fileHandleWithDevice，其中Device可以是StandardInput、StandardOutput、StandardError或者NullDevice。&lt;/p&gt;
&lt;p&gt; 应该注意到，&lt;strong&gt;NSFileHandle类并没有提供创建文件的功能&lt;/strong&gt;。必须使用NSFileManager方法来创建文件。因此，方法 fileHandleForWritingAtPath：和 hfileHandleUpdatingAtPath：都假定文件已经存在，否则返回nil。对于这两个方法，文件的偏移量都设为文件的开始，所以都是在文件的开始位置开始写入（或更新模式的读取）&lt;/p&gt;
&lt;p&gt; NSFileHandle常用方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(NSFileHandle*)fileHandleForReadingAtPath:path 打开一个文件用于读入

+(NSFileHandle*)fileHandleForWritingAtPath:path 打开一个文件用于写入

+(NSFileHandle*)fileHandleForUpdatingAtPath:path 打开一个文件用于读写

-(NSData*)availableData 从设备或者通道返回可用数据

-(NSData*)readDataToEndOfFile 读取其余的数据知道文件的末尾(最多UINT_MAX字节)

-(NSData*)readDataOfLength:(NSUInteger)bytes 从文件中读取指定字节的内容

-(void)writeData:data  将data写入文件

-(unsigned long long)offsetInFile 获取当前偏移量

-(void)seekToFileOffset:offset  设置偏移量

-(unsigned long long)seekToEndOfFile 将偏移量定位到文件的末尾

-(void)truncateFileAtOffset:offset 讲文件的长度设置为offset字节

-(void)closeFile 关闭文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法fileHandleForWritingAtPath和fileHandleForUpdatingAtPath所指定的文件必须是已经存在的，否则返回nil,另外对于这两个方法中文件的偏移量都是为文件的开始。&lt;/p&gt;
&lt;h3 id=&quot;部分代码&quot;&gt;&lt;a href=&quot;#部分代码&quot; class=&quot;headerlink&quot; title=&quot;部分代码&quot;&gt;&lt;/a&gt;部分代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSFileHandle *inFile, *outFile;
NSData *buffer;

//文件 1
NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
[[NSFileManager defaultManager] createFileAtPath:@&amp;quot;test.txt&amp;quot; contents:data attributes:nil];

//文件2
NSData *data2 = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/123&amp;quot;];
[[NSFileManager defaultManager] createFileAtPath:@&amp;quot;out.txt&amp;quot; contents:data2 attributes:nil];

// 打开test.txt文件用于读取操作
inFile = [NSFileHandle fileHandleForReadingAtPath:@&amp;quot;test.txt&amp;quot;];

// 打开test.txt文件用于写操作
outFile = [NSFileHandle fileHandleForWritingAtPath: @&amp;quot;out.txt&amp;quot;];
outFile = [NSFileHandle fileHandleForUpdatingAtPath:@&amp;quot;out.txt&amp;quot;];

// 读取数据
buffer = [inFile readDataToEndOfFile];
buffer = [inFile readDataOfLength:60];

// 写入数据
[outFile writeData:buffer];

//获取当前文件的偏移量
long long offset =  [outFile offsetInFile];
NSLog(@&amp;quot;offset = %lld&amp;quot;, offset);


//设置当前文件的偏移量
[inFile seekToFileOffset:100];

if(inFile == nil)
{
    NSLog(@&amp;quot;Open of testfile.txt for reading failed!&amp;quot;);
    return 1;
} else {

    buffer = [inFile readDataToEndOfFile];
    NSLog(@&amp;quot;%@&amp;quot;, buffer);
}

//关闭两个文件
[inFile closeFile];
[outFile closeFile];

NSLog(@&amp;quot;%@&amp;quot;, [NSString stringWithContentsOfFile:@&amp;quot;out.txt&amp;quot; encoding:NSUTF8StringEncoding error:nil]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;利用NSFilehandle类提供的方法，允许更有效地使用文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一般而言，处理文件时都要经历以下三个步骤：

1.打开文件，并获取一个NSFileHandle对象，以便在后面的I/O操作中引用该文件

2.对打开的文件执行I/O操作（读取、写入、更新）

3.关闭文件
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2016/04/27/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/04/27/位运算/</id>
    <published>2016-04-27T12:21:31.000Z</published>
    <updated>2016-04-27T12:25:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;头文件中的特别标记&quot;&gt;&lt;a href=&quot;#头文件中的特别标记&quot; class=&quot;headerlink&quot; title=&quot;头文件中的特别标记&quot;&gt;&lt;/a&gt;头文件中的特别标记&lt;/h3&gt;&lt;p&gt;0UL 表示 无符号长整型 0&lt;br&gt;1UL 表示 无符号长整型 1&lt;/p&gt;
&lt;p&gt; 如果不写UL后缀，系统默认为：int, 即，有符号整数。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt; 1.数值常数有：整型常数、浮点常数；&lt;br&gt; 2.只有数值常数才有后缀说明；&lt;br&gt; 3.数值常数后缀不区分字母大小写。&lt;/p&gt;
&lt;p&gt;（1）整型常数的表示形式有：十进制形式、以0开头的八进制形式、以0x开头的十六进制形式，无二进制形式。&lt;br&gt;    整型常数默认是signed int的。&lt;br&gt;    对整型常数进行类型转换的后缀只有：u或U（unsigned）、l或L（long）、u/U与l/L的组合（如：ul、lu、Lu等）。例：100u; -123u; 0x123l;&lt;/p&gt;
&lt;p&gt;（2）浮点常数的表示形式有：科学计数形式和小数点形式。&lt;br&gt;    浮点常数默认是double的。&lt;br&gt;    对浮点常数进行类型转换的后缀只有：f或F（单精度浮点数）、l或L（长双精度浮点数）。（注：因浮点型常数总是有符号的，故没有u或U后缀）。例：1.23e5f; 1.23l; -123.45f;&lt;/p&gt;
&lt;h3 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h3&gt;&lt;p&gt;  在许多计算机编程语言（例如：C语言、C++语言、Java语言、JavaScript语言、Pascal语言等）中，“&amp;gt;&amp;gt;”代表右移运算符，就相当于“shr”。该运算符为双目运算符，结合方向为从左到右，作用是把一个整型数的所有位向右移动指定的位数，移动到右边界之外的多余二进制位会被丢弃，并从左边界移入0。&lt;/p&gt;
&lt;p&gt;  右移运算的两个操作数应为整数类型。第一个操作数是要进行移位操作的数，第二个操作数指定第一个操作数移动的位数。如果第二个操作数等于0则不发生任何移位。&lt;/p&gt;
&lt;p&gt;应用举例：&lt;br&gt;        问：&lt;strong&gt;计算表达式14 &amp;gt;&amp;gt; 2的值&lt;/strong&gt;。&lt;br&gt;        答：表达式14 &amp;gt;&amp;gt; 2的值为3，因为14（即二进制的00001110）向右移两位等于3（即二进制的00000011）。&lt;/p&gt;
&lt;p&gt;  说白了，就是把要移动的数转换成2进制，右移几位就去掉右边的几位数，左移几位就在右边加几个0，比如14右移2位就是转成二进制变成1110，去掉右边的10，变成11，11转成十进制就是3；左移2位就是111000，转成十进制就是56。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,&lt;br&gt;也就是说,枚举值里面存取的是 计算后的十进制值. &lt;/p&gt;
&lt;p&gt;打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论&lt;strong&gt;你如何组合在一起,也不会产生两个同样的数字&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;头文件中的特别标记&quot;&gt;&lt;a href=&quot;#头文件中的特别标记&quot; class=&quot;headerlink&quot; title=&quot;头文件中的特别标记&quot;&gt;&lt;/a&gt;头文件中的特别标记&lt;/h3&gt;&lt;p&gt;0UL 表示 无符号长整型 0&lt;br&gt;1UL 表示 无符号长整型 1&lt;/p&gt;
&lt;p&gt; 如果不写UL后缀，系统默认为：int, 即，有符号整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>字符串加密之Base64</title>
    <link href="http://yoursite.com/2016/04/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%B9%8BBase64/"/>
    <id>http://yoursite.com/2016/04/27/字符串加密之Base64/</id>
    <published>2016-04-27T12:18:00.000Z</published>
    <updated>2016-04-27T12:31:36.000Z</updated>
    
    <content type="html">&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;转码过程例子：

    3*8=4*6
    内存1个字符占8位

    转前： s 1 3

    先转成ascii：对应 115 49 51

    2进制： 01110011 00110001 00110011

    6个一组（4组） 011100110011000100110011

    然后才有后面的 011100 110011 000100 110011

    然后计算机是8位8位的存数 6不够，自动就补两个高位0了
    所有有了 高位补0

    科学计算器输入 00011100 00110011 00000100 00110011

    得到 28 51 4 51
    查对下照表 c z E z
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;关于这个编码的规则：
①.把3个字符变成4个字符。
②.每76个字符加一个换行符。
③.最后的结束符也要处理。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;编码的过程是这样的&quot;&gt;&lt;a href=&quot;#编码的过程是这样的&quot; class=&quot;headerlink&quot; title=&quot;编码的过程是这样的&quot;&gt;&lt;/a&gt;编码的过程是这样的&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 第一个字符通过右移2位获得第一个目标字符的Base64表位置，根据这个数值取到表上相应的字符，就是第一个目标字符。

2. 然后将第一个字符与0x03(00000011)进行与(&amp;amp;)操作并左移4位,接着第二个字符右移4位与前者相或(|)，即获得第二个目标字符。

3. 再将第二个字符与0x0f(00001111)进行与(&amp;amp;)操作并左移2位,接着第三个字符右移6位与前者相或(|)，获得第三个目标字符。

4. 最后将第三个字符与0x3f(00111111)进行与(&amp;amp;)操作即获得第四个目标字符。

5. 在以上的每一个步骤之后，再把结果与 0x3F 进行 AND 位操作，就可以得到编码后的字符了。

 可是等等……聪明的你可能会问到，原文的字节数量应该是3的倍数啊，如果这个条件不能满足的话，那该怎么办呢？

我们的解决办法是这样的：原文剩余的字节根据编码规则继续单独转(1变2,2变3;不够的位数用0补全)，
再用=号补满4个字节。这就是为什么有些Base64编码会以一个或两个等号结束的原因，但等号最多只有两个。

 因为：
  一个原字节至少会变成两个目标字节

所以余数任何情况下都只可能是0，1，2这三个数中的一个。如果余数是0的话，就表示原文字节数正好是3的倍数（最理想的情况）。
如果是1的话，转成2个Base64编码字符，为了让Base64编码是4的倍数，就要补2个等号；同理，如果是2的话，就要补1个等号。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;MIME格式&quot;&gt;&lt;a href=&quot;#MIME格式&quot; class=&quot;headerlink&quot; title=&quot;MIME格式&quot;&gt;&lt;/a&gt;MIME格式&lt;/h3&gt;&lt;p&gt; 在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，&lt;strong&gt;等号“=”&lt;/strong&gt;用来作为后缀用途。&lt;/p&gt;
&lt;p&gt; 完整的base64定义可见 RFC1421和 RFC2045。编码后的数据比原始数据略长，为原来的4/3。在电子邮件中，根据RFC822规定，&lt;strong&gt;每76个字符，还需要加上一个回车换行&lt;/strong&gt;。可以估算编码后数据长度大约为&lt;strong&gt;原长的135.1%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的Bit用0补足。然后，每次取出6个bit，按照其值选择 &lt;em&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&lt;/em&gt;    中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。&lt;/p&gt;
&lt;p&gt; 如果最后&lt;em&gt;剩下两个输入数据&lt;/em&gt;，在编码结果后&lt;em&gt;加&lt;strong&gt;1个&lt;/strong&gt;“=”&lt;/em&gt;；如果最后&lt;em&gt;剩下一个输入数据&lt;/em&gt;，编码结果后&lt;em&gt;加&lt;strong&gt;2个&lt;/strong&gt;“=”&lt;/em&gt;；如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>导入头文件的几种方式</title>
    <link href="http://yoursite.com/2016/04/27/%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/04/27/导入头文件的几种方式/</id>
    <published>2016-04-27T12:05:41.000Z</published>
    <updated>2016-04-27T12:34:01.000Z</updated>
    
    <content type="html">&lt;p&gt;导入头文件的方式有一下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. #include &amp;lt; &amp;gt;
2. #include &amp;quot; &amp;quot;
3. #import &amp;lt; &amp;gt;
4. #import &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; #import 相对 #include 可以先检查文件中是否已经引入头文件，如果已经引入则不再引入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt; &amp;gt; 引用的是编译器的类库里面头文件
&amp;quot; &amp;quot; 引用的是你程序目录的相对路径中的头文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  如果使用””，它是会先在你项目的当前目录查找是否有对应头文件&lt;br&gt;  如果没有，它还是会在对应的引用目录里面查找对应的头文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果遇到已经导入 文件夹 但是代码显示找不到那个文件夹里面的文件，可以&lt;br&gt; 在 Build Settings -&amp;gt; Search Paths -&amp;gt; Header Search Paths 添加相对路径（添加之后会显示绝对路径 $(PROJECT_DIR)/Tools/Alipay）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Create-groups-与-Create-folder-references-的区别&quot;&gt;&lt;a href=&quot;#Create-groups-与-Create-folder-references-的区别&quot; class=&quot;headerlink&quot; title=&quot;Create groups 与 Create folder references 的区别&quot;&gt;&lt;/a&gt;Create groups 与 Create folder references 的区别&lt;/h4&gt;&lt;p&gt; 1.使用Create groups ，为任何新增加的文件夹创建组，组的概念也许我们并不陌生，我们在项目中完全可以手动添加一个groups（右键点击选择New Group），但是手动添加的groups实际上并不会存在于项目的目录中，你会发现被添加进groups中的文件仍在位于它原来所在的位置，但是从外部引入进来的groups并不会如此，正如我们刚才那样。groups一旦被创建或添加，都是以黄色文件夹的形式存在的，当你想要使用文件夹中的某个类的头文件时，你可以直接添加它的引用，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include xxx.h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 因为groups下的cpp文件是会被编译的。&lt;/p&gt;
&lt;p&gt; 2.使用Create folder references方法只是将文件单纯的创建了引用，这些文件不会被编译，所以在使用的时候需要加入其路径，比如在我们想要使用上图中的myScripts文件夹下面有某个头文件，则需要按照下面的方法添加声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include myScripts/xxx.h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 否则编译器就会告诉你找不到xxx.h文件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;导入头文件的方式有一下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. #include &amp;lt; &amp;gt;
2. #include &amp;quot; &amp;quot;
3. #import &amp;lt; &amp;gt;
4. #import &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>OC的三大特性</title>
    <link href="http://yoursite.com/2016/04/24/OC%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/04/24/OC的三大特性/</id>
    <published>2016-04-24T14:38:11.000Z</published>
    <updated>2016-04-24T14:44:56.000Z</updated>
    
    <content type="html">&lt;p&gt; OC中类的三大特性：继承，封装，多态&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;OC中是有四种访问权限修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@public、@protected、@private、@package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中默认的修饰符是@private&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;但是这里要注意的是：OC中的方法是没有修饰符的概念的，这个和Java有很大的区别，一般都是公开访问的，即public的，但是我们怎么做到让OC中的一个方法不能被外界访问呢？&lt;/p&gt;
&lt;p&gt;OC中是这么做的，如果想让一个方法不被外界访问的话，只需要在.m文件中实现这个方法，不要在头文件中进行定义，说白了就是：该方法有实现，没定义，这样外界在导入头文件的时候，是没有这个方法的，但是这个方法我们可以在自己的.m文件中进行使用。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;继承是类中的一个重要的特性，他的出现使得我们没必要别写重复的代码，可重用性很高&lt;/p&gt;
&lt;p&gt;可以使用 super 关键字来调用父类的方法，同时这里我们也是可以用 self 关键字来调用，这里看到其实这两种方式调用的效果是一样的，当我们在子类重新实现 brake 方法的时候(Java中的重写概念)，那么这时候 super 关键字调用的还是父类的方法，而 self 调用的就是重写之后的 brake 方法了。&lt;/p&gt;
&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;p&gt;定义类型和实际类型，一般是基于接口的形式实现的。&lt;/p&gt;
&lt;p&gt;下面就来详细讲解一下多态的好处&lt;br&gt;上面的例子是一个彩色打印机和黑白打印机这两种打印机，然后Person类中有一个操作打印的方法，当然这个方法是需要打印机对象的，如果不用多态机制实现的话(Person.h中注释的代码部分)，就是给两种打印机单独定义个操作的方法，然后在Person.m(代码中注释的部分)中用具体的打印机对象进行操作，在main.m文件中，我们看到，当Person需要使用哪个打印机的时候，就去调用指定的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[person printWithBlack:blackPrint];//调用黑白打印机  
[person printWithColor:colorPrint];//调用彩色打印机  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种设计就不好了，为什么呢？假如现在又有一种打印机，那么我们还需要在 Person.h 中定义一种操作这种打印机的方法，那么后续如果在添加新的打印机呢？还在添加方法吗？那么 Person.h 文件就会变得很臃肿。所以这时候多态就体现到好处了，使用父类类型，在 Person.h 中定义一个方法就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void) doPrint:(Printer *)printer;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里看到了，这个方法的参数类型就是父类的类型，这就是多态，定义类型为父类类型，实际类型为子类类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void) doPrint:(Printer *)printer{  
  [printer print];  
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里调用print方法，就是传递进来的实际类型的print方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printer *p1 = [[ColorPrinter alloc] init];  
Printer *p2 = [[BlackPrinter alloc] init];  

[person doPrint:p1];  
[person doPrint:p2];  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的p1,p2表面上的类型是Printer，但是实际类型是子类类型，所以会调用他们自己对应的print方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; OC中类的三大特性：继承，封装，多态&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;OC中是有四种访问权限修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@public、@protected、@private、@package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中默认的修饰符是@private&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件的处理－见识filemanager的强大</title>
    <link href="http://yoursite.com/2016/04/22/%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8D%E8%A7%81%E8%AF%86filemanager%E7%9A%84%E5%BC%BA%E5%A4%A7/"/>
    <id>http://yoursite.com/2016/04/22/文件的处理－见识filemanager的强大/</id>
    <published>2016-04-22T14:29:05.000Z</published>
    <updated>2016-04-22T14:29:35.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;获取-Documents-目录文件&quot;&gt;&lt;a href=&quot;#获取-Documents-目录文件&quot; class=&quot;headerlink&quot; title=&quot;获取 Documents 目录文件&quot;&gt;&lt;/a&gt;获取 Documents 目录文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Library-目录路径&quot;&gt;&lt;a href=&quot;#获取-Library-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Library 目录路径&quot;&gt;&lt;/a&gt;获取 Library 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString *libraryDirectofry = [paths2 lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Tmp-目录路径&quot;&gt;&lt;a href=&quot;#获取-Tmp-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Tmp 目录路径&quot;&gt;&lt;/a&gt;获取 Tmp 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *tmpDirectory = NSTemporaryDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件夹&quot;&gt;&lt;a href=&quot;#创建文件夹&quot; class=&quot;headerlink&quot; title=&quot;创建文件夹&quot;&gt;&lt;/a&gt;创建文件夹&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *testDirectory = [documentsDirectory stringByAppendingString:@&amp;quot;test&amp;quot;];
BOOL res = [fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil];   
if (res) {

    NSLog(@&amp;quot;创建文件夹成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件夹失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件&quot;&gt;&lt;a href=&quot;#创建文件&quot; class=&quot;headerlink&quot; title=&quot;创建文件&quot;&gt;&lt;/a&gt;创建文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
NSString *testPath = [testDirectory stringByAppendingPathComponent:@&amp;quot;test.txt&amp;quot;];
BOOL res2 = [fileManager createFileAtPath:testPath contents:data attributes:nil]; 
if (res2) {

    NSLog(@&amp;quot;创建文件成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;测试写入内容&quot;&gt;&lt;a href=&quot;#测试写入内容&quot; class=&quot;headerlink&quot; title=&quot;测试写入内容&quot;&gt;&lt;/a&gt;测试写入内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content = @&amp;quot;测试写入内容&amp;quot;;
BOOL res3 = [content writeToFile:testPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; 
if (res3) {

    NSLog(@&amp;quot;文件写入成功&amp;quot;);
} else {

    NSLog(@&amp;quot;文件写入失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;读取文件内容&quot;&gt;&lt;a href=&quot;#读取文件内容&quot; class=&quot;headerlink&quot; title=&quot;读取文件内容&quot;&gt;&lt;/a&gt;读取文件内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content2 = [NSString stringWithContentsOfFile:testPath encoding:NSUTF8StringEncoding error:nil]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取文件属性&quot;&gt;&lt;a href=&quot;#获取文件属性&quot; class=&quot;headerlink&quot; title=&quot;获取文件属性&quot;&gt;&lt;/a&gt;获取文件属性&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:testPath error:nil]; 
for (int i = 0; i &amp;lt; [[fileAttributes allKeys] count]; i ++) {

    NSLog(@&amp;quot;key: %@, value:%@&amp;quot;, [[fileAttributes allKeys] objectAtIndex:i], [fileAttributes objectForKey:[[fileAttributes allKeys] objectAtIndex:i]]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;BOOL res4 = [fileManager removeItemAtPath:testPath error:nil]; 
if (res4) {

    NSLog(@&amp;quot;删除成功&amp;quot;);
} else {

    NSLog(@&amp;quot;删除失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>内存空间Zone的挖掘</title>
    <link href="http://yoursite.com/2016/04/22/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4Zone%E7%9A%84%E6%8C%96%E6%8E%98/"/>
    <id>http://yoursite.com/2016/04/22/内存空间Zone的挖掘/</id>
    <published>2016-04-22T14:26:34.000Z</published>
    <updated>2016-04-22T14:27:11.000Z</updated>
    
    <content type="html">&lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;所以你为什么想要去用你自己的NSZone呢？&lt;/p&gt;
&lt;p&gt;如果你大量分配数百个小对象，事实上你会发现你花费精力来为他们分配内存是有意义的。因为这种标准的（默认的）空间会被一直使用，它会变得斑驳起来；释放对象的过程会给整个内存留下令人尴尬的空隙。标准空间的分配器（allocator）也知道知道这一点，所以它尝试着优先去使用被用户释放的内存，去填补这些空隙，但是这种方式只有在空间(zone) 变得很大时才有明显效果。&lt;/p&gt;
&lt;p&gt;如果你想为大量对象分配内存，然后，你可以创建你自己的空间（zone）并且告诉它不用去为了为新对象分配内存而去查找那些空隙。分配器现在能够每次跳到内存分配的末尾为你的新对象分配内存，能起到不错的效果。&lt;/p&gt;
&lt;p&gt;另外，分配器也能为你节省时间，当分配器向操作系统请求更多内存时，分配器去查找哪块空间什么时候被填满，需要花费不少时间。一种更快的时间是一次去请求一大块内存，你也能告诉你的NSZone在这儿做什么。&lt;/p&gt;
&lt;p&gt;NSZone也能节省你释放内存的时间。它有方法释放大量分配的内存，而不打扰释放器（deallocators）。如果用一个集合（set）包含一系列对象，这样能够节省时间，你可以一次释放它们而不用去乏味地一个个释放它们。&lt;/p&gt;
&lt;p&gt;NSZone is Apple’s way of optimizing object allocation and freeing. NSZone is not an object; it is an opaque C-struct storing information about how memory should be handled for a set of objects.&lt;/p&gt;
&lt;p&gt;One rarely needs to worry about handling your own zones in applications; Cocoa handles it transparently. A default NSZone is created&amp;gt;If you are mass-allocating hundreds of cheap objects, you may find the cost of actually allocating space for them becomes significant. Because the standard zone is used all the time, it can become very patchy; deleted objects can leave awkward gaps throughout memory. The allocator for the standard NSZone knows this, and it tries to fill these gaps in preference to grabbing more memory off the system, but this can be costly in time if the zone has grown quite large.&lt;/p&gt;
&lt;p&gt;If you want to mass-allocate objects, then, you can create your own zone and tell it not to bother with finding gaps to put new objects in. The allocator can now jump to the end of its allotted memory each time and quickly assign memory to your new objects, saving a lot of effort.&lt;/p&gt;
&lt;p&gt;Allocators can save you time elsewhere, too, as asking the OS for more memory, which a zone needs to do whenever it fills up, is another costly operation if it’s done a lot. Much quicker is to ask for huge chunks of memory at a time, and you can tell your NSZone what to do here as well.&lt;/p&gt;
&lt;p&gt;Rumor has it that NSZone could save you deallocation time in the Good Old Days, too, with a method that simply chucks away all the allotted memory without bothering to call deallocators. If a set of objects is self-contained, this could save a lot of time, as you can chuck them all away at style=”font-weight:bold”&amp;gt;NSZone method (NSRecycleZone) carefully puts all the objects in a zone neatly style=”font-weight:bold”&amp;gt;NSZone. Not exactly a huge time-saver.&lt;/p&gt;
&lt;p&gt;So, in summary, zones save you time in mass allocations. &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
</feed>
