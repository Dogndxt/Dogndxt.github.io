<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-16T13:43:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>预编译指令</title>
    <link href="http://yoursite.com/2016/05/16/%E9%A2%84%E7%BC%96%E8%AF%91%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/05/16/预编译指令/</id>
    <published>2016-05-16T13:38:49.000Z</published>
    <updated>2016-05-16T13:43:13.000Z</updated>
    
    <content type="html">&lt;p&gt;常见的预处理功能&lt;/p&gt;
&lt;p&gt;预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ 文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

＊ 条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

＊ 布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

＊ 宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; 预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。可见预处理过程先于编译器对源代码进行处理。&lt;/p&gt;
&lt;p&gt; 预处理指令是以#开头的代码行，#后是指令关键字，在关键字和#号之间允许存在任意个数的空白字符。正行语句构成了一条预处理指令，该指令酱紫啊编译器进行编译之前对源代码做某些转换，下面是一些&lt;/p&gt;
&lt;h3 id=&quot;常用的预处理指令&quot;&gt;&lt;a href=&quot;#常用的预处理指令&quot; class=&quot;headerlink&quot; title=&quot;常用的预处理指令&quot;&gt;&lt;/a&gt;常用的预处理指令&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#   空指令，没有任何效果

#include 包含一个源代码文件

#define 定义宏

#undef 取消定义宏

#if 如果条件为真，则编译下面的代码

#elif 如果前面的#if不为真，则编译下面的代码

#endif 结束一个#if...#elif条件编译块

#ifdef 如果已经定义了某个宏，则编译下面的代码

#ifndef 如果没有定义某个宏，则编译下面的代码

#error 停止编译并显示错误信息

#pragma 为编译程序提供非常规的控制流信息
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 这些指令的主要目的是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。&lt;/p&gt;
&lt;h3 id=&quot;预定义标识符&quot;&gt;&lt;a href=&quot;#预定义标识符&quot; class=&quot;headerlink&quot; title=&quot;预定义标识符&quot;&gt;&lt;/a&gt;预定义标识符&lt;/h3&gt;&lt;p&gt;  为了处理一些有用的信息，预处理定义了一些预处理标识符，虽然各种编译器的预处理标识符不尽相同，但是他们都会处理下面的4种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;__FILE__ 正在编译的文件的名字
__LINE__ 正在编译的文件的行号
__DATE__ 编译时刻的日期字符串，例如： &amp;quot;25 Jan 2006&amp;quot;
__TIME__ 编译时刻的时间字符串，例如： &amp;quot;12:30:55&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;常见的预处理功能&lt;/p&gt;
&lt;p&gt;预处理器的主要作用就是把通过预处理的内建功能对一个资源进行等价替换，最常见的预处理有：文件包含，条件编译、布局控制和宏替换4种。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ 文件包含：#include 是一种最为常见的预处理，主要是做为文件的引用组合源程序正文。

＊ 条件编译：#if,#ifndef,#ifdef,#endif,#undef等也是比较常见的预处理，主要是进行编译时进行有选择的挑选，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

＊ 布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

＊ 宏替换：#define，这是最常见的用法，它可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结</title>
    <link href="http://yoursite.com/2016/05/07/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/05/07/iOS特别技能点总结/</id>
    <published>2016-05-07T11:33:38.000Z</published>
    <updated>2016-05-16T13:55:07.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;修改状态栏颜色&quot;&gt;&lt;a href=&quot;#修改状态栏颜色&quot; class=&quot;headerlink&quot; title=&quot;修改状态栏颜色&quot;&gt;&lt;/a&gt;修改状态栏颜色&lt;/h3&gt;&lt;p&gt;1.在 info.plist 添加 View controller-based status bar appearance 并设置为 NO（白色），YES（黑色）， 如果为NO，并在 Appdelegate 里面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
则可设置为白色。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.在有 navigationbar 的时候需要 添加方法 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UIStatusBarStyle)preferredStatusBarStyle {

return UIStatusBarStyleLightContent;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且在 viewDidload 中添加：self.navigationController.navigationBar.barStyle = UIBarStyleBlack;&lt;/p&gt;
&lt;p&gt;这样可以设置为白色&lt;/p&gt;
&lt;h3 id=&quot;修改-Bar-Button-Item-的颜色&quot;&gt;&lt;a href=&quot;#修改-Bar-Button-Item-的颜色&quot; class=&quot;headerlink&quot; title=&quot;修改 Bar Button Item 的颜色&quot;&gt;&lt;/a&gt;修改 Bar Button Item 的颜色&lt;/h3&gt;&lt;p&gt;如果要修改 Right Bar Button Items 的颜色，需要在 Bar Button Item 里面修改它的 Tint 的颜色。因为自定义右按钮Right Bar Button Items 有两个图层：Bar Button Item 和 View。&lt;/p&gt;
&lt;h3 id=&quot;警告：Plain-style-unsupported-in-a-Navigation-item&quot;&gt;&lt;a href=&quot;#警告：Plain-style-unsupported-in-a-Navigation-item&quot; class=&quot;headerlink&quot; title=&quot;警告：Plain style unsupported in a Navigation item&quot;&gt;&lt;/a&gt;警告：Plain style unsupported in a Navigation item&lt;/h3&gt;&lt;p&gt; 解决方法： 将 plain 设置成：Bordered 。&lt;/p&gt;
&lt;h3 id=&quot;怎样设置UITableView的cell之间的距离&quot;&gt;&lt;a href=&quot;#怎样设置UITableView的cell之间的距离&quot; class=&quot;headerlink&quot; title=&quot;怎样设置UITableView的cell之间的距离?&quot;&gt;&lt;/a&gt;怎样设置UITableView的cell之间的距离?&lt;/h3&gt;&lt;p&gt;分为两种情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 分组表格    - 每段一个cell设置表头的高度 
2. 非分组表格  - 将tableViewCell的背景色，contentView的背景色设置为透明，在contentView中添加一个UIImageView做为背景，使UIImageView的高度小于cell的高度，这样创建出的tableView就可以使每个cell之间看起来有一定间隔。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;performSegueWithIdentifier-produce-no-segue-with-identifier-error&quot;&gt;&lt;a href=&quot;#performSegueWithIdentifier-produce-no-segue-with-identifier-error&quot; class=&quot;headerlink&quot; title=&quot;performSegueWithIdentifier produce no segue with identifier error&quot;&gt;&lt;/a&gt;performSegueWithIdentifier produce no segue with identifier error&lt;/h3&gt;&lt;p&gt;   解决方法：先检查要跳转的界面和目的界面的表格的协议（delegate和datasource）是否有代理。然后检查是否给控制器添加了类。&lt;/p&gt;
&lt;p&gt;1.在 ios 中如果遇到添加的图片没有显示出来，可以先检查图片的名称是否正确，&lt;br&gt; 然后检查图片的格式是否是 PNG 格式，最后检查是否已经添加到工程当中了。&lt;/p&gt;
&lt;p&gt;2.在tableView 中 cell 的跳转，需要使用控制器间的跳转。 &lt;/p&gt;
&lt;p&gt;3.异常：Terminating app due to uncaught exception ‘NSInvalidArgumentException’, reason: ‘&lt;em&gt;*&lt;/em&gt; -[UIViewController tableView:numberOfRowsInSection:]: unrecognized selector sent to instance 0x3b02120’&lt;/p&gt;
&lt;p&gt;   解决方法：检测视图控制器是否绑定了具体的类。&lt;/p&gt;
&lt;p&gt;4.this class is not key value coding-compliant for the key XXX错误的解决方法&lt;/p&gt;
&lt;p&gt;   解决方法：在设置IBAction和IBOutlet时有多余的连线，按下ctrl键检查控件的连接将多余的连续删除后程序正常运行。&lt;/p&gt;
&lt;p&gt;5.this class is not key value coding-compliant for the key leftTitle.&lt;/p&gt;
&lt;p&gt;   解决方法： 因为sb 或者 xib 中的控件链接的属性有些没有出现在页面绑定的控制器上，造成引用上的健值错误。&lt;/p&gt;
&lt;p&gt;6.OC之OBJC2_UNAVAILABLE&lt;/p&gt;
&lt;p&gt;  意即在OBJC2.0中，这些东西将被删除。&lt;/p&gt;
&lt;h3 id=&quot;去除-tableView-的-sectionView-的粘性&quot;&gt;&lt;a href=&quot;#去除-tableView-的-sectionView-的粘性&quot; class=&quot;headerlink&quot; title=&quot;去除 tableView 的 sectionView 的粘性&quot;&gt;&lt;/a&gt;去除 tableView 的 sectionView 的粘性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)scrollViewDidScroll:(UIScrollView *)scrollView {

   CGFloat sectionHeaderHeight = 45;
   if (scrollView.contentOffset.y &amp;lt;= sectionHeaderHeight&amp;amp;&amp;amp;scrollView.contentOffset.y &amp;gt;= 0) {

       scrollView.contentInset = UIEdgeInsetsMake(-scrollView.contentOffset.y, 0, 0, 0);
   }
   else if (scrollView.contentOffset.y &amp;gt;= sectionHeaderHeight) {

       scrollView.contentInset = UIEdgeInsetsMake(-sectionHeaderHeight, 0, 0, 0);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;修改-textField-的-placeholder-的字体颜色，大小&quot;&gt;&lt;a href=&quot;#修改-textField-的-placeholder-的字体颜色，大小&quot; class=&quot;headerlink&quot; title=&quot;修改 textField 的 placeholder 的字体颜色，大小&quot;&gt;&lt;/a&gt;修改 textField 的 placeholder 的字体颜色，大小&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[textField setValue:[UIColor redColor] forKeyPath:@&amp;quot;_placeholderLabel.textColor&amp;quot;];  

[textField setValue:[UIFont boldSystemFontOfSize:16] forKeyPath:@&amp;quot;_placeholderLabel.font&amp;quot;]; 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;修改状态栏颜色&quot;&gt;&lt;a href=&quot;#修改状态栏颜色&quot; class=&quot;headerlink&quot; title=&quot;修改状态栏颜色&quot;&gt;&lt;/a&gt;修改状态栏颜色&lt;/h3&gt;&lt;p&gt;1.在 info.plist 添加 View controller-based status bar appearance 并设置为 NO（白色），YES（黑色）， 如果为NO，并在 Appdelegate 里面添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleLightContent;
则可设置为白色。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习（三）</title>
    <link href="http://yoursite.com/2016/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/05/深度学习（三）/</id>
    <published>2016-05-05T13:11:48.000Z</published>
    <updated>2016-05-05T13:23:44.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;关于特征&quot;&gt;&lt;a href=&quot;#关于特征&quot; class=&quot;headerlink&quot; title=&quot;关于特征&quot;&gt;&lt;/a&gt;关于特征&lt;/h3&gt;&lt;h4 id=&quot;4-1、特征表示的粒度&quot;&gt;&lt;a href=&quot;#4-1、特征表示的粒度&quot; class=&quot;headerlink&quot; title=&quot;4.1、特征表示的粒度&quot;&gt;&lt;/a&gt;4.1、特征表示的粒度&lt;/h4&gt;&lt;p&gt;学习算法在一个什么粒度上的特征表示，才有能发挥作用？就一个图片来说，像素级的特征根本没有价值。例如下面的摩托车，从像素级别，根本得不到任何信息，其无法进行摩托车和非摩托车的区分。而如果特征是一个具有结构性（或者说有含义）的时候，比如是否具有车把手（handle），是否具有车轮（wheel），就很容易把摩托车和非摩托车区分，学习算法才能发挥作用。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;4-2、初级（浅层）特征表示&quot;&gt;&lt;a href=&quot;#4-2、初级（浅层）特征表示&quot; class=&quot;headerlink&quot; title=&quot;4.2、初级（浅层）特征表示&quot;&gt;&lt;/a&gt;4.2、初级（浅层）特征表示&lt;/h4&gt;&lt;p&gt;1995 年前后，Bruno Olshausen和 David Field 两位学者任职 Cornell University，他们试图同时用生理学和计算机的手段，双管齐下，研究视觉问题。&lt;br&gt;他们收集了很多黑白风景照片，从这些照片中，提取出400个小碎片，每个照片碎片的尺寸均为 16x16 像素，不妨把这400个碎片标记为 S[i], i = 0,.. 399。接下来，再从这些黑白风景照片中，随机提取另一个碎片，尺寸也是 16x16 像素，不妨把这个碎片标记为 T。&lt;br&gt;他们提出的问题是，如何从这400个碎片中，选取一组碎片，S[k], 通过叠加的办法，合成出一个新的碎片，而这个新的碎片，应当与随机选择的目标碎片 T，尽可能相似，同时，S[k] 的数量尽可能少。用数学的语言来描述，就是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Sum_k (a[k] * S[k]) --&amp;gt; T, 其中 a[k] 是在叠加碎片 S[k] 时的权重系数。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为解决这个问题，Bruno Olshausen和 David Field 发明了一个算法，稀疏编码（Sparse Coding）。&lt;br&gt;稀疏编码是一个重复迭代的过程，每次迭代分两步：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）选择一组 S[k]，然后调整 a[k]，使得Sum_k (a[k] * S[k]) 最接近 T。
2）固定住 a[k]，在 400 个碎片中，选择其它更合适的碎片S’[k]，替代原先的 S[k]，使得Sum_k (a[k] * S’[k]) 最接近 T。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;经过几次迭代后，最佳的 S[k] 组合，被遴选出来了。令人惊奇的是，被选中的 S[k]，基本上都是照片上不同物体的边缘线，这些线段形状相似，区别在于方向。&lt;/p&gt;
&lt;p&gt;Bruno Olshausen和 David Field 的算法结果，与 David Hubel 和Torsten Wiesel 的生理发现，不谋而合！&lt;br&gt;也就是说，复杂图形，往往由一些基本结构组成。&lt;/p&gt;
&lt;h4 id=&quot;4-3、结构性特征表示&quot;&gt;&lt;a href=&quot;#4-3、结构性特征表示&quot; class=&quot;headerlink&quot; title=&quot;4.3、结构性特征表示&quot;&gt;&lt;/a&gt;4.3、结构性特征表示&lt;/h4&gt;&lt;p&gt;小块的图形可以由基本edge构成，更结构化，更复杂的，具有概念性的图形如何表示呢？这就需要更高层次的特征表示，比如V2，V4。因此V1看像素级是像素级。V2看V1是像素级，这个是层次递进的，高层表达由底层表达的组合而成。专业点说就是基basis。V1取提出的basis是边缘，然后V2层是V1层这些basis的组合，这时候V2区得到的又是高一层的basis。即上一层的basis组合的结果，上上层又是上一层的组合basis……（所以有大牛说Deep learning就是“搞基”，因为难听，所以美其名曰Deep learning或者Unsupervised Feature Learning）&lt;/p&gt;
&lt;p&gt;直观上说，就是找到make sense的小patch再将其进行combine，就得到了上一层的feature，递归地向上learning feature。&lt;br&gt;在不同object上做training是，所得的edge basis 是非常相似的，但object parts和models 就会completely different了（那咱们分辨car或者face是不是容易多了）：&lt;/p&gt;
&lt;h4 id=&quot;4-4、需要有多少个特征？&quot;&gt;&lt;a href=&quot;#4-4、需要有多少个特征？&quot; class=&quot;headerlink&quot; title=&quot;4.4、需要有多少个特征？&quot;&gt;&lt;/a&gt;4.4、需要有多少个特征？&lt;/h4&gt;&lt;p&gt;我们知道需要层次的特征构建，由浅入深，但每一层该有多少个特征呢？&lt;br&gt;任何一种方法，特征越多，给出的参考信息就越多，准确性会得到提升。但特征多意味着计算复杂，探索的空间大，可以用来训练的数据在每个特征上就会稀疏，都会带来各种问题，并不一定特征越多越好。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关于特征&quot;&gt;&lt;a href=&quot;#关于特征&quot; class=&quot;headerlink&quot; title=&quot;关于特征&quot;&gt;&lt;/a&gt;关于特征&lt;/h3&gt;&lt;h4 id=&quot;4-1、特征表示的粒度&quot;&gt;&lt;a href=&quot;#4-1、特征表示的粒度&quot; class=&quot;headerlink&quot; title=&quot;4.1、特征表示的粒度&quot;&gt;&lt;/a&gt;4.1、特征表示的粒度&lt;/h4&gt;&lt;p&gt;学习算法在一个什么粒度上的特征表示，才有能发挥作用？就一个图片来说，像素级的特征根本没有价值。例如下面的摩托车，从像素级别，根本得不到任何信息，其无法进行摩托车和非摩托车的区分。而如果特征是一个具有结构性（或者说有含义）的时候，比如是否具有车把手（handle），是否具有车轮（wheel），就很容易把摩托车和非摩托车区分，学习算法才能发挥作用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习（二）</title>
    <link href="http://yoursite.com/2016/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/05/深度学习（二）/</id>
    <published>2016-05-05T13:03:45.000Z</published>
    <updated>2016-05-05T13:13:10.000Z</updated>
    
    <content type="html">&lt;p&gt;那它是怎么学习的呢？怎么知道哪些特征好哪些不好呢？我们说机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为的学科。&lt;/p&gt;
&lt;h3 id=&quot;人脑视觉机理&quot;&gt;&lt;a href=&quot;#人脑视觉机理&quot; class=&quot;headerlink&quot; title=&quot;人脑视觉机理&quot;&gt;&lt;/a&gt;人脑视觉机理&lt;/h3&gt;&lt;p&gt;可视皮层是分级的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 神经-中枢-大脑的工作过程，或许是一个不断迭代、不断抽象的过程&lt;/strong&gt;。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;这里的关键词有两个，一个是抽象，一个是迭代。从原始信号，做低级抽象，逐渐向高级抽象迭代。&lt;strong&gt;人类的逻辑思维，经常使用高度抽象的概念&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;总的来说，人的视觉系统的信息处理是分级的。从低级的V1区提取边缘特征，再到V2区的形状或者目标的部分等，再到更高层，整个目标、目标的行为等。也就是说高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。例如，单词集合和句子的对应是多对一的，句子和语义的对应又是多对一的，语义和意图的对应还是多对一的，这是个层级体系。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/danao.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;那它是怎么学习的呢？怎么知道哪些特征好哪些不好呢？我们说机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为的学科。&lt;/p&gt;
&lt;h3 id=&quot;人脑视觉机理&quot;&gt;&lt;a href=&quot;#人脑视觉机理&quot; class=&quot;headerlink&quot; title=&quot;人脑视觉机理&quot;&gt;&lt;/a&gt;人脑视觉机理&lt;/h3&gt;&lt;p&gt;可视皮层是分级的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 神经-中枢-大脑的工作过程，或许是一个不断迭代、不断抽象的过程&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深度学习（一）</title>
    <link href="http://yoursite.com/2016/05/05/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88%EF%BC%8D%EF%BC%89/"/>
    <id>http://yoursite.com/2016/05/05/深度学习（－）/</id>
    <published>2016-05-05T12:46:40.000Z</published>
    <updated>2016-05-05T13:37:54.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; Artificial Intelligence，也就是人工智能&lt;/strong&gt;，就像长生不老和星际漫游一样，是人类最美好的梦想之一。&lt;/p&gt;
&lt;p&gt;  图灵（图灵，大家都知道吧。计算机和人工智能的鼻祖，分别对应于其著名的“图灵机”和“图灵测试”）在 1950 年的论文里，提出图灵试验的设想，即，隔墙对话，你将不知道与你谈话的，是人还是电脑。这无疑给计算机，尤其是人工智能，预设了一个很高的期望值。但是半个世纪过去了，人工智能的进展，远远没有达到图灵试验的标准。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  但是自 2006 年以来，机器学习领域，取得了突破性的进展。图灵试验，至少不是那么可望而不可及了。至于技术手段，不仅仅依赖于云计算对大数据的并行处理能力，而且依赖于算法。这个算法就是，Deep Learning。借助于 Deep Learning 算法，人类终于找到了如何处理“抽象概念”这个亘古难题的方法。&lt;/p&gt;
&lt;p&gt;  2012年6月，《纽约时报》披露了Google Brain项目，吸引了公众的广泛关注。这个项目是由著名的斯坦福大学的机器学习教授Andrew Ng和在大规模计算机系统方面的世界顶尖专家JeffDean共同主导，用16000个CPU Core的并行计算平台训练一种称为“深度神经网络”（DNN，Deep Neural Networks）的机器学习模型（内部共有10亿个节点。人脑中有150多亿个神经元），在语音识别和图像识别等领域获得了巨大的成功。&lt;/p&gt;
&lt;h3 id=&quot;机器学习（人工智能的核心）的背景&quot;&gt;&lt;a href=&quot;#机器学习（人工智能的核心）的背景&quot; class=&quot;headerlink&quot; title=&quot;机器学习（人工智能的核心）的背景&quot;&gt;&lt;/a&gt;机器学习（人工智能的核心）的背景&lt;/h3&gt;&lt;p&gt;  &lt;strong&gt; 机器学习（Machine Learning）是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能的学科。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  目前我们通过机器学习去解决这些问题的思路都是这样的（以视觉感知为例子）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/img/sfeature.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;   从开始的通过传感器（例如CMOS）来获得数据。然后经过预处理、特征提取、特征选择，再到推理、预测或者识别。最后一个部分，也就是机器学习的部分，绝大部分的工作是在这方面做的，也存在很多的paper和研究。&lt;/p&gt;
&lt;p&gt;  而中间的三部分，概括起来就是特征表达。良好的特征表达，对最终算法的准确性起了非常关键的作用，而且系统主要的计算和测试工作都耗在这一大部分。但，这块实际中一般都是人工完成的。靠人工提取特征。&lt;br&gt;&lt;img src=&quot;/img/manmade.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  截止现在，也出现了不少NB的特征（好的特征应具有不变性（大小、尺度和旋转等）和可区分性）：例如Sift的出现，是局部图像特征描述子研究领域一项里程碑式的工作。由于SIFT对尺度、旋转以及一定视角和光照变化等图像变化都具有不变性，并且SIFT具有很强的可区分性，的确让很多问题的解决变为可能。但它也不是万能的。&lt;/p&gt;
&lt;p&gt;  然而，手工地选取特征是一件非常费力、启发式（需要专业知识）的方法，能不能选取好很大程度上靠经验和运气，而且它的调节需要大量的时间。&lt;br&gt;  既然手工选取特征不太好，那么能不能自动地学习一些特征呢？&lt;br&gt;  答案是能！&lt;br&gt;  &lt;strong&gt;Deep Learning就是用来干这个事情的，看它的一个别名UnsupervisedFeature Learning，就可以顾名思义了，Unsupervised的意思就是不要人参与特征的选取过程&lt;/strong&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt; Artificial Intelligence，也就是人工智能&lt;/strong&gt;，就像长生不老和星际漫游一样，是人类最美好的梦想之一。&lt;/p&gt;
&lt;p&gt;  图灵（图灵，大家都知道吧。计算机和人工智能的鼻祖，分别对应于其著名的“图灵机”和“图灵测试”）在 1950 年的论文里，提出图灵试验的设想，即，隔墙对话，你将不知道与你谈话的，是人还是电脑。这无疑给计算机，尤其是人工智能，预设了一个很高的期望值。但是半个世纪过去了，人工智能的进展，远远没有达到图灵试验的标准。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>单一功能原则</title>
    <link href="http://yoursite.com/2016/05/01/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2016/05/01/单一功能原则/</id>
    <published>2016-05-01T13:29:49.000Z</published>
    <updated>2016-05-01T13:34:46.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个术语由&lt;strong&gt;罗伯特·C·马丁（Robert Cecil Martin）&lt;/strong&gt;在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。&lt;/p&gt;
&lt;p&gt;马丁表述该原则是基于的《结构化分析和系统规格》一书中的内聚原则（Cohesion）上。&lt;/p&gt;
&lt;p&gt;马丁把功能（职责）定义为：“&lt;strong&gt;改变的原因&lt;/strong&gt;”，并且总结出一个类或者模块应该&lt;strong&gt;有且只有一个&lt;/strong&gt;改变的原因。&lt;/p&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;第一，报表的内容可以改变（编辑）。
第二，报表的格式可以改变（打印）。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。&lt;br&gt;单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，打印功能的代码会因此不工作，假使这两个功能存在于同一个类中的话。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。&lt;br&gt;
    
    </summary>
    
    
      <category term="［类的魔法］" scheme="http://yoursite.com/tags/%EF%BC%BB%E7%B1%BB%E7%9A%84%E9%AD%94%E6%B3%95%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>基本文件操作filehandle的用法</title>
    <link href="http://yoursite.com/2016/04/29/%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9Cfilehandle%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/29/基本文件操作filehandle的用法/</id>
    <published>2016-04-29T12:57:38.000Z</published>
    <updated>2016-04-29T13:00:52.000Z</updated>
    
    <content type="html">&lt;p&gt;利用NSFilehandle类提供的方法，允许更有效地使用文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一般而言，处理文件时都要经历以下三个步骤：

1.打开文件，并获取一个NSFileHandle对象，以便在后面的I/O操作中引用该文件

2.对打开的文件执行I/O操作（读取、写入、更新）

3.关闭文件
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; NSFileHandle用于以标准输入、标准输出、标准错误和空设置的方法。他们的格式为fileHandleWithDevice，其中Device可以是StandardInput、StandardOutput、StandardError或者NullDevice。&lt;/p&gt;
&lt;p&gt; 应该注意到，&lt;strong&gt;NSFileHandle类并没有提供创建文件的功能&lt;/strong&gt;。必须使用NSFileManager方法来创建文件。因此，方法 fileHandleForWritingAtPath：和 hfileHandleUpdatingAtPath：都假定文件已经存在，否则返回nil。对于这两个方法，文件的偏移量都设为文件的开始，所以都是在文件的开始位置开始写入（或更新模式的读取）&lt;/p&gt;
&lt;p&gt; NSFileHandle常用方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+(NSFileHandle*)fileHandleForReadingAtPath:path 打开一个文件用于读入

+(NSFileHandle*)fileHandleForWritingAtPath:path 打开一个文件用于写入

+(NSFileHandle*)fileHandleForUpdatingAtPath:path 打开一个文件用于读写

-(NSData*)availableData 从设备或者通道返回可用数据

-(NSData*)readDataToEndOfFile 读取其余的数据知道文件的末尾(最多UINT_MAX字节)

-(NSData*)readDataOfLength:(NSUInteger)bytes 从文件中读取指定字节的内容

-(void)writeData:data  将data写入文件

-(unsigned long long)offsetInFile 获取当前偏移量

-(void)seekToFileOffset:offset  设置偏移量

-(unsigned long long)seekToEndOfFile 将偏移量定位到文件的末尾

-(void)truncateFileAtOffset:offset 讲文件的长度设置为offset字节

-(void)closeFile 关闭文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法fileHandleForWritingAtPath和fileHandleForUpdatingAtPath所指定的文件必须是已经存在的，否则返回nil,另外对于这两个方法中文件的偏移量都是为文件的开始。&lt;/p&gt;
&lt;h3 id=&quot;部分代码&quot;&gt;&lt;a href=&quot;#部分代码&quot; class=&quot;headerlink&quot; title=&quot;部分代码&quot;&gt;&lt;/a&gt;部分代码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSFileHandle *inFile, *outFile;
NSData *buffer;

//文件 1
NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
[[NSFileManager defaultManager] createFileAtPath:@&amp;quot;test.txt&amp;quot; contents:data attributes:nil];

//文件2
NSData *data2 = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/123&amp;quot;];
[[NSFileManager defaultManager] createFileAtPath:@&amp;quot;out.txt&amp;quot; contents:data2 attributes:nil];

// 打开test.txt文件用于读取操作
inFile = [NSFileHandle fileHandleForReadingAtPath:@&amp;quot;test.txt&amp;quot;];

// 打开test.txt文件用于写操作
outFile = [NSFileHandle fileHandleForWritingAtPath: @&amp;quot;out.txt&amp;quot;];
outFile = [NSFileHandle fileHandleForUpdatingAtPath:@&amp;quot;out.txt&amp;quot;];

// 读取数据
buffer = [inFile readDataToEndOfFile];
buffer = [inFile readDataOfLength:60];

// 写入数据
[outFile writeData:buffer];

//获取当前文件的偏移量
long long offset =  [outFile offsetInFile];
NSLog(@&amp;quot;offset = %lld&amp;quot;, offset);


//设置当前文件的偏移量
[inFile seekToFileOffset:100];

if(inFile == nil)
{
    NSLog(@&amp;quot;Open of testfile.txt for reading failed!&amp;quot;);
    return 1;
} else {

    buffer = [inFile readDataToEndOfFile];
    NSLog(@&amp;quot;%@&amp;quot;, buffer);
}

//关闭两个文件
[inFile closeFile];
[outFile closeFile];

NSLog(@&amp;quot;%@&amp;quot;, [NSString stringWithContentsOfFile:@&amp;quot;out.txt&amp;quot; encoding:NSUTF8StringEncoding error:nil]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;利用NSFilehandle类提供的方法，允许更有效地使用文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;一般而言，处理文件时都要经历以下三个步骤：

1.打开文件，并获取一个NSFileHandle对象，以便在后面的I/O操作中引用该文件

2.对打开的文件执行I/O操作（读取、写入、更新）

3.关闭文件
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://yoursite.com/2016/04/27/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/04/27/位运算/</id>
    <published>2016-04-27T12:21:31.000Z</published>
    <updated>2016-04-27T12:25:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;头文件中的特别标记&quot;&gt;&lt;a href=&quot;#头文件中的特别标记&quot; class=&quot;headerlink&quot; title=&quot;头文件中的特别标记&quot;&gt;&lt;/a&gt;头文件中的特别标记&lt;/h3&gt;&lt;p&gt;0UL 表示 无符号长整型 0&lt;br&gt;1UL 表示 无符号长整型 1&lt;/p&gt;
&lt;p&gt; 如果不写UL后缀，系统默认为：int, 即，有符号整数。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt; 1.数值常数有：整型常数、浮点常数；&lt;br&gt; 2.只有数值常数才有后缀说明；&lt;br&gt; 3.数值常数后缀不区分字母大小写。&lt;/p&gt;
&lt;p&gt;（1）整型常数的表示形式有：十进制形式、以0开头的八进制形式、以0x开头的十六进制形式，无二进制形式。&lt;br&gt;    整型常数默认是signed int的。&lt;br&gt;    对整型常数进行类型转换的后缀只有：u或U（unsigned）、l或L（long）、u/U与l/L的组合（如：ul、lu、Lu等）。例：100u; -123u; 0x123l;&lt;/p&gt;
&lt;p&gt;（2）浮点常数的表示形式有：科学计数形式和小数点形式。&lt;br&gt;    浮点常数默认是double的。&lt;br&gt;    对浮点常数进行类型转换的后缀只有：f或F（单精度浮点数）、l或L（长双精度浮点数）。（注：因浮点型常数总是有符号的，故没有u或U后缀）。例：1.23e5f; 1.23l; -123.45f;&lt;/p&gt;
&lt;h3 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h3&gt;&lt;p&gt;  在许多计算机编程语言（例如：C语言、C++语言、Java语言、JavaScript语言、Pascal语言等）中，“&amp;gt;&amp;gt;”代表右移运算符，就相当于“shr”。该运算符为双目运算符，结合方向为从左到右，作用是把一个整型数的所有位向右移动指定的位数，移动到右边界之外的多余二进制位会被丢弃，并从左边界移入0。&lt;/p&gt;
&lt;p&gt;  右移运算的两个操作数应为整数类型。第一个操作数是要进行移位操作的数，第二个操作数指定第一个操作数移动的位数。如果第二个操作数等于0则不发生任何移位。&lt;/p&gt;
&lt;p&gt;应用举例：&lt;br&gt;        问：&lt;strong&gt;计算表达式14 &amp;gt;&amp;gt; 2的值&lt;/strong&gt;。&lt;br&gt;        答：表达式14 &amp;gt;&amp;gt; 2的值为3，因为14（即二进制的00001110）向右移两位等于3（即二进制的00000011）。&lt;/p&gt;
&lt;p&gt;  说白了，就是把要移动的数转换成2进制，右移几位就去掉右边的几位数，左移几位就在右边加几个0，比如14右移2位就是转成二进制变成1110，去掉右边的10，变成11，11转成十进制就是3；左移2位就是111000，转成十进制就是56。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;位运算可以确保枚举值组合的唯一性. 因为位运算的计算方式是将二进制转换成十进制,&lt;br&gt;也就是说,枚举值里面存取的是 计算后的十进制值. &lt;/p&gt;
&lt;p&gt;打个比方: 通过上面的位运算方式设定好枚举以后,打印出来的枚举值分别是: 1 2 4 8 16 这5个数字,无论&lt;strong&gt;你如何组合在一起,也不会产生两个同样的数字&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;头文件中的特别标记&quot;&gt;&lt;a href=&quot;#头文件中的特别标记&quot; class=&quot;headerlink&quot; title=&quot;头文件中的特别标记&quot;&gt;&lt;/a&gt;头文件中的特别标记&lt;/h3&gt;&lt;p&gt;0UL 表示 无符号长整型 0&lt;br&gt;1UL 表示 无符号长整型 1&lt;/p&gt;
&lt;p&gt; 如果不写UL后缀，系统默认为：int, 即，有符号整数。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>字符串加密之Base64</title>
    <link href="http://yoursite.com/2016/04/27/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8A%A0%E5%AF%86%E4%B9%8BBase64/"/>
    <id>http://yoursite.com/2016/04/27/字符串加密之Base64/</id>
    <published>2016-04-27T12:18:00.000Z</published>
    <updated>2016-04-27T12:31:36.000Z</updated>
    
    <content type="html">&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;转码过程例子：

    3*8=4*6
    内存1个字符占8位

    转前： s 1 3

    先转成ascii：对应 115 49 51

    2进制： 01110011 00110001 00110011

    6个一组（4组） 011100110011000100110011

    然后才有后面的 011100 110011 000100 110011

    然后计算机是8位8位的存数 6不够，自动就补两个高位0了
    所有有了 高位补0

    科学计算器输入 00011100 00110011 00000100 00110011

    得到 28 51 4 51
    查对下照表 c z E z
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;关于这个编码的规则：
①.把3个字符变成4个字符。
②.每76个字符加一个换行符。
③.最后的结束符也要处理。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;编码的过程是这样的&quot;&gt;&lt;a href=&quot;#编码的过程是这样的&quot; class=&quot;headerlink&quot; title=&quot;编码的过程是这样的&quot;&gt;&lt;/a&gt;编码的过程是这样的&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 第一个字符通过右移2位获得第一个目标字符的Base64表位置，根据这个数值取到表上相应的字符，就是第一个目标字符。

2. 然后将第一个字符与0x03(00000011)进行与(&amp;amp;)操作并左移4位,接着第二个字符右移4位与前者相或(|)，即获得第二个目标字符。

3. 再将第二个字符与0x0f(00001111)进行与(&amp;amp;)操作并左移2位,接着第三个字符右移6位与前者相或(|)，获得第三个目标字符。

4. 最后将第三个字符与0x3f(00111111)进行与(&amp;amp;)操作即获得第四个目标字符。

5. 在以上的每一个步骤之后，再把结果与 0x3F 进行 AND 位操作，就可以得到编码后的字符了。

 可是等等……聪明的你可能会问到，原文的字节数量应该是3的倍数啊，如果这个条件不能满足的话，那该怎么办呢？

我们的解决办法是这样的：原文剩余的字节根据编码规则继续单独转(1变2,2变3;不够的位数用0补全)，
再用=号补满4个字节。这就是为什么有些Base64编码会以一个或两个等号结束的原因，但等号最多只有两个。

 因为：
  一个原字节至少会变成两个目标字节

所以余数任何情况下都只可能是0，1，2这三个数中的一个。如果余数是0的话，就表示原文字节数正好是3的倍数（最理想的情况）。
如果是1的话，转成2个Base64编码字符，为了让Base64编码是4的倍数，就要补2个等号；同理，如果是2的话，就要补1个等号。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;MIME格式&quot;&gt;&lt;a href=&quot;#MIME格式&quot; class=&quot;headerlink&quot; title=&quot;MIME格式&quot;&gt;&lt;/a&gt;MIME格式&lt;/h3&gt;&lt;p&gt; 在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，&lt;strong&gt;等号“=”&lt;/strong&gt;用来作为后缀用途。&lt;/p&gt;
&lt;p&gt; 完整的base64定义可见 RFC1421和 RFC2045。编码后的数据比原始数据略长，为原来的4/3。在电子邮件中，根据RFC822规定，&lt;strong&gt;每76个字符，还需要加上一个回车换行&lt;/strong&gt;。可以估算编码后数据长度大约为&lt;strong&gt;原长的135.1%&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。数据不足3byte的话，于缓冲区中剩下的Bit用0补足。然后，每次取出6个bit，按照其值选择 &lt;em&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&lt;/em&gt;    中的字符作为编码后的输出。不断进行，直到全部输入数据转换完成。&lt;/p&gt;
&lt;p&gt; 如果最后&lt;em&gt;剩下两个输入数据&lt;/em&gt;，在编码结果后&lt;em&gt;加&lt;strong&gt;1个&lt;/strong&gt;“=”&lt;/em&gt;；如果最后&lt;em&gt;剩下一个输入数据&lt;/em&gt;，编码结果后&lt;em&gt;加&lt;strong&gt;2个&lt;/strong&gt;“=”&lt;/em&gt;；如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>导入头文件的几种方式</title>
    <link href="http://yoursite.com/2016/04/27/%E5%AF%BC%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/04/27/导入头文件的几种方式/</id>
    <published>2016-04-27T12:05:41.000Z</published>
    <updated>2016-04-27T12:34:01.000Z</updated>
    
    <content type="html">&lt;p&gt;导入头文件的方式有一下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. #include &amp;lt; &amp;gt;
2. #include &amp;quot; &amp;quot;
3. #import &amp;lt; &amp;gt;
4. #import &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; #import 相对 #include 可以先检查文件中是否已经引入头文件，如果已经引入则不再引入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt; &amp;gt; 引用的是编译器的类库里面头文件
&amp;quot; &amp;quot; 引用的是你程序目录的相对路径中的头文件
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  如果使用””，它是会先在你项目的当前目录查找是否有对应头文件&lt;br&gt;  如果没有，它还是会在对应的引用目录里面查找对应的头文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果遇到已经导入 文件夹 但是代码显示找不到那个文件夹里面的文件，可以&lt;br&gt; 在 Build Settings -&amp;gt; Search Paths -&amp;gt; Header Search Paths 添加相对路径（添加之后会显示绝对路径 $(PROJECT_DIR)/Tools/Alipay）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Create-groups-与-Create-folder-references-的区别&quot;&gt;&lt;a href=&quot;#Create-groups-与-Create-folder-references-的区别&quot; class=&quot;headerlink&quot; title=&quot;Create groups 与 Create folder references 的区别&quot;&gt;&lt;/a&gt;Create groups 与 Create folder references 的区别&lt;/h4&gt;&lt;p&gt; 1.使用Create groups ，为任何新增加的文件夹创建组，组的概念也许我们并不陌生，我们在项目中完全可以手动添加一个groups（右键点击选择New Group），但是手动添加的groups实际上并不会存在于项目的目录中，你会发现被添加进groups中的文件仍在位于它原来所在的位置，但是从外部引入进来的groups并不会如此，正如我们刚才那样。groups一旦被创建或添加，都是以黄色文件夹的形式存在的，当你想要使用文件夹中的某个类的头文件时，你可以直接添加它的引用，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include xxx.h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 因为groups下的cpp文件是会被编译的。&lt;/p&gt;
&lt;p&gt; 2.使用Create folder references方法只是将文件单纯的创建了引用，这些文件不会被编译，所以在使用的时候需要加入其路径，比如在我们想要使用上图中的myScripts文件夹下面有某个头文件，则需要按照下面的方法添加声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include myScripts/xxx.h
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 否则编译器就会告诉你找不到xxx.h文件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;导入头文件的方式有一下几种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. #include &amp;lt; &amp;gt;
2. #include &amp;quot; &amp;quot;
3. #import &amp;lt; &amp;gt;
4. #import &amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>OC的三大特性</title>
    <link href="http://yoursite.com/2016/04/24/OC%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2016/04/24/OC的三大特性/</id>
    <published>2016-04-24T14:38:11.000Z</published>
    <updated>2016-04-24T14:44:56.000Z</updated>
    
    <content type="html">&lt;p&gt; OC中类的三大特性：继承，封装，多态&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;OC中是有四种访问权限修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@public、@protected、@private、@package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中默认的修饰符是@private&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;但是这里要注意的是：OC中的方法是没有修饰符的概念的，这个和Java有很大的区别，一般都是公开访问的，即public的，但是我们怎么做到让OC中的一个方法不能被外界访问呢？&lt;/p&gt;
&lt;p&gt;OC中是这么做的，如果想让一个方法不被外界访问的话，只需要在.m文件中实现这个方法，不要在头文件中进行定义，说白了就是：该方法有实现，没定义，这样外界在导入头文件的时候，是没有这个方法的，但是这个方法我们可以在自己的.m文件中进行使用。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h3&gt;&lt;p&gt;继承是类中的一个重要的特性，他的出现使得我们没必要别写重复的代码，可重用性很高&lt;/p&gt;
&lt;p&gt;可以使用 super 关键字来调用父类的方法，同时这里我们也是可以用 self 关键字来调用，这里看到其实这两种方式调用的效果是一样的，当我们在子类重新实现 brake 方法的时候(Java中的重写概念)，那么这时候 super 关键字调用的还是父类的方法，而 self 调用的就是重写之后的 brake 方法了。&lt;/p&gt;
&lt;h3 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h3&gt;&lt;p&gt;定义类型和实际类型，一般是基于接口的形式实现的。&lt;/p&gt;
&lt;p&gt;下面就来详细讲解一下多态的好处&lt;br&gt;上面的例子是一个彩色打印机和黑白打印机这两种打印机，然后Person类中有一个操作打印的方法，当然这个方法是需要打印机对象的，如果不用多态机制实现的话(Person.h中注释的代码部分)，就是给两种打印机单独定义个操作的方法，然后在Person.m(代码中注释的部分)中用具体的打印机对象进行操作，在main.m文件中，我们看到，当Person需要使用哪个打印机的时候，就去调用指定的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[person printWithBlack:blackPrint];//调用黑白打印机  
[person printWithColor:colorPrint];//调用彩色打印机  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种设计就不好了，为什么呢？假如现在又有一种打印机，那么我们还需要在 Person.h 中定义一种操作这种打印机的方法，那么后续如果在添加新的打印机呢？还在添加方法吗？那么 Person.h 文件就会变得很臃肿。所以这时候多态就体现到好处了，使用父类类型，在 Person.h 中定义一个方法就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void) doPrint:(Printer *)printer;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里看到了，这个方法的参数类型就是父类的类型，这就是多态，定义类型为父类类型，实际类型为子类类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void) doPrint:(Printer *)printer{  
  [printer print];  
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里调用print方法，就是传递进来的实际类型的print方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printer *p1 = [[ColorPrinter alloc] init];  
Printer *p2 = [[BlackPrinter alloc] init];  

[person doPrint:p1];  
[person doPrint:p2];  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的p1,p2表面上的类型是Printer，但是实际类型是子类类型，所以会调用他们自己对应的print方法。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; OC中类的三大特性：继承，封装，多态&lt;/p&gt;
&lt;h3 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h3&gt;&lt;p&gt;OC中是有四种访问权限修饰符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@public、@protected、@private、@package
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中默认的修饰符是@private&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件的处理－见识filemanager的强大</title>
    <link href="http://yoursite.com/2016/04/22/%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8D%E8%A7%81%E8%AF%86filemanager%E7%9A%84%E5%BC%BA%E5%A4%A7/"/>
    <id>http://yoursite.com/2016/04/22/文件的处理－见识filemanager的强大/</id>
    <published>2016-04-22T14:29:05.000Z</published>
    <updated>2016-04-22T14:29:35.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;获取-Documents-目录文件&quot;&gt;&lt;a href=&quot;#获取-Documents-目录文件&quot; class=&quot;headerlink&quot; title=&quot;获取 Documents 目录文件&quot;&gt;&lt;/a&gt;获取 Documents 目录文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Library-目录路径&quot;&gt;&lt;a href=&quot;#获取-Library-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Library 目录路径&quot;&gt;&lt;/a&gt;获取 Library 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString *libraryDirectofry = [paths2 lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Tmp-目录路径&quot;&gt;&lt;a href=&quot;#获取-Tmp-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Tmp 目录路径&quot;&gt;&lt;/a&gt;获取 Tmp 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *tmpDirectory = NSTemporaryDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件夹&quot;&gt;&lt;a href=&quot;#创建文件夹&quot; class=&quot;headerlink&quot; title=&quot;创建文件夹&quot;&gt;&lt;/a&gt;创建文件夹&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *testDirectory = [documentsDirectory stringByAppendingString:@&amp;quot;test&amp;quot;];
BOOL res = [fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil];   
if (res) {

    NSLog(@&amp;quot;创建文件夹成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件夹失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件&quot;&gt;&lt;a href=&quot;#创建文件&quot; class=&quot;headerlink&quot; title=&quot;创建文件&quot;&gt;&lt;/a&gt;创建文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
NSString *testPath = [testDirectory stringByAppendingPathComponent:@&amp;quot;test.txt&amp;quot;];
BOOL res2 = [fileManager createFileAtPath:testPath contents:data attributes:nil]; 
if (res2) {

    NSLog(@&amp;quot;创建文件成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;测试写入内容&quot;&gt;&lt;a href=&quot;#测试写入内容&quot; class=&quot;headerlink&quot; title=&quot;测试写入内容&quot;&gt;&lt;/a&gt;测试写入内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content = @&amp;quot;测试写入内容&amp;quot;;
BOOL res3 = [content writeToFile:testPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; 
if (res3) {

    NSLog(@&amp;quot;文件写入成功&amp;quot;);
} else {

    NSLog(@&amp;quot;文件写入失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;读取文件内容&quot;&gt;&lt;a href=&quot;#读取文件内容&quot; class=&quot;headerlink&quot; title=&quot;读取文件内容&quot;&gt;&lt;/a&gt;读取文件内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content2 = [NSString stringWithContentsOfFile:testPath encoding:NSUTF8StringEncoding error:nil]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取文件属性&quot;&gt;&lt;a href=&quot;#获取文件属性&quot; class=&quot;headerlink&quot; title=&quot;获取文件属性&quot;&gt;&lt;/a&gt;获取文件属性&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:testPath error:nil]; 
for (int i = 0; i &amp;lt; [[fileAttributes allKeys] count]; i ++) {

    NSLog(@&amp;quot;key: %@, value:%@&amp;quot;, [[fileAttributes allKeys] objectAtIndex:i], [fileAttributes objectForKey:[[fileAttributes allKeys] objectAtIndex:i]]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;BOOL res4 = [fileManager removeItemAtPath:testPath error:nil]; 
if (res4) {

    NSLog(@&amp;quot;删除成功&amp;quot;);
} else {

    NSLog(@&amp;quot;删除失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>内存空间Zone的挖掘</title>
    <link href="http://yoursite.com/2016/04/22/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4Zone%E7%9A%84%E6%8C%96%E6%8E%98/"/>
    <id>http://yoursite.com/2016/04/22/内存空间Zone的挖掘/</id>
    <published>2016-04-22T14:26:34.000Z</published>
    <updated>2016-04-22T14:27:11.000Z</updated>
    
    <content type="html">&lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;所以你为什么想要去用你自己的NSZone呢？&lt;/p&gt;
&lt;p&gt;如果你大量分配数百个小对象，事实上你会发现你花费精力来为他们分配内存是有意义的。因为这种标准的（默认的）空间会被一直使用，它会变得斑驳起来；释放对象的过程会给整个内存留下令人尴尬的空隙。标准空间的分配器（allocator）也知道知道这一点，所以它尝试着优先去使用被用户释放的内存，去填补这些空隙，但是这种方式只有在空间(zone) 变得很大时才有明显效果。&lt;/p&gt;
&lt;p&gt;如果你想为大量对象分配内存，然后，你可以创建你自己的空间（zone）并且告诉它不用去为了为新对象分配内存而去查找那些空隙。分配器现在能够每次跳到内存分配的末尾为你的新对象分配内存，能起到不错的效果。&lt;/p&gt;
&lt;p&gt;另外，分配器也能为你节省时间，当分配器向操作系统请求更多内存时，分配器去查找哪块空间什么时候被填满，需要花费不少时间。一种更快的时间是一次去请求一大块内存，你也能告诉你的NSZone在这儿做什么。&lt;/p&gt;
&lt;p&gt;NSZone也能节省你释放内存的时间。它有方法释放大量分配的内存，而不打扰释放器（deallocators）。如果用一个集合（set）包含一系列对象，这样能够节省时间，你可以一次释放它们而不用去乏味地一个个释放它们。&lt;/p&gt;
&lt;p&gt;NSZone is Apple’s way of optimizing object allocation and freeing. NSZone is not an object; it is an opaque C-struct storing information about how memory should be handled for a set of objects.&lt;/p&gt;
&lt;p&gt;One rarely needs to worry about handling your own zones in applications; Cocoa handles it transparently. A default NSZone is created&amp;gt;If you are mass-allocating hundreds of cheap objects, you may find the cost of actually allocating space for them becomes significant. Because the standard zone is used all the time, it can become very patchy; deleted objects can leave awkward gaps throughout memory. The allocator for the standard NSZone knows this, and it tries to fill these gaps in preference to grabbing more memory off the system, but this can be costly in time if the zone has grown quite large.&lt;/p&gt;
&lt;p&gt;If you want to mass-allocate objects, then, you can create your own zone and tell it not to bother with finding gaps to put new objects in. The allocator can now jump to the end of its allotted memory each time and quickly assign memory to your new objects, saving a lot of effort.&lt;/p&gt;
&lt;p&gt;Allocators can save you time elsewhere, too, as asking the OS for more memory, which a zone needs to do whenever it fills up, is another costly operation if it’s done a lot. Much quicker is to ask for huge chunks of memory at a time, and you can tell your NSZone what to do here as well.&lt;/p&gt;
&lt;p&gt;Rumor has it that NSZone could save you deallocation time in the Good Old Days, too, with a method that simply chucks away all the allotted memory without bothering to call deallocators. If a set of objects is self-contained, this could save a lot of time, as you can chuck them all away at style=”font-weight:bold”&amp;gt;NSZone method (NSRecycleZone) carefully puts all the objects in a zone neatly style=”font-weight:bold”&amp;gt;NSZone. Not exactly a huge time-saver.&lt;/p&gt;
&lt;p&gt;So, in summary, zones save you time in mass allocations. &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>错误类error的学习</title>
    <link href="http://yoursite.com/2016/04/22/%E9%94%99%E8%AF%AF%E7%B1%BBerror%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/04/22/错误类error的学习/</id>
    <published>2016-04-22T14:24:31.000Z</published>
    <updated>2016-04-22T14:25:03.000Z</updated>
    
    <content type="html">&lt;p&gt;获取系统的错误信息 &lt;/p&gt;
&lt;p&gt;比如移动文件时，获取文件操作错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NSError *e = nil;
  [[NSFileManager defaultManager] moveItemAtPath:sourcePath toPath:targetPath error:&amp;amp;e];
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
先定一个空的错误信息
  NSError *e = nil;
取地址
  &amp;amp;e   
如果有错误信息，打印错误的本地化描述
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;自定义错误信息&quot;&gt;&lt;a href=&quot;#自定义错误信息&quot; class=&quot;headerlink&quot; title=&quot;自定义错误信息&quot;&gt;&lt;/a&gt;自定义错误信息&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;通常可以通过下面语句，自定义个NSError对象

   #define CustomErrorDomain @&amp;quot;com.xiaodao.test&amp;quot;
     typedef enum {

   　　  XDefultFailed = -1000,
   　　  XRegisterFailed,
   　　  XConnectFailed,
   　　  XNotBindedFailed
     }CustomErrorFailed;

   NSDictionary *userInfo = [NSDictionary dictionaryWithObject:@&amp;quot;is a error test&amp;quot;                                                                      forKey:NSLocalizedDescriptionKey];
   NSError *aError = [NSError errorWithDomain:CustomErrorDomain code:XDefultFailed userInfo:userInfo];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，自定义错误域对象CustomErrorDomain，通常用域名反写，也可以是任何其他字符串code错误标识, 系统的code一般都大于零，自定code可以用枚举（最好用负数, 但不是必须的）userInfo自定义错误信息，NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述可以通过NSError的localizedDescription方法获得对应的值信息&lt;/p&gt;
&lt;p&gt;主调用函数一般传入NSError指针的指针，来获取错误信息，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (Bool)doSomething:(NSDictionary *)parameter1 error:(NSError **)aError
{
   //TODO: do something
　　*aError = [NSError errorWithDomain:CustomErrorDomain code:XDefultFailed userInfo:userInfo];
　　return Yes;

}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSError头文件解析&quot;&gt;&lt;a href=&quot;#NSError头文件解析&quot; class=&quot;headerlink&quot; title=&quot;NSError头文件解析&quot;&gt;&lt;/a&gt;NSError头文件解析&lt;/h3&gt;&lt;h4 id=&quot;NSError对象中，主要有三个私有变量&quot;&gt;&lt;a href=&quot;#NSError对象中，主要有三个私有变量&quot; class=&quot;headerlink&quot; title=&quot;NSError对象中，主要有三个私有变量&quot;&gt;&lt;/a&gt;NSError对象中，主要有三个私有变量&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;错误域（NSInteger）： _domain

错误标示（NSString *）：_code

错误详细信息（NSDictionary *）：_userInfo

通常用_domain和_code一起标识一个错误信息


获取_domain
- (NSString *)domain;

获取 _code
- (NSInteger)code;

获取 _userInfo
- (NSDictionary *)userInfo;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;预定义域&quot;&gt;&lt;a href=&quot;#预定义域&quot; class=&quot;headerlink&quot; title=&quot;预定义域&quot;&gt;&lt;/a&gt;预定义域&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;AppKit和Foundation库中主要的错误域
     NSString *const NSCocoaErrorDomain;

其他域
     NSString *const NSPOSIXErrorDomain;
     NSString *const NSOSStatusErrorDomain;
     NSString *const NSMachErrorDomain;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;预定义的userinfo键名&quot;&gt;&lt;a href=&quot;#预定义的userinfo键名&quot; class=&quot;headerlink&quot; title=&quot;预定义的userinfo键名&quot;&gt;&lt;/a&gt;预定义的userinfo键名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;推荐的标准方式，通用键
    NSString *const NSUnderlyingErrorKey;

其他键，对应各自读取信息的方法：

详细描述键
    NSString *const NSLocalizedDescriptionKey;

取方法
   - (NSString *)localizedDescription;

失败原因键
    NSString *const NSLocalizedFailureReasonErrorKey

取方法
    - (NSString *)localizedFailureReason;

恢复建议键
    NSString *const NSLocalizedRecoverySuggestionErrorKey;

取方法
    - (NSString *)localizedRecoverySuggestion;

恢复选项键
    NSString *const NSLocalizedRecoveryOptionsErrorKey

取方法
    - (NSArray *)localizedRecoveryOptions;

其他键
    NSString *const NSRecoveryAttempterErrorKey; 
    NSString *const NSHelpAnchorErrorKey;
    NSString *const NSStringEncodingErrorKey ;
    NSString *const NSURLErrorKey;
    NSString *const NSFilePathErrorKey;
用法：
NSDictionary *userInfo ＝ [NSDictionary dictionaryWithObjectsAndKeys:@&amp;quot;这是错误详细的描述信息&amp;quot;, NSLocalizedDescriptionKey, error, NSUnderlyingErrorKey, nil]];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;主要的初始化方法：&quot;&gt;&lt;a href=&quot;#主要的初始化方法：&quot; class=&quot;headerlink&quot; title=&quot;主要的初始化方法：&quot;&gt;&lt;/a&gt;主要的初始化方法：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (id)initWithDomain:(NSString *)domain code:(NSInteger)code userInfo:(NSDictionary *)dict;
+ (id)errorWithDomain:(NSString *)domain code:(NSInteger)code userInfo:(NSDictionary *)dict;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;获取系统的错误信息 &lt;/p&gt;
&lt;p&gt;比如移动文件时，获取文件操作错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NSError *e = nil;
  [[NSFileManager defaultManager] moveItemAtPath:sourcePath toPath:targetPath error:&amp;amp;e];
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
先定一个空的错误信息
  NSError *e = nil;
取地址
  &amp;amp;e   
如果有错误信息，打印错误的本地化描述
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS程序的五种状态</title>
    <link href="http://yoursite.com/2016/04/22/iOS%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2016/04/22/iOS程序的五种状态/</id>
    <published>2016-04-22T14:21:54.000Z</published>
    <updated>2016-04-22T14:23:20.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;IOS应用程序5种状态&quot;&gt;&lt;a href=&quot;#IOS应用程序5种状态&quot; class=&quot;headerlink&quot; title=&quot;IOS应用程序5种状态&quot;&gt;&lt;/a&gt;IOS应用程序5种状态&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Not running:应用还没有启动，或者应用正在运行但是途中被系统停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inactive:当前应用正在前台运行，但是并不接收事件（当前 或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不 同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时 间比较长的情况是：当用户 锁屏时，或者系统提示用户去响应某 些（诸如电话来电、有未读短信等）事件的时候。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Active:当前应用正在前台运行，并且接收事件。这是应用正在前台运行时所处的正常状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Background:应用处在后台，并且还在执行代码。大多数将 要进入Suspended状态的应用，会先短暂进入此状态。然而，对于请求 需要额外的执行时间的应用，会在此状态保持更长一段时间。另外， 如果一个应用要 求启动时直接进入后台运行，这样的应用会直接 从Not running状态进入Background状态，中途不会经过Inactive状 态。比如没有界面的应用。注此处并不特指没有界面的应用，其实 也可以是 有界面的应用，只是如果要直接进入background状态的 话，该应用界面不会被显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Suspended:应用处在后台，并且已停止执行代码。系统自动 的将应用移入此状态，且在此举之前不会对应用做任何通知。当处在 此状态时，应用依然驻留内存但不执行任何程序代码。当系统发生 低内存告警时，系统将会将处 于Suspended状态的应用清除出内 存以为正在前台运行的应用提供足够的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IOS应用程序5种状态&quot;&gt;&lt;a href=&quot;#IOS应用程序5种状态&quot; class=&quot;headerlink&quot; title=&quot;IOS应用程序5种状态&quot;&gt;&lt;/a&gt;IOS应用程序5种状态&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Not running:应用还没有启动，或者应用正在运行但是途中被系统停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inactive:当前应用正在前台运行，但是并不接收事件（当前 或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不 同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时 间比较长的情况是：当用户 锁屏时，或者系统提示用户去响应某 些（诸如电话来电、有未读短信等）事件的时候。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>单例UIApplication-总结</title>
    <link href="http://yoursite.com/2016/04/22/%E5%8D%95%E4%BE%8BUIApplication-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/22/单例UIApplication-总结/</id>
    <published>2016-04-22T14:16:58.000Z</published>
    <updated>2016-04-22T14:21:05.000Z</updated>
    
    <content type="html">&lt;p&gt;If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIKIT_EXTERN int UIApplicationMain (

   int argc, 
   char *argv[], 
   NSString * __nullable principalClassName, 
   NSString * __nullable delegateClassName
);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责-三件-事情：&quot;&gt;&lt;a href=&quot;#那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责-三件-事情：&quot; class=&quot;headerlink&quot; title=&quot;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责 三件 事情：&quot;&gt;&lt;/a&gt;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责 三件 事情：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1）从给定的类名初始化应用程序对象，也就是初始化UIApplication或者子类对象的一个实例，
如果你在这里给定的是nil，那么 系统会默认UIApplication类，也就主要是这个类来控制以及协调应用程序的运行。
在后续的工作中，你可以用静态方法sharedApplication 来获取应用程序的句柄。 
2）从给定的应用程序委托类，初始化一个应用程序委托。并把该委托设置为应用程序的委托，这里就有如果传入参数为nil，会调用函数访问 Info.plist文件来寻找主nib文件，获取应用程序委托。 
3）启动主事件循环，并开始接收事件。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;UIApplication（或-者子类）对象的职责，这个对象主要做下面几件事：&quot;&gt;&lt;a href=&quot;#UIApplication（或-者子类）对象的职责，这个对象主要做下面几件事：&quot; class=&quot;headerlink&quot; title=&quot;UIApplication（或 者子类）对象的职责，这个对象主要做下面几件事：&quot;&gt;&lt;/a&gt;UIApplication（或 者子类）对象的职责，这个对象主要做下面几件事：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1）负责处理到来的用户事件，并分发事件消息到应该处理该消息的目标对象（sender,  action)。 
2）管理以及控制视图，包括呈现、控制行为、当前显示视图等。 
3）该对象有一个应用程序委托对象，当一些生命周期内重要事件（可以包括系统事件或者生命周期控制事件）发生时，应用程序通知该对象。
例如，应用程序启动、内存不够了或者应用程序结束等，让这些事件发生时，应用程序委托去响应。 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot;&gt;&lt;a href=&quot;#我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot; class=&quot;headerlink&quot; title=&quot;我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot;&gt;&lt;/a&gt;我们可以从应用程序的单例类对象中得到应用程序委托的对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UIApplicationDelegate* myDelegate = [[UIApplication sharedApplication] delegate]; 

UIApplication 接收到所有的系统事件和生命周期事件时，都会把事件传递给UIApplicationDelegate进行处理，
对于用户输入 事件，则传递给相应的目标对象去处理
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;创建UIApplication对象并指定其代理&quot;&gt;&lt;a href=&quot;#创建UIApplication对象并指定其代理&quot; class=&quot;headerlink&quot; title=&quot;创建UIApplication对象并指定其代理&quot;&gt;&lt;/a&gt;创建UIApplication对象并指定其代理&lt;/h3&gt;&lt;p&gt;通过UIApplicationMain函数创建UIApplication对象并 指定其代理对象AppDelegate;第三个参数为指定 UIApplication的子类来生成UIApplication对象，为nil时由 UIApplication类初始化默认对象；第四个参数为指定代理 对象。&lt;/p&gt;
&lt;h3 id=&quot;UIApplication的代理对象&quot;&gt;&lt;a href=&quot;#UIApplication的代理对象&quot; class=&quot;headerlink&quot; title=&quot;UIApplication的代理对象&quot;&gt;&lt;/a&gt;UIApplication的代理对象&lt;/h3&gt;&lt;p&gt;作为UIApplication的代理类，必须要先实现 UIApplicationDelegate协议，协议里明确了作为代理应 该做或可以做哪些事情。 UIApplication对象负责监听应用程序的生命周期事件， 并将生命周期事件交由UIApplication代理对象处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIKIT_EXTERN int UIApplicationMain (

   int argc, 
   char *argv[], 
   NSString * __nullable principalClassName, 
   NSString * __nullable delegateClassName
);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC关键字</title>
    <link href="http://yoursite.com/2016/04/15/OC%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/04/15/OC关键字/</id>
    <published>2016-04-15T14:50:55.000Z</published>
    <updated>2016-04-15T14:53:08.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;import和-include的区别&quot;&gt;&lt;a href=&quot;#import和-include的区别&quot; class=&quot;headerlink&quot; title=&quot;#import和#include的区别&quot;&gt;&lt;/a&gt;#import和#include的区别&lt;/h3&gt;&lt;p&gt;  当我们在代码中使用两次#include的时候会报错：因为#include相当于拷贝头文件中的声明内容，所以会报重复定义的错误但是使用两次#import的话，不会报错，所以他可以解决重复导入的问题，他会做一次判断，如果已经导入一次就不导入了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;class&quot;&gt;&lt;a href=&quot;#class&quot; class=&quot;headerlink&quot; title=&quot;@class&quot;&gt;&lt;/a&gt;@class&lt;/h3&gt;&lt;p&gt;  不会将Student.h拷贝过来，只是告诉编译器Student这个类在别的地方中有定义，这样就不知道这个类中任何信息(哪些属性和方法) &lt;/p&gt;
&lt;p&gt;#import指令是Object-C针对#include的改进版本，#import确保引用的文件只会被引用一次，这样就不会陷入递归包含的问题中。&lt;/p&gt;
&lt;h3 id=&quot;import与-class二者的区别在于：&quot;&gt;&lt;a href=&quot;#import与-class二者的区别在于：&quot; class=&quot;headerlink&quot; title=&quot;#import与@class二者的区别在于：&quot;&gt;&lt;/a&gt;#import与@class二者的区别在于：&lt;/h3&gt;&lt;p&gt;　　 &lt;/p&gt;
&lt;p&gt; #import会链入该头文件的全部信息，包括实体变量和方法等；而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑。在头文件中， 一般只需要知道被引用的类的名称就可以了。&lt;br&gt;　　&lt;br&gt; 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;import和-include的区别&quot;&gt;&lt;a href=&quot;#import和-include的区别&quot; class=&quot;headerlink&quot; title=&quot;#import和#include的区别&quot;&gt;&lt;/a&gt;#import和#include的区别&lt;/h3&gt;&lt;p&gt;  当我们在代码中使用两次#include的时候会报错：因为#include相当于拷贝头文件中的声明内容，所以会报重复定义的错误但是使用两次#import的话，不会报错，所以他可以解决重复导入的问题，他会做一次判断，如果已经导入一次就不导入了&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC的实例方法和类方法的区别</title>
    <link href="http://yoursite.com/2016/04/15/OC%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/15/OC的实例方法和类方法的区别/</id>
    <published>2016-04-15T14:48:32.000Z</published>
    <updated>2016-04-15T14:50:21.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;-对象方法&lt;/strong&gt; 即OO的基本精神之一 —— 封装／信息隐藏，这个需要你对OO有理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+类方法&lt;/strong&gt; 一般用作命名空间，用以组织一组功能函数；又或用作类的工厂函数，用以产生类的对象；不管哪种，都需要有大型项目的经验，才知道如何组织程序的复杂性及使用设计模式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;类方法和实例方法&quot;&gt;&lt;a href=&quot;#类方法和实例方法&quot; class=&quot;headerlink&quot; title=&quot;类方法和实例方法&quot;&gt;&lt;/a&gt;类方法和实例方法&lt;/h3&gt;&lt;p&gt;实例方法是— ， 类开头是+&lt;br&gt;实例方法是用实例对象访问，类方法的对象是类而不是实例，通常创建对象或者工具类。&lt;/p&gt;
&lt;p&gt;在实例方法里，根据继承原理发送消息给self和super其实都是发送给self&lt;/p&gt;
&lt;p&gt;在类方法里面self是其他的类的类方法，在类方法中给self发送消息只能发类方法，self是类super也是&lt;/p&gt;
&lt;p&gt;什么时候用类方法：要创建一个实例时候获取一个共享实例，或者获取关于类的一些共有信息&lt;/p&gt;
&lt;p&gt;1、类方法是属于整个类，而不属于某个对象。&lt;br&gt;2、类方法只能访问类成员变量，不能访问实例变量，而实例方法可以访问类成员变量和实例变量。&lt;br&gt;3、类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问。&lt;br&gt;4、类方法只能访问类方法，而实例方法可以访问类方法和实例方法。&lt;br&gt;5、类方法不能被覆盖，实例方法可以被覆盖。 &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;-对象方法&lt;/strong&gt; 即OO的基本精神之一 —— 封装／信息隐藏，这个需要你对OO有理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+类方法&lt;/strong&gt; 一般用作命名空间，用以组织一组功能函数；又或用作类的工厂函数，用以产生类的对象；不管哪种，都需要有大型项目的经验，才知道如何组织程序的复杂性及使用设计模式&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSSet_集合（无序）</title>
    <link href="http://yoursite.com/2016/04/15/NSSet-%E9%9B%86%E5%90%88%EF%BC%88%E6%97%A0%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2016/04/15/NSSet-集合（无序）/</id>
    <published>2016-04-15T14:46:28.000Z</published>
    <updated>2016-04-15T14:47:26.000Z</updated>
    
    <content type="html">&lt;p&gt;NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;//判断是否含有age字符串
if([set containsObject:@&amp;quot;age&amp;quot;]) {
    NSLog(@&amp;quot;set包含age&amp;quot;);
}

//判断set 是否等于set1
if ([set isEqualToSet:set1]) {
    NSLog(@&amp;quot;set 等于 set1&amp;quot;);
}

//判断set是否是否是set1的子集合
if ([set isSubsetOfSet:set1]) {
    NSLog(@&amp;quot;set isSubsetOfSet set1&amp;quot;);
}

//获取所有set对象
NSArray *array = [set allObjects];
NSLog(@&amp;quot;array:%@&amp;quot;, array);

//迭代遍历
NSEnumerator *enumerator = [set objectEnumerator];
for (NSObject *object in enumerator) {
    NSLog(@&amp;quot;set1里的对象:%@&amp;quot;, object);
}

//添加对象到集合里面
[set setByAddingObject:@&amp;quot;123&amp;quot;];

// 类方法处理方式
NSSet *set3 = [NSSet set];
NSSet *set4 = [NSSet setWithObject:@&amp;quot;123&amp;quot;];
NSSet *set5 = [NSSet setWithObjects:@&amp;quot;1&amp;quot;, @&amp;quot;2&amp;quot;, nil];
NSSet *set6 = [NSSet setWithArray:array];
NSSet *set7 = [NSSet setWithSet:set6];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSMutableSet的使用&quot;&gt;&lt;a href=&quot;#NSMutableSet的使用&quot; class=&quot;headerlink&quot; title=&quot;NSMutableSet的使用&quot;&gt;&lt;/a&gt;NSMutableSet的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSMutableSet继承NSSet，它可以使用NSSet的方法。

[NSMutableSet setWithCapacity:6]:创建可变集合对象，并且初始化长度为6。
[set addObject: obj] : 向集合中动态的添加对象。
[set removeObject:obj]:删除集合中的一个对象。
[set removeAllObjects]:删除集合中的所有对象。
[set unionSet:obj]:向集合中添加一个obj集合的所有数据。
[set minusSet:obj]:向集合中删除一个obj集合的所有数据。
[set intersectSet]:向集合中删除一个不包含obj集合的所有数据。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中 @synthesize 和 @dynamic 的区别</title>
    <link href="http://yoursite.com/2016/04/14/iOS%E4%B8%AD-synthesize-%E5%92%8C-dynamic-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/14/iOS中-synthesize-和-dynamic-的区别/</id>
    <published>2016-04-14T13:28:35.000Z</published>
    <updated>2016-04-14T13:40:13.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其主要的作用就是用在NSManagerObject对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，core data 框架会在程序运行的时候为此类属性生成getter和setter方法。&lt;/p&gt;
&lt;p&gt;被指定为动态实现的方法的dynamicMethod的参数有如下的要求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A.第一个、第二个参数必须是id、SEL；
B.第三个参数开始，你可以按照原方法（例如：setHeight:(float)）的参数定义。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再接下来，你需要覆盖NSObject 的类方法resolveInstanceMethod，这个方法会把需要动态实现的方法（setHeight:）的选择器传递进来，我们判断一下是否是需要动态实现的选择器，如果是就把处理权转交给dynamicMethod。&lt;/p&gt;
&lt;h3 id=&quot;如何转交呢？&quot;&gt;&lt;a href=&quot;#如何转交呢？&quot; class=&quot;headerlink&quot; title=&quot;如何转交呢？&quot;&gt;&lt;/a&gt;如何转交呢？&lt;/h3&gt;&lt;p&gt;这里我们就要用到运行时函数class_addMethod(Class,SEL,IMP,char[])。&lt;/p&gt;
&lt;p&gt;运行时函数位于objc/runtime.h，正如名字一样，这里面都是C 语言的函数。按照这些函数的功能的不同，主要分为如下几类：操作类型、操作对象、操作协议等。大多数的函数都可以通过名字看出是什么意思，例如：class_addProtocol 动态的为一个类型在运行时增加协议、objc_getProtocol 把一个字符串转换为协议等。&lt;/p&gt;
&lt;p&gt;言归正传，我们来解释一下这里需要用到的class_addmethod 方法，这个方法有四个参数，Class 表示你要为哪个类型增加方法，SEL 参数表示你要增加的方法的选择器，IMP 表示你要添加的方法的运行时的具体实现的函数指针。其实在这里你能够看出SEL 并不能在运行时找到真正要调用的方法，IMP 才可以真正的找到实现方法的。&lt;/p&gt;
&lt;p&gt;现在我们来正式的看以下第四个参数v@:f 的含义，它描述了IMP 指向的函数的描述信息，按照@encode 指令编译之后的字符说明，第一个字符v 表示返回值为void，剩余的字符为dynamicMethod 函数的参数描述，@表示第一个参数id，:自然就是第二个参数SEL，f 就是第三个参数float。由于前面说过动态方法的实现的前两个参数必须是id、SEL，所以第四个参数中的字符串的第二、三个字符一定是@:。我们看到resolveInstanceMethod 方法的返回值为BOOL，也就是这个方法返回YES 表示找到了动态方法的具体实现，否则就表示没有在运行时找到真实的实现，程序就汇报错。&lt;/p&gt;
&lt;p&gt;经过了上面的处理，Objective-C 的运行时只要发现你调用了@dynamic 标注的属性的setter、getter 方法，就会自动到resolveInstanceMethod 里去寻找真实的实现。这也就是说你在main.m 中调用peson.height 的时候，实际上dynamicMethod 函数被调用了。实际上除了@dynamic 标注的属性之外，如果你调用了类型中不存在的方法，也会被 resolveInstanceMethod 或者resolveClassMethod 截获，但由于你没有处理，所以会报告不能识别的消息的错误。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;譬如：从网络下载一个升级包，不需要退出原有的程序，就可以动态的替换掉旧的功能等类似的需求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
