<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-14T11:51:09.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>YYModel字典转模型的几种详细用法</title>
    <link href="http://yoursite.com/2016/11/14/YYModel%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2016/11/14/YYModel字典转模型的几种详细用法/</id>
    <published>2016-11-14T11:47:06.000Z</published>
    <updated>2016-11-14T11:51:09.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;常用的几个方法&quot;&gt;&lt;a href=&quot;#常用的几个方法&quot; class=&quot;headerlink&quot; title=&quot;常用的几个方法&quot;&gt;&lt;/a&gt;常用的几个方法&lt;/h4&gt;&lt;p&gt;json转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithJSON:(id)json;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSString *)yy_modelToJSONString 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 声明数组、字典或者集合里的元素类型时要重写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass；
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# YYAlbum.h
@property (nonatomic, copy) NSString *name;
@property (nonatomic, strong) NSArray *photos; # Array&amp;lt;YYPhoto&amp;gt;
@property (nonatomic, strong) NSDictionary *likedUsers; # Key:name(NSString) Value:user(YYUser)
@property (nonatomic, strong) NSSet *likedUserIds; # Set&amp;lt;NSNumber&amp;gt;

# YYPhoto.h
@property (nonatomic, copy) NSString *url;
@property (nonatomic, copy) NSString *desc;

# YYAlbum.m
#把数组里面带有对象的类型专门按照这个方法，这个格式写出来
-(nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass{
    return @{
             @&amp;quot;photos&amp;quot;       : YYPhoto.class,
             @&amp;quot;likedUsers&amp;quot;   : YYUser.class,
             @&amp;quot;likedUserIds&amp;quot; : NSNumber.class
             };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典里的key值与模型的属性值不一致要重置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelCustomPropertyMapper;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# YYMessage.h
@property (nonatomic, assign) uint64_t messageId;
@property (nonatomic, strong) NSString *content;
@property (nonatomic, strong) NSDate *time;

# YYMessage.m
/*!
 *  1.该方法是 `字典里的属性Key` 和 `要转化为模型里的属性名` 不一样 而重写的
 *  前：模型的属性   后：字典里的属性
 */

+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelCustomPropertyMapper{

    return @{@&amp;quot;messageId&amp;quot;:@&amp;quot;i&amp;quot;,
             @&amp;quot;content&amp;quot;:@&amp;quot;c&amp;quot;,
             @&amp;quot;time&amp;quot;:@&amp;quot;t&amp;quot;};
}

/*!
 *  2. 下面的两个方法 `字典里值`与`模型的值`类型不一样`需要转换`而重写的方法
 *   NSDate *time     dic[@&amp;quot;t&amp;quot;]是double类型的的秒数
 */

/// Dic -&amp;gt; model
- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic {

    self.time = (NSDate *)[NSDate dateWithTimeIntervalSince1970:[dic[@&amp;quot;t&amp;quot;] doubleValue]/1000];

    return YES;
}

/// model -&amp;gt; Dic
- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic {

    dic[@&amp;quot;t&amp;quot;] = @([self.time timeIntervalSince1970] * 1000).description;

    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面两者是属性值在两个dic与模型之间的转化方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic ；
- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic；
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;常用的几个方法&quot;&gt;&lt;a href=&quot;#常用的几个方法&quot; class=&quot;headerlink&quot; title=&quot;常用的几个方法&quot;&gt;&lt;/a&gt;常用的几个方法&lt;/h4&gt;&lt;p&gt;json转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithJSON:(id)json;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSString *)yy_modelToJSONString 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 声明数组、字典或者集合里的元素类型时要重写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass；
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>layoutSubviews 总结</title>
    <link href="http://yoursite.com/2016/10/27/layoutSubviews-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/10/27/layoutSubviews-总结/</id>
    <published>2016-10-27T11:23:57.000Z</published>
    <updated>2016-10-27T11:28:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;ios-layout机制相关方法&quot;&gt;&lt;a href=&quot;#ios-layout机制相关方法&quot; class=&quot;headerlink&quot; title=&quot;ios layout机制相关方法&quot;&gt;&lt;/a&gt;ios layout机制相关方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (CGSize)sizeThatFits:(CGSize)size
- (void)sizeToFit
——————-
- (void)layoutSubviews
- (void)layoutIfNeeded
- (void)setNeedsLayout
——————–
- (void)setNeedsDisplay
- (void)drawRect
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;layoutSubviews在以下情况下会被调用：&quot;&gt;&lt;a href=&quot;#layoutSubviews在以下情况下会被调用：&quot; class=&quot;headerlink&quot; title=&quot;layoutSubviews在以下情况下会被调用：&quot;&gt;&lt;/a&gt;layoutSubviews在以下情况下会被调用：&lt;/h4&gt;&lt;p&gt;1、init初始化不会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;但是是用initWithFrame 进行初始化时，当rect的值不为CGRectZero时,也会触发&lt;/p&gt;
&lt;p&gt;2、addSubview会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化&lt;/p&gt;
&lt;p&gt;4、滚动一个UIScrollView会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;5、旋转Screen会触发父UIView上的layoutSubviews事件&lt;/p&gt;
&lt;p&gt;6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件&lt;/p&gt;
&lt;h3 id=&quot;刷新子对象布局&quot;&gt;&lt;a href=&quot;#刷新子对象布局&quot; class=&quot;headerlink&quot; title=&quot;刷新子对象布局&quot;&gt;&lt;/a&gt;刷新子对象布局&lt;/h3&gt;&lt;p&gt;-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写&lt;br&gt;-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用&lt;br&gt;-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）&lt;/p&gt;
&lt;p&gt;如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局&lt;/p&gt;
&lt;p&gt;在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]&lt;/p&gt;
&lt;h3 id=&quot;重绘&quot;&gt;&lt;a href=&quot;#重绘&quot; class=&quot;headerlink&quot; title=&quot;重绘&quot;&gt;&lt;/a&gt;重绘&lt;/h3&gt;&lt;p&gt;-drawRect:(CGRect)rect方法：重写此方法，执行重绘任务&lt;br&gt;-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect&lt;br&gt;-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘&lt;/p&gt;
&lt;p&gt;sizeToFit会自动调用sizeThatFits方法；&lt;/p&gt;
&lt;p&gt;sizeToFit不应该在子类中被重写，应该重写sizeThatFits&lt;/p&gt;
&lt;p&gt;sizeThatFits传入的参数是receiver当前的size，返回一个适合的size&lt;/p&gt;
&lt;p&gt;sizeToFit可以被手动直接调用&lt;/p&gt;
&lt;p&gt;sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己&lt;/p&gt;
&lt;p&gt;layoutSubviews对subviews重新布局&lt;/p&gt;
&lt;p&gt;layoutSubviews方法调用先于drawRect&lt;/p&gt;
&lt;p&gt;setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews&lt;/p&gt;
&lt;p&gt;layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的&lt;/p&gt;
&lt;p&gt;layoutIfNeeded遍历的不是superview链，应该是subviews链&lt;/p&gt;
&lt;p&gt;drawRect是对receiver的重绘，能获得context&lt;/p&gt;
&lt;p&gt;setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘 &lt;/p&gt;
&lt;h3 id=&quot;sizeToFit&quot;&gt;&lt;a href=&quot;#sizeToFit&quot; class=&quot;headerlink&quot; title=&quot;sizeToFit&quot;&gt;&lt;/a&gt;sizeToFit&lt;/h3&gt;&lt;p&gt;sizeToFit会自动调用sizeThatFits方法；&lt;br&gt;sizeToFit不应该在子类中被重写，应该重写sizeThatFits&lt;br&gt;sizeThatFits传入的参数是receiver当前的size，返回一个适合的size&lt;br&gt;sizeToFit可以被手动直接调用sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ios-layout机制相关方法&quot;&gt;&lt;a href=&quot;#ios-layout机制相关方法&quot; class=&quot;headerlink&quot; title=&quot;ios layout机制相关方法&quot;&gt;&lt;/a&gt;ios layout机制相关方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (CGSize)sizeThatFits:(CGSize)size
- (void)sizeToFit
——————-
- (void)layoutSubviews
- (void)layoutIfNeeded
- (void)setNeedsLayout
——————–
- (void)setNeedsDisplay
- (void)drawRect
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别知识点总结六</title>
    <link href="http://yoursite.com/2016/10/20/iOS%E7%89%B9%E5%88%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%85%AD/"/>
    <id>http://yoursite.com/2016/10/20/iOS特别知识点总结六/</id>
    <published>2016-10-20T14:04:41.000Z</published>
    <updated>2016-10-20T14:06:04.000Z</updated>
    
    <content type="html">&lt;p&gt;//判断内容是否全部为空格  yes 全部为空格  no 不是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)isEmpty:(NSString *) str {

    if (!str) {
        return true;
    } else {
        //A character set containing only the whitespace characters space (U+0020) and tab (U+0009) and the newline and nextline characters (U+000A–U+000D, U+0085).
        NSCharacterSet *set = [NSCharacterSet whitespaceAndNewlineCharacterSet];

        //Returns a new string made by removing from both ends of the receiver characters contained in a given character set.
        NSString *trimedString = [str stringByTrimmingCharactersInSet:set];

        if ([trimedString length] == 0) {
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UITabBarController&quot;&gt;&lt;a href=&quot;#UITabBarController&quot; class=&quot;headerlink&quot; title=&quot;UITabBarController&quot;&gt;&lt;/a&gt;UITabBarController&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//1.创建Window
 self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
 self.window.backgroundColor = [UIColor whiteColor];

 //a.初始化一个tabBar控制器
 UITabBarController *tb=[[UITabBarController alloc]init];
 //设置控制器为Window的根控制器
 self.window.rootViewController=tb;

 //b.创建子控制器
 UIViewController *c1=[[UIViewController alloc]init];
 c1.view.backgroundColor=[UIColor grayColor];
 c1.view.backgroundColor=[UIColor greenColor];
 c1.tabBarItem.title=@&amp;quot;消息&amp;quot;;
 c1.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_recent_nor&amp;quot;];
 c1.tabBarItem.badgeValue=@&amp;quot;123&amp;quot;;

 UIViewController *c2=[[UIViewController alloc]init];
 c2.view.backgroundColor=[UIColor brownColor];
 c2.tabBarItem.title=@&amp;quot;联系人&amp;quot;;
 c2.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_buddy_nor&amp;quot;];

 UIViewController *c3=[[UIViewController alloc]init];
 c3.tabBarItem.title=@&amp;quot;动态&amp;quot;;
 c3.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_qworld_nor&amp;quot;];

 UIViewController *c4=[[UIViewController alloc]init];
 c4.tabBarItem.title=@&amp;quot;设置&amp;quot;;
 c4.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_me_nor&amp;quot;]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;weak-typeof-self-weakSelf-self&quot;&gt;&lt;a href=&quot;#weak-typeof-self-weakSelf-self&quot; class=&quot;headerlink&quot; title=&quot;_weak typeof(self) weakSelf = self;&quot;&gt;&lt;/a&gt;_weak typeof(self) weakSelf = self;&lt;/h3&gt;&lt;p&gt;内存管理原则&lt;br&gt;1、默认strong，可选weak。strong下不管成员变量还是property，每次使用指针指向一个对象，等于自动调用retain(), 并对旧对象调用release(),所以设为nil等于release。&lt;br&gt;2、只要某个对象被任一strong指针指向，那么它将不会被销毁，否则立即释放，不用等runloop结束。所有strong指针变量不需要在dealloc中手动设为nil，iOS会自动处理，debug可以看到全部被置为nil，最先声明的变量最后调用dealloc释放。&lt;/p&gt;
&lt;p&gt;3、官方建议IBOutlet加上__weak，实际上不用加也会自动释放；&lt;/p&gt;
&lt;p&gt;4、优先使用私有成员变量，除非需要公开属性才用property。&lt;/p&gt;
&lt;p&gt;5、避免循环引用，否则手动设置nil释放。&lt;/p&gt;
&lt;p&gt;6、block方法常用声明：@property (copy) void(^MyBlock)(void); 如果超出当前作用域之后仍然继续使用block，那么最好使用copy关键字，拷贝到堆区，防止栈区变量销毁。&lt;/p&gt;
&lt;p&gt;7、创建block匿名函数之前一般需要对self进行weak化，否则造成循环引用无法释放controller:&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;weak MyController *weakSelf = self 或者 &lt;/strong&gt;weak __typeof(self) weakSelf = self;&lt;br&gt;执行block方法体的时候也可以转换为强引用之后再使用：MyController* strongSelf = weakSelf; if (!strongSelf) { return; }&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//判断内容是否全部为空格  yes 全部为空格  no 不是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)isEmpty:(NSString *) str {

    if (!str) {
        return true;
    } else {
        //A character set containing only the whitespace characters space (U+0020) and tab (U+0009) and the newline and nextline characters (U+000A–U+000D, U+0085).
        NSCharacterSet *set = [NSCharacterSet whitespaceAndNewlineCharacterSet];

        //Returns a new string made by removing from both ends of the receiver characters contained in a given character set.
        NSString *trimedString = [str stringByTrimmingCharactersInSet:set];

        if ([trimedString length] == 0) {
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之顶部状态栏statusBar颜色变化小结</title>
    <link href="http://yoursite.com/2016/10/20/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E9%A1%B6%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8FstatusBar%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/10/20/iOS开发之顶部状态栏statusBar颜色变化小结/</id>
    <published>2016-10-20T14:01:28.000Z</published>
    <updated>2016-10-20T14:03:50.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS开发之顶部状态栏statusBar颜色变化小结&lt;/p&gt;
&lt;p&gt;1.单个视图View没有导航控制器包装的情况下&lt;/p&gt;
&lt;p&gt;(1.只设置启动状态栏颜色改变(白色)，而视图中状态栏不变化(默认黑色)，做如下的设置即可，两种方式不管先设置哪一个，另一个都会相应的变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. General 中的 Status Bar Style   --&amp;gt;  Light

b. plist 中增加 Status Bar Style   --&amp;gt;  UIStatusBarStyleLightContent
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;(2).设置启动状态栏颜色改变(白色)，视图中的状态栏也变成白色(保持上面的设置)，有两种设置方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. 在Info.plist里面添加一行View controller-based status bar appearance ＝ NO 即可

b.在视图控制器中添加代码

  - (UIStatusBarStyle)preferredStatusBarStyle {

    return UIStatusBarStyleLightContent;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3).设置视图中状态栏的颜色为白色，启动程序时的状态栏为默认颜色(黑色)，没有做1.中的任何设置情况下，在控制器.m文件中添加如下代码(即2.-&amp;gt;b.)&lt;/p&gt;
&lt;p&gt;2.视图作为导航控制器的根控制器的情况下&lt;/p&gt;
&lt;p&gt;(1) .设置启动画面的状态栏为白色，视图中的状态栏为默认(黑色)，如1.-&amp;gt;1.中的设置即可，&lt;/p&gt;
&lt;p&gt;(2) .设置启动画面和视图中的状态栏颜色都为白色(保持2.-&amp;gt;1.中的设置)，方式同样有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a.在Info.plist里面添加一行View controller-based status bar appearance ＝ NO 即可


b.此时如果单单在视图控制器.m文件中添加如下代码是不够的，

- (UIStatusBarStyle)preferredStatusBarStyle {
    return UIStatusBarStyleLightContent;
}
同时需要在导航控制器.m文件中添加下面的代码才能达到效果(careful)

- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3).只设置视图控制器状态栏颜色为白色，启动画面的状态栏为默认(黑色)，把Info.plist文件中的 Status bar style = UIStatusBarStyleLightContent设置去掉，保持2.-&amp;gt;2.-&amp;gt;b.中的代码设置即可&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发之顶部状态栏statusBar颜色变化小结&lt;/p&gt;
&lt;p&gt;1.单个视图View没有导航控制器包装的情况下&lt;/p&gt;
&lt;p&gt;(1.只设置启动状态栏颜色改变(白色)，而视图中状态栏不变化(默认黑色)，做如下的设置即可，两种方式不管先设置哪一个，另一个都会相应的变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. General 中的 Status Bar Style   --&amp;gt;  Light

b. plist 中增加 Status Bar Style   --&amp;gt;  UIStatusBarStyleLightContent
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发使用系统的拷贝剪切功能</title>
    <link href="http://yoursite.com/2016/10/19/iOS%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%89%AA%E5%88%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/10/19/iOS开发使用系统的拷贝剪切功能/</id>
    <published>2016-10-19T11:15:58.000Z</published>
    <updated>2016-10-19T11:19:30.000Z</updated>
    
    <content type="html">&lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2）响应事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//并加上几个方法
-(void)longPressCellHandle:(UILongPressGestureRecognizer *)gesture {

    [self becomeFirstResponder];
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    UIMenuItem *copyItem = [[UIMenuItem alloc] initWithTitle:@&amp;quot;复制&amp;quot; action:@selector(menuCopyBtnPressed:)];
    menuController.menuItems = @[copyItem];
    [menuController setTargetRect:gesture.view.frame inView:gesture.view.superview];
    [menuController setMenuVisible:YES animated:YES];
    [UIMenuController sharedMenuController].menuItems=nil;
}

// 将要复制的内容复制到系统的剪贴板
- (void)menuCopyBtnPressed:(UIMenuItem *)menuItem {
    //  通用的粘贴板
    [UIPasteboard generalPasteboard].string = self.messageLab.text;
}

- (BOOL)canBecomeFirstResponder {

    return YES;
}

- (BOOL)canPerformAction:(SEL)action withSender:(id)sender {

    if (action == @selector(menuCopyBtnPressed:)) {
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之旅之懒加载</title>
    <link href="http://yoursite.com/2016/10/18/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2016/10/18/iOS开发之旅之懒加载/</id>
    <published>2016-10-18T14:54:55.000Z</published>
    <updated>2016-10-18T14:56:00.000Z</updated>
    
    <content type="html">&lt;p&gt;懒加载定义：延时加载，即当对象需要用到的时候再去加载。其实就是所谓的重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。&lt;/p&gt;
&lt;p&gt;需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)shopData {

    if (!_shopData) {
        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];
    }
    return _shopData;
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;懒加载的优点&lt;/p&gt;
&lt;p&gt;1）不需将对象的实例化写到viewDidLoad，可以简化代码，增强代码的可读性&lt;br&gt;2）对象的实例化在 getter 方法中，各司其职，降低耦合性&lt;br&gt;3）对系统的内存占用率会减小&lt;/p&gt;
&lt;p&gt;总结：懒加载即用到时方去加载对象&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;懒加载定义：延时加载，即当对象需要用到的时候再去加载。其实就是所谓的重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。&lt;/p&gt;
&lt;p&gt;需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)shopData {

    if (!_shopData) {
        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];
    }
    return _shopData;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>initWithFrame方法的理解</title>
    <link href="http://yoursite.com/2016/09/28/initWithFrame%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/09/28/initWithFrame方法的理解/</id>
    <published>2016-09-28T11:33:37.000Z</published>
    <updated>2016-09-28T11:36:38.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;initWithFrame方法是什么？&quot;&gt;&lt;a href=&quot;#initWithFrame方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;initWithFrame方法是什么？&quot;&gt;&lt;/a&gt;initWithFrame方法是什么？&lt;/h4&gt;&lt;p&gt;initWithFrame方法用来初始化并返回一个新的视图对象,根据指定的CGRect（尺寸）。&lt;/p&gt;
&lt;h4 id=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;a href=&quot;#什么时候用initWithFrame方法？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;/a&gt;什么时候用initWithFrame方法？&lt;/h4&gt;&lt;p&gt;简单的说，我们用编程方式申明，创建UIView对象时，使用initWithFrame方法。&lt;br&gt;在此，我们必须搞清楚，两种方式来进行初始化UIView。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-使用-Interface-Builder-方式&quot;&gt;&lt;a href=&quot;#1-使用-Interface-Builder-方式&quot; class=&quot;headerlink&quot; title=&quot;1) 使用 Interface Builder 方式&quot;&gt;&lt;/a&gt;1) 使用 Interface Builder 方式&lt;/h4&gt;&lt;p&gt; 这种方式，就是使用nib文件。通常我们说的“拖控件” 的方式。&lt;/p&gt;
&lt;p&gt;实际编程中，我们如果用Interface Builder 方式创建了UIView对象。（也就是，用拖控件的方式）&lt;br&gt;那么，initWithFrame方法方法是不会被调用的。因为nib文件已经知道如何初始化该View。（因为，我们在拖该view的时候，就定义好了长、宽、背景等属性）。&lt;br&gt;这时候，会调用initWithCoder方法，我们可以用initWithCoder方法来重新定义我们在nib中已经设置的各项属性。&lt;/p&gt;
&lt;h4 id=&quot;2-使用编程方式&quot;&gt;&lt;a href=&quot;#2-使用编程方式&quot; class=&quot;headerlink&quot; title=&quot;2) 使用编程方式&quot;&gt;&lt;/a&gt;2) 使用编程方式&lt;/h4&gt;&lt;p&gt;实际编程中，我们使用编程方式下，来创建一个UIView或者创建UIView的子类。这时候，将调用initWithFrame方法，来实例化UIView。&lt;br&gt;特别注意，如果在子类中重载initWithFrame方法，必须先调用父类的initWithFrame方法。在对自定义的UIView子类进行初始化操作。&lt;br&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)initWithFrame:(CGRect)frame{
    self = [super initWithFrame:frame];// 先调用父类的initWithFrame方法
    if (self) {

        // 再自定义该类（UIView子类）的初始化操作。
        _scrollView = [[UIScrollView alloc] initWithFrame:self.bounds];
        [_scrollView setFrame:CGRectMake(0, 0, 320, 480)];
        _scrollView.contentSize = CGSizeMake(320*3, 480);

        [self addSubview:_scrollView];
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;那么，用Interface-Builder-方式创建的nib文件是什么？&quot;&gt;&lt;a href=&quot;#那么，用Interface-Builder-方式创建的nib文件是什么？&quot; class=&quot;headerlink&quot; title=&quot;那么，用Interface Builder 方式创建的nib文件是什么？&quot;&gt;&lt;/a&gt;那么，用Interface Builder 方式创建的nib文件是什么？&lt;/h4&gt;&lt;p&gt;对于应用程序，资源是一种数据文件，伴随可程序执行程序的一种数据文件。（可以理解为可执行程序的，一种不可缺少的组陈部分）。&lt;br&gt;资源文件，是一种可移动的，由适合的工具编写的一种特殊的代码。&lt;br&gt;如：plish文件，txt文件，图像，视频等文件。都可以被xCode识别和引用。&lt;/p&gt;
&lt;p&gt;一个应用程序可以包含多种形式的资源文件。&lt;/p&gt;
&lt;p&gt;当然，nib文件也不例外，仅仅是一种资源文件。&lt;br&gt;通过Interface Builder 方式，可以创建nib文件，存储应用程序的UI对象。供应用程序来读取。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;initWithFrame方法是什么？&quot;&gt;&lt;a href=&quot;#initWithFrame方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;initWithFrame方法是什么？&quot;&gt;&lt;/a&gt;initWithFrame方法是什么？&lt;/h4&gt;&lt;p&gt;initWithFrame方法用来初始化并返回一个新的视图对象,根据指定的CGRect（尺寸）。&lt;/p&gt;
&lt;h4 id=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;a href=&quot;#什么时候用initWithFrame方法？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;/a&gt;什么时候用initWithFrame方法？&lt;/h4&gt;&lt;p&gt;简单的说，我们用编程方式申明，创建UIView对象时，使用initWithFrame方法。&lt;br&gt;在此，我们必须搞清楚，两种方式来进行初始化UIView。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> NSString 字符串处理</title>
    <link href="http://yoursite.com/2016/09/22/NSString-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/09/22/NSString-字符串处理/</id>
    <published>2016-09-22T14:39:16.000Z</published>
    <updated>2016-09-22T14:40:10.000Z</updated>
    
    <content type="html">&lt;p&gt;iphone NSString 字符串处理：截取字符串、匹配字符串、分隔字符串    &lt;/p&gt;
&lt;p&gt;1.截取字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
string = [string substringToIndex:7];//截取掉下标7之后的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
[string substringFromIndex:2];//截取掉下标2之前的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.匹配字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSRange range = [stringrangeOfString:@&amp;quot;f&amp;quot;];//匹配得到的下标
NSLog(@&amp;quot;rang:%@&amp;quot;,NSStringFromRange(range));
string = [string substringWithRange:range];//截取范围类的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.分隔字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSArray *array = [string componentsSeparatedByString:@&amp;quot;A&amp;quot;]; //从字符A中分隔成2个元素的数组
NSLog(@&amp;quot;array:%@&amp;quot;,array); //结果是adfsfsfs和dfsdf
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;iphone NSString 字符串处理：截取字符串、匹配字符串、分隔字符串    &lt;/p&gt;
&lt;p&gt;1.截取字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
string = [string substringToIndex:7];//截取掉下标7之后的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
[string substringFromIndex:2];//截取掉下标2之前的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UISlide属性</title>
    <link href="http://yoursite.com/2016/09/22/UISlide%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/22/UISlide属性/</id>
    <published>2016-09-22T14:39:02.000Z</published>
    <updated>2016-09-22T14:43:35.000Z</updated>
    
    <content type="html">&lt;p&gt;1.minimumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最小位置的值，默认为0.0

_slider.minimumValue = 10.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.maximumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最大位置的值，默认为1.0

_slider.maximumValue = 100.0;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;3.continuous &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果设置YES，在拖动滑块的任何时候，滑块的值都会改变。默认设置为YES

[_slider setContinuous:NO]; // 在滑块滑动结束时才获取滑块的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.minimumValueImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最小值处设置的图片，默认为nil

_slider.minimumValueImage = [UIImage imageNamed:@&amp;quot;003.png&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.maximumValueImage&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最大值处设置的图片,默认为nil

_slider.maximumValueImage = [UIImage imageNamed:@&amp;quot;002.png&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.minimumTrackTintColor :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小于滑块当前值滑块条的颜色，默认为蓝色

_slider.minimumTrackTintColor = [UIColor redColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.maximumTrackTintColor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大于滑块当前值滑块条的颜色，默认为白色

_slider.maximumTrackTintColor = [UIColor greenColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.thumbTintColor :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当前滑块的颜色，默认为白色

_slider.thumbTintColor = [UIColor yellowColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9.currentMaximumTrackImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最大值处设置的图片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;10.currentMinimumTrackImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最小值处设置的图片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;11.currentThumbImage&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当前滑块的图片
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;1.minimumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最小位置的值，默认为0.0

_slider.minimumValue = 10.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.maximumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最大位置的值，默认为1.0

_slider.maximumValue = 100.0;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用 AFNetworking 监听网络状态</title>
    <link href="http://yoursite.com/2016/09/22/%E5%88%A9%E7%94%A8-AFNetworking-%E7%9B%91%E5%90%AC%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2016/09/22/利用-AFNetworking-监听网络状态/</id>
    <published>2016-09-22T14:33:42.000Z</published>
    <updated>2016-09-22T14:37:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-创建网络监听者管理者对象&quot;&gt;&lt;a href=&quot;#1-创建网络监听者管理者对象&quot; class=&quot;headerlink&quot; title=&quot;1.创建网络监听者管理者对象&quot;&gt;&lt;/a&gt;1.创建网络监听者管理者对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-设置监听&quot;&gt;&lt;a href=&quot;#2-设置监听&quot; class=&quot;headerlink&quot; title=&quot;2.设置监听&quot;&gt;&lt;/a&gt;2.设置监听&lt;/h3&gt;&lt;p&gt;1)网络状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//显然是枚举值
typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,//未识别的网络
    AFNetworkReachabilityStatusNotReachable     = 0,//不可达的网络
    AFNetworkReachabilityStatusReachableViaWWAN = 1,//2G,3G,4G...
    AFNetworkReachabilityStatusReachableViaWiFi = 2,//wifi网络
    }
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2)设置网络监听&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        case AFNetworkReachabilityStatusUnknown:
            NSLog(@&amp;quot;未识别的网络&amp;quot;);
            break;

        case AFNetworkReachabilityStatusNotReachable:
            NSLog(@&amp;quot;不可达的网络(未连接)&amp;quot;);
            break;

        case AFNetworkReachabilityStatusReachableViaWWAN:
            NSLog(@&amp;quot;2G,3G,4G...的网络&amp;quot;);
            break;

        case AFNetworkReachabilityStatusReachableViaWiFi:
            NSLog(@&amp;quot;wifi的网络&amp;quot;);
            break;
        default:
            break;
    }
}];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-开始监听&quot;&gt;&lt;a href=&quot;#3-开始监听&quot; class=&quot;headerlink&quot; title=&quot;3.开始监听&quot;&gt;&lt;/a&gt;3.开始监听&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[manager startMonitoring];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建网络监听者管理者对象&quot;&gt;&lt;a href=&quot;#1-创建网络监听者管理者对象&quot; class=&quot;headerlink&quot; title=&quot;1.创建网络监听者管理者对象&quot;&gt;&lt;/a&gt;1.创建网络监听者管理者对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-设置监听&quot;&gt;&lt;a href=&quot;#2-设置监听&quot; class=&quot;headerlink&quot; title=&quot;2.设置监听&quot;&gt;&lt;/a&gt;2.设置监听&lt;/h3&gt;&lt;p&gt;1)网络状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//显然是枚举值
typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,//未识别的网络
    AFNetworkReachabilityStatusNotReachable     = 0,//不可达的网络
    AFNetworkReachabilityStatusReachableViaWWAN = 1,//2G,3G,4G...
    AFNetworkReachabilityStatusReachableViaWiFi = 2,//wifi网络
    }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>仿射变换(CGAffineTransform)使用小结</title>
    <link href="http://yoursite.com/2016/09/22/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2-CGAffineTransform-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/22/仿射变换-CGAffineTransform-使用小结/</id>
    <published>2016-09-22T14:28:02.000Z</published>
    <updated>2016-09-22T14:32:43.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;一、理论基础&lt;/h3&gt;&lt;p&gt;在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换(运用一次函数进行的变换)接上一个平移组成。&lt;/p&gt;
&lt;p&gt;CGAffineTransform简单分析（&lt;a href=&quot;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、射变换的种类&quot;&gt;&lt;a href=&quot;#二、射变换的种类&quot; class=&quot;headerlink&quot; title=&quot;二、射变换的种类&quot;&gt;&lt;/a&gt;二、射变换的种类&lt;/h3&gt;&lt;p&gt;1.自定义变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMake(1.0, 0, 0, 1.0, 20, 20);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.平移&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; x &amp;gt; 0 右边  x &amp;lt; 0 左边
 y &amp;gt; 0 下边  y &amp;lt; 0 上边 
 _demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeTranslation(100, -50);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.缩放      x 轴缩放 ， y 轴缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeScale(2, 0.5);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.旋转     angle &amp;gt; 0 顺时针 ， angle &amp;lt; 0逆时针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
   _demoView.transform = CGAffineTransformMakeRotation(20);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.旋转 ＋ 平移 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeRotation(20);
}];
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformTranslate(_demoView.transform, 150, 150);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.旋转 ＋ 缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeRotation(20);
    //        NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformIsIdentity(_demoView.transform));
}];
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformScale(_demoView.transform, 0.5, 2);
    //        NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformIsIdentity(_demoView.transform));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.相反 （逆旋转，逆移动等）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformInvert(CGAffineTransformMakeRotation(20));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.合并多个变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformConcat(CGAffineTransformMakeRotation(20), CGAffineTransformScale(_demoView.transform, 0.5, 2));
    NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformEqualToTransform(CGAffineTransformMakeRotation(20), CGAffineTransformScale(_demoView.transform, 0.5, 2)));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三、补充&quot;&gt;&lt;a href=&quot;#三、补充&quot; class=&quot;headerlink&quot; title=&quot;三、补充&quot;&gt;&lt;/a&gt;三、补充&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;CGAffineTransformIdentity ： 单位矩阵变换，一般用于仿射变换的初始化或者还原。
CGAffineTransformEqualToTransform(CGAffineTransform t1, CGAffineTransform t2) ： 判断两个变换矩阵是否相等
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2) ： 得到两个矩阵相加后得到的最终矩阵
CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform t) ： 某点通过矩阵变换之后的点
CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform t) ： 某个size通过矩阵变换之后的size
CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform t) ： 某个Rect通过矩阵变换之后的区域
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;一、理论基础&lt;/h3&gt;&lt;p&gt;在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换(运用一次函数进行的变换)接上一个平移组成。&lt;/p&gt;
&lt;p&gt;CGAffineTransform简单分析（&lt;a href=&quot;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&quot;&gt;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、射变换的种类&quot;&gt;&lt;a href=&quot;#二、射变换的种类&quot; class=&quot;headerlink&quot; title=&quot;二、射变换的种类&quot;&gt;&lt;/a&gt;二、射变换的种类&lt;/h3&gt;&lt;p&gt;1.自定义变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMake(1.0, 0, 0, 1.0, 20, 20);
}];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>property在声明中可以指定的属性</title>
    <link href="http://yoursite.com/2016/09/11/property%E5%9C%A8%E5%A3%B0%E6%98%8E%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/11/property在声明中可以指定的属性/</id>
    <published>2016-09-11T14:18:58.000Z</published>
    <updated>2016-09-11T14:34:54.000Z</updated>
    
    <content type="html">&lt;p&gt;assign, retain, strong, weak, unsafe_unretained, copy &lt;/p&gt;
&lt;p&gt;这些都是一个property在声明中可以指定的属性，且都与内存管理有关。下面会从Non-ARC和ARC两种情况讨论一下这些属性的意义。&lt;/p&gt;
&lt;h3 id=&quot;Non-ARC&quot;&gt;&lt;a href=&quot;#Non-ARC&quot; class=&quot;headerlink&quot; title=&quot;Non-ARC&quot;&gt;&lt;/a&gt;Non-ARC&lt;/h3&gt;&lt;p&gt;从官方文档的描述上看，Non-ARC的内存管理模式下，编译器会为带有不同属性的property自动生成对应的accessor方法。并且苹果十分建议在可能的情况下通过accessor方法来操纵property，而不是操纵它对应的实例变量。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;assign&quot;&gt;&lt;a href=&quot;#assign&quot; class=&quot;headerlink&quot; title=&quot;assign&quot;&gt;&lt;/a&gt;assign&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在Non-ARC内存管理模式下，assign是一个property的默认属性，无论这个property代表一个简单数据类型，还是一个指向对象的指针
也就是说：

@property (nonatomic) NSNumber *count;
等价于：

@property (nonatomic, assign) NSNumber *count;

assign主要应用于代表简单数据类型的property，比如int，float等。
如果这个用assign属性修饰的property代表一个指向对象的指针，那么当这个指针指向某个对象时，这个对象的引用计数不应该被改变。
也就是说，用assign属性修饰的property，不应该持有一个对象。
因为这个property不持有对象，所以它所指向的对象很可能已经在别处被释放了。这时它就有可能成为一枚悬垂指针，访问它指向的内存地址时，可能会发生意想不到的状况。


retain

retain不能修饰用来代表简单数据类型的property，否则编译器会报错：

@property (nonatomic, retain) int num;//编译器报错：Property with &amp;apos;retain (or strong)&amp;apos; attribute must be of object type
如果一个property被retain修饰，这代表着这个property应该持有它所指向的对象。
官方文档中展示了一个被retain修饰的property：

@property (nonatomic, retain) NSNumber *count;

编译器可能为它实现的accessor方法：

- (NSNumber *)count {
    return _count;
}
- (void)setCount:(NSNumber *)newCount {
    [newCount retain];
    [_count release];
    // Make the new assignment.
    _count = newCount;
}

注意，考虑到newCount和_count可能指向同一个对象，所以在setter方法中，必须首先调用retain，以防这个对象被释放。


 copy

copy也不能修饰用来代表简单数据类型的property，否则编译器会报错：

    @property (nonatomic, copy) int num;//编译器报错：Property with &amp;apos;copy&amp;apos; attribute must be of object type

如果一个property被copy修饰，那么赋值到这个property的对象，应该是原有对象的一份拷贝。
只有实现了NSCopying协议，并且实现了其中的copyWithZone:方法的对象才能被拷贝。
但是并不是所有的拷贝都产生了新的对象，有些类在实现copyWithZone:方法时，有着它们自己的考虑。比如NSString：

    @property (nonatomic, copy) NSString *myString;
    NSString *string = [[NSString alloc] initWithString:@&amp;quot;Hello&amp;quot;];
    self.myString = string;
    NSLog(@&amp;quot;%d&amp;quot;, string == _myString);//输出1

在这里，property的指针和原先的指针指向的是同一个地址。

unsafe_unretained

人认为unsafe_unretained与assign是等价的。


strong

个人认为strong与retain是等价的。
官方文档中有这样的示例代码：

// The following declaration is a synonym for: @property(retain) MyClass *myObject;
@property(strong) MyClass *myObject;

表示了strong和retain是同义词。


weak

Non-ARC内存管理模式下无法使用weak来修饰一个property，编译器会报错。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ARC有效时，对象类型的变量将有所有权修饰符来修饰。一共有以下四种所有权修饰符：

__strong 修饰符
__weak 修饰符
__unsafe_unretained 修饰符
__autoreleasing 修饰符

四种修饰符的具体意思，就不在这里解释了(´･_･`)

编译器在为一个property合成实例变量时，也会使用所有权修饰符来修饰这个实例变量。根据property属性的不同，用来修饰实例变量的所有权修饰符也不尽相同。


strong

在ARC内存管理模式下，strong是一个代表对象类型的property的默认属性，并且它不能修饰用来代表简单数据类型的property。
编译器在合成实例变量时，将使用__strong修饰符。
如果另外自定义了用其他修饰符修饰的实例变量，编译器会报错。可以用这个方法来验证property的各个属性对应的实例变量的所有权修饰符。

@interface ViewController ()
{
    __weak NSObject *_obj;//编译器报错：Existing instance variable &amp;apos;_obj&amp;apos; for strong property &amp;apos;obj&amp;apos; may not be weak
}

@property (nonatomic, strong) NSObject *obj;

@end


weak

weak也不能修饰用来代表简单数据类型的property。
编译器将为weak修饰的property生成带__weak所有权修饰符的实例变量。

copy

copy也不能修饰用来代表简单数据类型的property。
编译器将为copy修饰的property生成带__strong所有权修饰符的实例变量。
编译器自动合成的setter方法会调用对象的copyWithZone:方法。虽然第三方程序员可以自定义setter方法，但是为了程序的可读性，
也应该在其中执行拷贝的逻辑。

retain

和Non-ARC的理由一样，个人认为retain和strong是等价的。

unsafe_unretained

编译器将为unsafe_unretained修饰的property生成带__unsafe_unretained所有权修饰符的实例变量。
与weak和strong不同的是，unsafe_unretained也可以修饰代表简单数据类型的property。

assign

个人认为assign和unsafe_unretained等价。
assign在ARC内存管理模式下，仍然是代表简单数据类型的property的默认属性。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;assign, retain, strong, weak, unsafe_unretained, copy &lt;/p&gt;
&lt;p&gt;这些都是一个property在声明中可以指定的属性，且都与内存管理有关。下面会从Non-ARC和ARC两种情况讨论一下这些属性的意义。&lt;/p&gt;
&lt;h3 id=&quot;Non-ARC&quot;&gt;&lt;a href=&quot;#Non-ARC&quot; class=&quot;headerlink&quot; title=&quot;Non-ARC&quot;&gt;&lt;/a&gt;Non-ARC&lt;/h3&gt;&lt;p&gt;从官方文档的描述上看，Non-ARC的内存管理模式下，编译器会为带有不同属性的property自动生成对应的accessor方法。并且苹果十分建议在可能的情况下通过accessor方法来操纵property，而不是操纵它对应的实例变量。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代理设计模式</title>
    <link href="http://yoursite.com/2016/08/28/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/28/代理设计模式/</id>
    <published>2016-08-28T11:56:17.000Z</published>
    <updated>2016-08-28T12:00:01.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;代理delegate就是委托另一个对象来帮忙完成一件事情&lt;/p&gt;
&lt;p&gt;为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如 View 对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是 Controller 的责任，所以此时 View 就应该将这个功能委托给 Controller 去实现，当然你作为码农强行让 View 处理数据逻辑的任务，也不是不行，只是这就违背了 MVC 设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;场景描述如下：TableView 上面有多个 CustomTableViewCell，cell上面显示的是文字信息和一个详情Button，点击button以后push到一个新的页面。为什么说这个场景用到了代理delegate？因为button是在自定义的CustomTableViewCell上面，而cell没有能力实现push的功能，因为push到新页面的代码是这样的，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.navigationController pushViewController...];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以这时候 CustomTableViewCell 就要委托它所在的 Controller 去做这件事情了。&lt;/p&gt;
&lt;h3 id=&quot;代码使用&quot;&gt;&lt;a href=&quot;#代码使用&quot; class=&quot;headerlink&quot; title=&quot;代码使用&quot;&gt;&lt;/a&gt;代码使用&lt;/h3&gt;&lt;p&gt;1.在任意的一个头文件里面编写委托的协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@protocol CustomCellDelegate &amp;lt;NSObject&amp;gt;

 - (void)pushToNewPage;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.在想要发出这份委托的头文件添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface CustomTableViewCell : UITableViewCell

@property(nonatomic, assign) id&amp;lt;CustomCellDelegate&amp;gt; delegate;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.在委托者的 .m 文件的某个需要调用协议方法的方法中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)btnClicked:(UIButton *)btn {

    if (self.delegate &amp;amp;&amp;amp; [self.delegaterespondsToSelector:@selector(pushToNewPage)]) {

      [self.delegate pushToNewPage];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.在受到委托申请的类的头部中添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ViewController ()&amp;lt;CustomCellDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.在然后是委托申请的类中实现CustomCellDelegate协议中的pushToNewPage方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)pushToNewPage {

    DetailViewController*detailVC = [[DetailViewController alloc] init];
    [self.navigationController pushViewController:detailVC animated:YES];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.最后设置CumtomTableViewCell对象cell的delegate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//下面代码很关键
cell.delegate = self;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结：委托的协议可以写在任何的头文件中，代理设计模式的六个步骤缺一不可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;代理delegate就是委托另一个对象来帮忙完成一件事情&lt;/p&gt;
&lt;p&gt;为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如 View 对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是 Controller 的责任，所以此时 View 就应该将这个功能委托给 Controller 去实现，当然你作为码农强行让 View 处理数据逻辑的任务，也不是不行，只是这就违背了 MVC 设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios技能点总结和存取方法</title>
    <link href="http://yoursite.com/2016/08/28/ios%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/28/ios技能点总结和存取方法/</id>
    <published>2016-08-28T11:45:40.000Z</published>
    <updated>2016-08-28T11:52:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;a href=&quot;#存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot; class=&quot;headerlink&quot; title=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;/a&gt;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&lt;/h3&gt;&lt;p&gt;在Cocoa的术语中，一个检索对象属性值的方法提及为getter方法，或者”getter;”，一个改变对象属性值的方法提及为setter方法，或者“setter.”这些方法通常成对建立，提供获得或者设置对象属性值的API。&lt;/p&gt;
&lt;p&gt;我们应该使用存储方法而不是直接存储状态数据因为他们提供了一个抽象的层。下面是存储方法所提供的两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们不需要重写我们的代码如果一个描述或者存储属性的方法改变。&lt;/li&gt;
&lt;li&gt;存储方法常常实现重要行为是无论何时一个值被检索或者设置都会被重现。例如，设置方法频繁的实现内存管理代码并且通知其他对象当一个值被改变的时候。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h3&gt;&lt;p&gt;给出一个属性的类型type和称呼name，我们应该通过下面的格式，典型的实现存储方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(type)name;
-(void)setName:(type)newName;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有个例外是属性为Boolean值。getter方法名字应该是isName。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(BOOL)isHidden;
-(void)setHidden:(BOOL)newHidden;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种命名惯例很重要因为在Cocoa中的很多其他的功能都依赖它，特别的key-value coding。Cocoa不使用getName因为以get开始的方法表明方法返回引用类型的值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) 报错：__NSCFString containsString:]: unrecognized selector sent to instance 0x7f876b79e160&lt;/p&gt;
&lt;p&gt; 原因：因为该属性提前释放了。&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) 报错：This application is modifying the autolayout engine from a background thread&lt;/p&gt;
&lt;p&gt;原因：把需要更新UI的放在的主线程就好了。（通过打印 [NSThreadcurrentThread],就可以知道当前不是在主线程;&lt;/p&gt;
&lt;p&gt; NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:@”value1”, @”key1”, @”value2”, @”key2”, nil];&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) Dealloc 时取 weak self 时崩溃  （&lt;a href=&quot;http://blog.csdn.net/kaihaodir/article/details/51586616）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kaihaodir/article/details/51586616）&lt;/a&gt;&lt;br&gt;    先上引起崩溃的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc
{
    __weak __typeof(self)weak_self = self;
    NSLog(@&amp;quot;%@&amp;quot;, weak_self);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明不允许在 dealloc 的时候取 weak self.&lt;/p&gt;
&lt;h3 id=&quot;获取当前年份和月份和天数&quot;&gt;&lt;a href=&quot;#获取当前年份和月份和天数&quot; class=&quot;headerlink&quot; title=&quot;获取当前年份和月份和天数&quot;&gt;&lt;/a&gt;获取当前年份和月份和天数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSCalendar *calendar = [NSCalendar currentCalendar];
unsigned unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit |  NSDayCalendarUnit;
NSDateComponents *components = [calendar components:unitFlags fromDate:[NSDate date]];
NSInteger iCurYear = [components year];  //当前的年份
NSInteger iCurMonth = [components month];  //当前的月份
NSInteger iCurDay = [components day];  // 当前的号数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;根据传入的年份和月份获得该月份的天数&quot;&gt;&lt;a href=&quot;#根据传入的年份和月份获得该月份的天数&quot; class=&quot;headerlink&quot; title=&quot;根据传入的年份和月份获得该月份的天数&quot;&gt;&lt;/a&gt;根据传入的年份和月份获得该月份的天数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**  
 * 根据传入的年份和月份获得该月份的天数  
 *   
 * @param year  
 *            年份-正整数  
 * @param month  
 *            月份-正整数  
 * @return 返回天数  
 */    
public int getDayNumber(int year, int month) {    
    int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };    
    if (2 == month &amp;amp;&amp;amp; 0 == (year % 4) &amp;amp;&amp;amp; (0 != (year % 100) || 0 == (year % 400))) {    
        days[1] = 29;    
    }    
    return (days[month - 1]);    
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;a href=&quot;#存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot; class=&quot;headerlink&quot; title=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;/a&gt;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&lt;/h3&gt;&lt;p&gt;在Cocoa的术语中，一个检索对象属性值的方法提及为getter方法，或者”getter;”，一个改变对象属性值的方法提及为setter方法，或者“setter.”这些方法通常成对建立，提供获得或者设置对象属性值的API。&lt;/p&gt;
&lt;p&gt;我们应该使用存储方法而不是直接存储状态数据因为他们提供了一个抽象的层。下面是存储方法所提供的两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们不需要重写我们的代码如果一个描述或者存储属性的方法改变。&lt;/li&gt;
&lt;li&gt;存储方法常常实现重要行为是无论何时一个值被检索或者设置都会被重现。例如，设置方法频繁的实现内存管理代码并且通知其他对象当一个值被改变的时候。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block的使用</title>
    <link href="http://yoursite.com/2016/08/28/block%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/08/28/block的使用/</id>
    <published>2016-08-28T11:40:33.000Z</published>
    <updated>2016-08-28T11:42:30.000Z</updated>
    
    <content type="html">&lt;p&gt;Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了.&lt;/p&gt;
&lt;h3 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;h4 id=&quot;As-a-local-variable&quot;&gt;&lt;a href=&quot;#As-a-local-variable&quot; class=&quot;headerlink&quot; title=&quot;As a local variable:&quot;&gt;&lt;/a&gt;As a local variable:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;As-a-property&quot;&gt;&lt;a href=&quot;#As-a-property&quot; class=&quot;headerlink&quot; title=&quot;As a property:&quot;&gt;&lt;/a&gt;As a property:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-a-method-parameter&quot;&gt;&lt;a href=&quot;#As-a-method-parameter&quot; class=&quot;headerlink&quot; title=&quot;As a method parameter:&quot;&gt;&lt;/a&gt;As a method parameter:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-an-argument-to-a-method-call&quot;&gt;&lt;a href=&quot;#As-an-argument-to-a-method-call&quot; class=&quot;headerlink&quot; title=&quot;As an argument to a method call:&quot;&gt;&lt;/a&gt;As an argument to a method call:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-a-typedef&quot;&gt;&lt;a href=&quot;#As-a-typedef&quot; class=&quot;headerlink&quot; title=&quot;As a typedef:&quot;&gt;&lt;/a&gt;As a typedef:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;typedef returnType (^TypeName)(parameterTypes);
TypeName blockName = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
@interface ViewController ()

@property (nonatomic, assign) void (^block)(NSString *);

@end

typedef void (^block)(NSString *);
typedef NSString *(^block2)(NSString *);

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    int (^num)(int) = ^(int a) {

        return a * 6;
    };
    NSLog(@&amp;quot;%d&amp;quot;, num(5));

    block b = ^(NSString *string) {

        NSLog(@&amp;quot;%@&amp;quot;, string);
    };
    b(@&amp;quot;4677646974&amp;quot;);

    block2 b2 = ^(NSString *string) {
        NSLog(@&amp;quot;%@&amp;quot;, string);
        return string;
    };
    NSLog(@&amp;quot;%@&amp;quot;, b2(@&amp;quot;456&amp;quot;));

    [self methodsBlock:^(NSString *block3) {

        NSLog(@&amp;quot;%@&amp;quot;, block3);
    }];

    [self methodsBlock2:^NSString *(NSString *block4) {

        NSLog(@&amp;quot;%@&amp;quot;, block4);
        return @&amp;quot;1&amp;quot;;
    }];
    NSLog(@&amp;quot;%@&amp;quot;, [self methodsBlock3:^NSString *(NSString *block5) {
        NSLog(@&amp;quot;%@&amp;quot;, block5);
        return @&amp;quot;2&amp;quot;;
    }]);

    int (^num2)(int, int, int, int, int, int, int) = ^(int a, int b, int c, int d, int e, int f, int g) {

        return a * b * c * d * e * f * g;
    };
    NSLog(@&amp;quot;num2 = %d&amp;quot;, num2(10, 2, 5, 1, 45, 4, 4));


}

- (void)methodsBlock:(void(^)(NSString *))block3 {

    block3(@&amp;quot;block3&amp;quot;);
}


- (void)methodsBlock2:(NSString *(^)(NSString *))block4 {

    block4(@&amp;quot;block4&amp;quot;);
    NSLog(@&amp;quot;%@&amp;quot;, block4(@&amp;quot;block4&amp;quot;));
}


- (NSString *)methodsBlock3:(NSString *(^ __nullable)(NSString *))block5 {

    block5(@&amp;quot;block5&amp;quot;);
    NSLog(@&amp;quot;block5 = %@&amp;quot;, block5(@&amp;quot;block5&amp;quot;));
    return @&amp;quot;block5&amp;quot;;
}
@end
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了.&lt;/p&gt;
&lt;h3 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;h4 id=&quot;As-a-local-variable&quot;&gt;&lt;a href=&quot;#As-a-local-variable&quot; class=&quot;headerlink&quot; title=&quot;As a local variable:&quot;&gt;&lt;/a&gt;As a local variable:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> 系统定位</title>
    <link href="http://yoursite.com/2016/08/28/%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2016/08/28/系统定位/</id>
    <published>2016-08-28T11:35:47.000Z</published>
    <updated>2016-08-28T11:37:19.000Z</updated>
    
    <content type="html">&lt;p&gt;首先导入CoreLocation.framework，然后再引入头文件#import&lt;/p&gt;
&lt;h3 id=&quot;定义属性&quot;&gt;&lt;a href=&quot;#定义属性&quot; class=&quot;headerlink&quot; title=&quot;定义属性&quot;&gt;&lt;/a&gt;定义属性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic , strong)CLLocationManager *locationManager;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;初始化定位服务&quot;&gt;&lt;a href=&quot;#初始化定位服务&quot; class=&quot;headerlink&quot; title=&quot;初始化定位服务&quot;&gt;&lt;/a&gt;初始化定位服务&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#pragma mark - 私有方法
///初始化定位服务
- (void)settupLocation
{
    self.locationManager = [[CLLocationManager alloc] init];
    self.locationManager.delegate = self;
    self.locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;

    if ([CLLocationManager locationServicesEnabled] &amp;amp;&amp;amp;
        [CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedWhenInUse) {
        //定位功能可用，开始定位
        [self.locationManager startUpdatingLocation];

    } else if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusNotDetermined) {
        //请求授权
        [self.locationManager requestWhenInUseAuthorization];

    } else if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied
              || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusRestricted){
    }
    if (self.schoolStr.length &amp;lt; 2) {
        // 开始定位
        [_locationManager startUpdatingLocation];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;然后使用代理-CLLocationManagerDelegate&quot;&gt;&lt;a href=&quot;#然后使用代理-CLLocationManagerDelegate&quot; class=&quot;headerlink&quot; title=&quot;然后使用代理 CLLocationManagerDelegate&quot;&gt;&lt;/a&gt;然后使用代理 CLLocationManagerDelegate&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#pragma mark - &amp;lt;CLLocationManagerDelegate&amp;gt;
///成功定位
- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&amp;lt;CLLocation *&amp;gt; *)locations
{
    //经纬度信息
    CLLocation *location = [locations lastObject];

    //反地理编码
    CLGeocoder *geocoder = [[CLGeocoder alloc] init];
    [geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&amp;lt;CLPlacemark *&amp;gt; * _Nullable placemarks, NSError * _Nullable error) {
        //编码成功
        if (!error &amp;amp;&amp;amp; placemarks.count &amp;gt; 0) {
            //获取地址对象
            CLPlacemark *address = placemarks.firstObject;
            //获取城市名称
            NSMutableString *city = [NSMutableString stringWithString:address.locality];
            if ([city containsString:@&amp;quot;市&amp;quot;]) {
                [city deleteCharactersInRange:[city rangeOfString: @&amp;quot;市&amp;quot;]];
            }
            //显示定位信息
            self.schoolStr = city;
            [self.tableView reloadData];
            //停止定位
            [self.locationManager stopUpdatingLocation];

        } else {
            //编码失败
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;在Info-plist文件中添加如下配置：&quot;&gt;&lt;a href=&quot;#在Info-plist文件中添加如下配置：&quot; class=&quot;headerlink&quot; title=&quot;在Info.plist文件中添加如下配置：&quot;&gt;&lt;/a&gt;在Info.plist文件中添加如下配置：&lt;/h3&gt;&lt;p&gt;（1）NSLocationAlwaysUsageDescription&lt;br&gt;（2）NSLocationWhenInUseUsageDescription&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先导入CoreLocation.framework，然后再引入头文件#import&lt;/p&gt;
&lt;h3 id=&quot;定义属性&quot;&gt;&lt;a href=&quot;#定义属性&quot; class=&quot;headerlink&quot; title=&quot;定义属性&quot;&gt;&lt;/a&gt;定义属性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic , strong)CLLocationManager *locationManager;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> initWithNibName 和 loadNibNamed 的区别和联系</title>
    <link href="http://yoursite.com/2016/08/13/initWithNibName-%E5%92%8C-loadNibNamed-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2016/08/13/initWithNibName-和-loadNibNamed-的区别和联系/</id>
    <published>2016-08-13T11:13:03.000Z</published>
    <updated>2016-08-13T11:14:02.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;联系&quot;&gt;&lt;a href=&quot;#联系&quot; class=&quot;headerlink&quot; title=&quot;联系&quot;&gt;&lt;/a&gt;联系&lt;/h3&gt;&lt;p&gt; 可以使用此方法加载用户界面（xib文件）到我们的代码中，这样，可以通过操作这个加载进来的（xib）对象，来操作xib文件内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h3&gt;&lt;p&gt;1.集成类不一样&lt;/p&gt;
&lt;p&gt;initWithNibName要加载的xib的类为我们定义的视图控制器类&lt;br&gt;loadNibNamed要加载的xib的类为NSOjbect&lt;/p&gt;
&lt;p&gt;2.加载方式不同&lt;/p&gt;
&lt;p&gt;initWithNibName方法：是延迟加载，这个View上的控件是 nil 的，只有到 需要显示时，才会不是 nil&lt;br&gt;loadNibNamed方法：即时加载，用该方法加载的xib对象中的各个元素都已经存在。&lt;/p&gt;
&lt;h3 id=&quot;获取想要的-view&quot;&gt;&lt;a href=&quot;#获取想要的-view&quot; class=&quot;headerlink&quot; title=&quot;获取想要的 view&quot;&gt;&lt;/a&gt;获取想要的 view&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSArray* nib = [[NSBundle mainBundle] loadNibNamed／@&amp;quot;CustomCell&amp;quot; owner:self options:nil];
for(id item in nib) {

    if([is isKindOfClass:[youview class]]) {

    //找到了你自己需要得view
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;联系&quot;&gt;&lt;a href=&quot;#联系&quot; class=&quot;headerlink&quot; title=&quot;联系&quot;&gt;&lt;/a&gt;联系&lt;/h3&gt;&lt;p&gt; 可以使用此方法加载用户界面（xib文件）到我们的代码中，这样，可以通过操作这个加载进来的（xib）对象，来操作xib文件内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通知iOS</title>
    <link href="http://yoursite.com/2016/08/13/%E9%80%9A%E7%9F%A5iOS/"/>
    <id>http://yoursite.com/2016/08/13/通知iOS/</id>
    <published>2016-08-13T11:07:36.000Z</published>
    <updated>2016-08-13T11:09:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;发送通知-（在程序任何一个地方都可以发送通知）&quot;&gt;&lt;a href=&quot;#发送通知-（在程序任何一个地方都可以发送通知）&quot; class=&quot;headerlink&quot; title=&quot;发送通知 （在程序任何一个地方都可以发送通知）&quot;&gt;&lt;/a&gt;发送通知 （在程序任何一个地方都可以发送通知）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)getNotofocation {
    //发出通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;A类通知&amp;quot; object:self userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;注册通知&quot;&gt;&lt;a href=&quot;#注册通知&quot; class=&quot;headerlink&quot; title=&quot;注册通知&quot;&gt;&lt;/a&gt;注册通知&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver: self selector: @selector(callBack) name: @&amp;quot;A类通知&amp;quot;  object: nil  userInfo: nil];

Name: 消息名称 
object: 消息发送者 
userInfo: 消息传递的数据信息
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;定义回调&quot;&gt;&lt;a href=&quot;#定义回调&quot; class=&quot;headerlink&quot; title=&quot;定义回调&quot;&gt;&lt;/a&gt;定义回调&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)callBack {

    NSLog(@&amp;quot;我收到通知了！&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注销通知&quot;&gt;&lt;a href=&quot;#注销通知&quot; class=&quot;headerlink&quot; title=&quot;注销通知&quot;&gt;&lt;/a&gt;注销通知&lt;/h3&gt;&lt;p&gt;   a. 最优的方法，在 UIViewController.m 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc {

 [[NSNotificationCenter defaultCenter] removeObserver:self];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   b. 单个移除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;Notification_GetUserProfileSuccess&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;发送通知-（在程序任何一个地方都可以发送通知）&quot;&gt;&lt;a href=&quot;#发送通知-（在程序任何一个地方都可以发送通知）&quot; class=&quot;headerlink&quot; title=&quot;发送通知 （在程序任何一个地方都可以发送通知）&quot;&gt;&lt;/a&gt;发送通知 （在程序任何一个地方都可以发送通知）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)getNotofocation {
    //发出通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;A类通知&amp;quot; object:self userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>控制器初始化方法</title>
    <link href="http://yoursite.com/2016/08/13/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/13/控制器初始化方法/</id>
    <published>2016-08-13T11:03:07.000Z</published>
    <updated>2016-08-13T11:06:34.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;控制器初始化方法&quot;&gt;&lt;a href=&quot;#控制器初始化方法&quot; class=&quot;headerlink&quot; title=&quot;控制器初始化方法&quot;&gt;&lt;/a&gt;控制器初始化方法&lt;/h3&gt;&lt;h4 id=&quot;viewWillAppear&quot;&gt;&lt;a href=&quot;#viewWillAppear&quot; class=&quot;headerlink&quot; title=&quot;viewWillAppear&quot;&gt;&lt;/a&gt;viewWillAppear&lt;/h4&gt;&lt;p&gt;视图即将可见时调用。默认情况下不执行任何操作。 Called when the view is about to made visible. Default does nothing&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;viewDidAppear&quot;&gt;&lt;a href=&quot;#viewDidAppear&quot; class=&quot;headerlink&quot; title=&quot;viewDidAppear&quot;&gt;&lt;/a&gt;viewDidAppear&lt;/h4&gt;&lt;p&gt;视图已完全过渡到屏幕上时调用。。默认情况下不执行任何操作。 Called when the view has been fully transitioned onto the screen. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewWillDisappear&quot;&gt;&lt;a href=&quot;#viewWillDisappear&quot; class=&quot;headerlink&quot; title=&quot;viewWillDisappear&quot;&gt;&lt;/a&gt;viewWillDisappear&lt;/h4&gt;&lt;p&gt;视图被消失时调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作。 Called when the view is dismissed, covered or otherwise hidden. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewDidDisappear&quot;&gt;&lt;a href=&quot;#viewDidDisappear&quot; class=&quot;headerlink&quot; title=&quot;viewDidDisappear&quot;&gt;&lt;/a&gt;viewDidDisappear&lt;/h4&gt;&lt;p&gt;视图被消失后调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作。 Called after the view was dismissed, covered or otherwise hidden. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewDidLoad&quot;&gt;&lt;a href=&quot;#viewDidLoad&quot; class=&quot;headerlink&quot; title=&quot;viewDidLoad&quot;&gt;&lt;/a&gt;viewDidLoad&lt;/h4&gt;&lt;p&gt;在视图加载后被调用，如果是在代码中创建的视图加载器，他将会在loadView方法后被调用，如果是从nib视图页面输出，他将会在视图设置好后后被调用。&lt;br&gt;Called after the view has been loaded. For view controllers created in code, this is after -loadView. For view controllers unarchived from a nib, this is after the view is set.&lt;/p&gt;
&lt;h4 id=&quot;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot;&gt;&lt;a href=&quot;#「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot; class=&quot;headerlink&quot; title=&quot;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot;&gt;&lt;/a&gt;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&lt;/h4&gt;&lt;h4 id=&quot;视图控制器发生旋转调用的方法&quot;&gt;&lt;a href=&quot;#视图控制器发生旋转调用的方法&quot; class=&quot;headerlink&quot; title=&quot;视图控制器发生旋转调用的方法&quot;&gt;&lt;/a&gt;视图控制器发生旋转调用的方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&amp;lt;UIViewControllerTransitionCoordinator&amp;gt;)coordinator {

     NSLog(@&amp;quot;%f&amp;quot;, size.height);
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;当一个视图控制器被创建，并在屏幕上显示的时候。-代码的执行顺序&quot;&gt;&lt;a href=&quot;#当一个视图控制器被创建，并在屏幕上显示的时候。-代码的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序&quot;&gt;&lt;/a&gt;当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、 alloc                   创建对象，分配空间

2、init (initWithNibName)    初始化对象，初始化数据

3、loadView                  从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图

4、viewDidLoad               载入完成，可以进行自定义数据以及动态创建其他控件

5、viewWillAppear            视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了

6、viewDidAppear             视图已在屏幕上渲染完成
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot;&gt;&lt;a href=&quot;#当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot; class=&quot;headerlink&quot; title=&quot;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot;&gt;&lt;/a&gt;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、viewWillDisappear          视图将被从屏幕上移除之前执行

2、viewDidDisappear           视图已经被从屏幕上移除，用户看不到这个视图了

3、dealloc                    视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;控制器初始化方法&quot;&gt;&lt;a href=&quot;#控制器初始化方法&quot; class=&quot;headerlink&quot; title=&quot;控制器初始化方法&quot;&gt;&lt;/a&gt;控制器初始化方法&lt;/h3&gt;&lt;h4 id=&quot;viewWillAppear&quot;&gt;&lt;a href=&quot;#viewWillAppear&quot; class=&quot;headerlink&quot; title=&quot;viewWillAppear&quot;&gt;&lt;/a&gt;viewWillAppear&lt;/h4&gt;&lt;p&gt;视图即将可见时调用。默认情况下不执行任何操作。 Called when the view is about to made visible. Default does nothing&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应者</title>
    <link href="http://yoursite.com/2016/08/07/%E5%93%8D%E5%BA%94%E8%80%85/"/>
    <id>http://yoursite.com/2016/08/07/响应者/</id>
    <published>2016-08-07T11:25:04.000Z</published>
    <updated>2016-08-07T11:27:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;响应者对象（Response-object）&quot;&gt;&lt;a href=&quot;#响应者对象（Response-object）&quot; class=&quot;headerlink&quot; title=&quot;响应者对象（Response object）&quot;&gt;&lt;/a&gt;响应者对象（Response object）&lt;/h3&gt;&lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一响应者（First-responder）&quot;&gt;&lt;a href=&quot;#第一响应者（First-responder）&quot; class=&quot;headerlink&quot; title=&quot;第一响应者（First responder）&quot;&gt;&lt;/a&gt;第一响应者（First responder）&lt;/h3&gt;&lt;p&gt;当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。&lt;/p&gt;
&lt;h3 id=&quot;响应者链（Responder-chain）&quot;&gt;&lt;a href=&quot;#响应者链（Responder-chain）&quot; class=&quot;headerlink&quot; title=&quot;响应者链（Responder chain）&quot;&gt;&lt;/a&gt;响应者链（Responder chain）&lt;/h3&gt;&lt;p&gt;响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件&lt;/p&gt;
&lt;h3 id=&quot;管理事件分发&quot;&gt;&lt;a href=&quot;#管理事件分发&quot; class=&quot;headerlink&quot; title=&quot;管理事件分发&quot;&gt;&lt;/a&gt;管理事件分发&lt;/h3&gt;&lt;p&gt;视图对触摸事件是否需要作处回应可以通过设置视图的userInteractionEnabled属性。默认状态为YES，如果设置为NO，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏（setHidden：YES）或者透明（alpha值为0）也不会收事件。不过这个属性只对视图有效，如果想要整个程序都步响应事件，可以调用UIApplication的beginIngnoringInteractionEvents方法来完全停止事件接收和分发。通过endIngnoringInteractionEvents方法来恢复让程序接收和分发事件。如果要让视图接收多点触摸，需要设置它的multipleTouchEnabled属性为YES，默认状态下这个属性值为NO，即视图默认不接收多点触摸。&lt;/p&gt;
&lt;h3 id=&quot;处理用户的触摸事件&quot;&gt;&lt;a href=&quot;#处理用户的触摸事件&quot; class=&quot;headerlink&quot; title=&quot;处理用户的触摸事件&quot;&gt;&lt;/a&gt;处理用户的触摸事件&lt;/h3&gt;&lt;p&gt;首先触摸的对象是视图，而视图的类UIView继承了UIRespnder类，但是要对事件作出处理，还需要重写UIResponder类中定义的事件处理函数。根据不通的触摸状态，程序会调用相应的处理函数，这些函数包括以下几个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;

当手指接触屏幕时，就会调用touchesBegan:withEvent方法；

当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；

当手指离开屏幕时，就会调用touchesEnded:withEvent方法；

当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。而这几个方法被调用时，正好对应了UITouch类中phase属性的4个枚举值。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的四个事件方法，在开发过程中并不要求全部实现，可以根据需要重写特定的方法。对于这4个方法，都有两个相同的参数：NSSet类型的touches和UIEvent类型的event。其中touches表示触摸产生的所有UITouch对象，而event表示特定的事件。因为UIEvent包含了整个触摸过程中所有的触摸对象，因此可以调用allTouches方法获取该事件内所有的触摸对象，也可以调用touchesForVIew：或者touchesForWindows：取出特定视图或者窗口上的触摸对象。在这几个事件中，都可以拿到触摸对象，然后根据其位置，状态，时间属性做逻辑处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;响应者对象（Response-object）&quot;&gt;&lt;a href=&quot;#响应者对象（Response-object）&quot; class=&quot;headerlink&quot; title=&quot;响应者对象（Response object）&quot;&gt;&lt;/a&gt;响应者对象（Response object）&lt;/h3&gt;&lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
