<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-20T06:09:55.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> 日期类的使用2</title>
    <link href="http://yoursite.com/2016/03/20/%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A82/"/>
    <id>http://yoursite.com/2016/03/20/日期类的使用2/</id>
    <published>2016-03-20T05:59:29.000Z</published>
    <updated>2016-03-20T06:09:55.000Z</updated>
    
    <content type="html">&lt;p&gt;接上一篇：&lt;a href=&quot;/2016/03/20/日期类的使用NSDate/&quot;&gt;日期类的使用NSDate&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;NSDateFormatter-的使用&quot;&gt;&lt;a href=&quot;#NSDateFormatter-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSDateFormatter 的使用&quot;&gt;&lt;/a&gt;NSDateFormatter 的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];

[dateFormatter setDateFormat:@&amp;quot;&amp;apos;公元前/后:&amp;apos;G  &amp;apos;年份:&amp;apos;u&amp;apos;=&amp;apos;yyyy&amp;apos;=&amp;apos;yy &amp;apos;季度:&amp;apos;q&amp;apos;=&amp;apos;qqq&amp;apos;=&amp;apos;qqqq &amp;apos;月份:&amp;apos;M&amp;apos;=&amp;apos;MMM&amp;apos;=&amp;apos;MMMM &amp;apos;今天是今年第几周:&amp;apos;w &amp;apos;今天是本月第几周:&amp;apos;W  &amp;apos;
今天是今天第几天:&amp;apos;D &amp;apos;今天是本月第几天:&amp;apos;d &amp;apos;星期:&amp;apos;c&amp;apos;=&amp;apos;ccc&amp;apos;=&amp;apos;cccc &amp;apos;上午/下午:&amp;apos;a &amp;apos;小时:&amp;apos;h&amp;apos;=&amp;apos;H &amp;apos;分钟:&amp;apos;m &amp;apos;秒:&amp;apos;s &amp;apos;毫秒:&amp;apos;SSS  &amp;apos;这一天已过多少毫秒:&amp;apos;A  &amp;apos;时区名称:&amp;apos;zzzz&amp;apos;=&amp;apos;vvvv &amp;apos;时区编号:&amp;apos;Z &amp;quot;];

 NSLog(@&amp;quot;%@&amp;quot;, [dateFormatter stringFromDate:[NSDate date]]);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;NSTimeZone-的使用&quot;&gt;&lt;a href=&quot;#NSTimeZone-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSTimeZone 的使用&quot;&gt;&lt;/a&gt;NSTimeZone 的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//系统时区
NSTimeZone *zone = [NSTimeZone systemTimeZone];
NSTimeZone *zone = [NSTimeZone defaultTimeZone];
NSTimeZone *localTime = [NSTimeZone localTimeZone];

NSData *data = [zone data];//转化成 二进制数据

NSString *addStr = [zone abbreviation];//获取时区的简写

NSInteger timeoff = [zone secondsFromGMT];   //获取时区的偏移量

NSDate *timeOffDate = [date dateByAddingTimeInterval:timeoff]; //附加时间

NSArray *zoneArrs = [NSTimeZone knownTimeZoneNames];    //获取时区的对应表
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇：&lt;a href=&quot;/2016/03/20/日期类的使用NSDate/&quot;&gt;日期类的使用NSDate&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;NSDateFormatter-的使用&quot;&gt;&lt;a href=&quot;#NSDateFormatter-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSDateFormatter 的使用&quot;&gt;&lt;/a&gt;NSDateFormatter 的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];

[dateFormatter setDateFormat:@&amp;quot;&amp;apos;公元前/后:&amp;apos;G  &amp;apos;年份:&amp;apos;u&amp;apos;=&amp;apos;yyyy&amp;apos;=&amp;apos;yy &amp;apos;季度:&amp;apos;q&amp;apos;=&amp;apos;qqq&amp;apos;=&amp;apos;qqqq &amp;apos;月份:&amp;apos;M&amp;apos;=&amp;apos;MMM&amp;apos;=&amp;apos;MMMM &amp;apos;今天是今年第几周:&amp;apos;w &amp;apos;今天是本月第几周:&amp;apos;W  &amp;apos;
今天是今天第几天:&amp;apos;D &amp;apos;今天是本月第几天:&amp;apos;d &amp;apos;星期:&amp;apos;c&amp;apos;=&amp;apos;ccc&amp;apos;=&amp;apos;cccc &amp;apos;上午/下午:&amp;apos;a &amp;apos;小时:&amp;apos;h&amp;apos;=&amp;apos;H &amp;apos;分钟:&amp;apos;m &amp;apos;秒:&amp;apos;s &amp;apos;毫秒:&amp;apos;SSS  &amp;apos;这一天已过多少毫秒:&amp;apos;A  &amp;apos;时区名称:&amp;apos;zzzz&amp;apos;=&amp;apos;vvvv &amp;apos;时区编号:&amp;apos;Z &amp;quot;];

 NSLog(@&amp;quot;%@&amp;quot;, [dateFormatter stringFromDate:[NSDate date]]);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="日期，时间" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%9F%EF%BC%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>日期类的使用NSDate</title>
    <link href="http://yoursite.com/2016/03/20/%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8NSDate/"/>
    <id>http://yoursite.com/2016/03/20/日期类的使用NSDate/</id>
    <published>2016-03-20T05:24:56.000Z</published>
    <updated>2016-03-20T06:08:29.000Z</updated>
    
    <content type="html">&lt;p&gt;日期类在需要记录时间的地方发挥着巨大的作用，也可以实时地获取程序使用的时间。配合 NSLocal ，NSDateFormatter 和 NSTimeZone 这几个类就可以涵盖所有的程序使用的时间日期的数据。&lt;br&gt;&lt;img src=&quot;/img/date.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初始化一个 NSDate 类可以使用工厂方法和实例方法：&lt;/p&gt;
&lt;h4 id=&quot;工厂方法&quot;&gt;&lt;a href=&quot;#工厂方法&quot; class=&quot;headerlink&quot; title=&quot;工厂方法&quot;&gt;&lt;/a&gt;工厂方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDate *time = [NSDate date]; //返回当前时间
NSDate *time = [NSDate dateWithTimeIntervalSinceNow:0.0]; //返回以当前时间为基准，然后过了secs秒的时间
NSDate *time = [NSDate dateWithTimeIntervalSince1970:100.0]; //返回以1970/01/01 GMT为基准，然后过了secs秒的时间
NSDate *time = [NSDate dateWithTimeIntervalSinceReferenceDate:100.0]; //返回以2001/01/01 GMT为基准，然后过了secs秒的时间
NSDate *time = [NSDate dateWithTimeInterval:100.0 sinceDate:time2]; //返回从某个时间之后过了多少秒
NSDate *time = [NSDate distantFuture];  //返回很多年以后的未来的某一天。
NSDate *time = [NSDate distantPast];    //返回很多年以前的某一天
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;实例方法&quot;&gt;&lt;a href=&quot;#实例方法&quot; class=&quot;headerlink&quot; title=&quot;实例方法&quot;&gt;&lt;/a&gt;实例方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDate *time = [[NSDate alloc] init]; //返回当前时间
NSDate *time = [[NSDate alloc] initWithTimeInterval:1000.0 sinceDate:time2]; //返回从某个时间之后过了多少秒
NSDate *time = [[NSDate alloc] initWithTimeIntervalSince1970:1000000000.0]; //返回以1970/01/01 GMT为基准，然后过了secs秒的时间
NSDate *time = [[NSDate alloc] initWithTimeIntervalSinceNow:100.0]; //返回以当前时间为基准，然后过了secs秒的时间
NSDate *time = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:1000000.0]; //返回以2001/01/01 GMT为基准，然后过了secs秒的时间
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;日期间的比较-获取两个时间的间隔&quot;&gt;&lt;a href=&quot;#日期间的比较-获取两个时间的间隔&quot; class=&quot;headerlink&quot; title=&quot;日期间的比较 /  获取两个时间的间隔&quot;&gt;&lt;/a&gt;日期间的比较 /  获取两个时间的间隔&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSLog(@&amp;quot;%d&amp;quot;, [time isEqualToDate:time2]);  //是否相等
NSLog(@&amp;quot;%@&amp;quot;, [time earlierDate:time2]);    //是否早于
NSLog(@&amp;quot;%@&amp;quot;, [time2 laterDate:time]);      //是否低于
NSLog(@&amp;quot;%ld&amp;quot;, [time2 compare:time]);       //排序时调用，返回 -1，0，1

NSLog(@&amp;quot;%f&amp;quot;, [time timeIntervalSinceDate:time2]); //time2之后与time间的间隔
NSLog(@&amp;quot;%f&amp;quot;, [time timeIntervalSince1970]);    //从1970年之后到time的间隔
NSLog(@&amp;quot;%F&amp;quot;, [time timeIntervalSinceNow]);    //从现在到time之间的时间间隔
NSLog(@&amp;quot;%f&amp;quot;, [time timeIntervalSinceReferenceDate]); //从以1970/01/01 GMT为基准到time的时间间隔
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;时间表示成字符串&quot;&gt;&lt;a href=&quot;#时间表示成字符串&quot; class=&quot;headerlink&quot; title=&quot;时间表示成字符串&quot;&gt;&lt;/a&gt;时间表示成字符串&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (NSString *)description; 以YYYY-MM-DD HH:MM:SS ±HHMM的格式表示时间。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSLocale-的用法&quot;&gt;&lt;a href=&quot;#NSLocale-的用法&quot; class=&quot;headerlink&quot; title=&quot;NSLocale 的用法&quot;&gt;&lt;/a&gt;NSLocale 的用法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSLocale *usLocale = [[NSLocale alloc] initWithLocaleIdentifier&amp;quot;en_US&amp;quot;]; // 根据本地标识符创建本地化对象

[NSLocale availableLocaleIdentifiers]; // 获取系统所有本地化标识符数组列表  

[[NSLocale currentLocale] localeIdentifier]; //获取当前系统设置语言的标识符

[NSLocale lineDirectionForLanguage:[[NSLocale currentLocale] objectForKey:NSLocaleLanguageCode]; //获取当前语言的排版方向和字符方向

[NSLocale preferredLanguages]; //获取用户的语言偏好设置列表 

[NSNotificationCenter defaultCenter] addObserver:self selector@selector(localChangedHandler)  name:NSCurrentLocaleDidChangeNotification object:nil];  // 监听用户本地化设置的消息

NSLocale *curLocal = [[NSLocale alloc]initWithLocaleIdentifier&amp;quot;zh-Hans&amp;quot;]; // 以本地化方式获取国际化信息的显示名称


// 设置固定的系统返回 语言数据
NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&amp;quot;zh&amp;quot;];
NSDateFormatter *secondDateFormatter = [[NSDateFormatter alloc] init];
[secondDateFormatter setDateFormat:@&amp;quot;cccc&amp;quot;];  
secondDateFormatter.locale = locale;
NSDate *date = [NSDate date];
NSLog(@&amp;quot;%@&amp;quot;, [secondDateFormatter stringFromDate:date]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;日期类在需要记录时间的地方发挥着巨大的作用，也可以实时地获取程序使用的时间。配合 NSLocal ，NSDateFormatter 和 NSTimeZone 这几个类就可以涵盖所有的程序使用的时间日期的数据。&lt;br&gt;&lt;img src=&quot;/img/date.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="日期，时间" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%9F%EF%BC%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>NSData 的使用</title>
    <link href="http://yoursite.com/2016/03/17/NSData-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/17/NSData-的使用/</id>
    <published>2016-03-17T14:01:55.000Z</published>
    <updated>2016-03-17T14:14:33.000Z</updated>
    
    <content type="html">&lt;p&gt;应该说在任何网络中，如何使用数据来传递信息，保存和读取信息，并将其变为可以产生价值的东西，而在计算机的世界里面除了0 和 1 ，我们眼中所见的东西在计算机眼里只不过是一堆 0 和 1 数据而已。那么在 iOS 里，又是如何进行数据间的转化的。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;初始化-NSData-类型的对象&quot;&gt;&lt;a href=&quot;#初始化-NSData-类型的对象&quot; class=&quot;headerlink&quot; title=&quot;初始化 NSData 类型的对象&quot;&gt;&lt;/a&gt;初始化 NSData 类型的对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//定义一个char类型的字符串  
const char * string = &amp;quot;Hi there ,this is a C string&amp;quot;; 

//建立缓冲区，把字符串添加进去  
NSData * data = [NSData dataWithBytes:string length:strlen(string)+1]; 

//获取APP根目录的方法
NSHomeDirectory()；

//返回 data 的数据长度
NSLog(@&amp;quot;%ld&amp;quot;, reader.length);


//返回data对象的首指针
NSLog(@&amp;quot;%s&amp;quot;, reader.bytes);


//获取data格式的数据
NSLog(@&amp;quot;%@&amp;quot;, reader.description);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSString-类型的数据与-NSData-类型之间的转化&quot;&gt;&lt;a href=&quot;#NSString-类型的数据与-NSData-类型之间的转化&quot; class=&quot;headerlink&quot; title=&quot;NSString 类型的数据与 NSData 类型之间的转化&quot;&gt;&lt;/a&gt;NSString 类型的数据与 NSData 类型之间的转化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString * str = @&amp;quot;hello, world!&amp;quot;;
NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding]; //NSString转换成NSData类型
NSString * newStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSData-与-UIImage&quot;&gt;&lt;a href=&quot;#NSData-与-UIImage&quot; class=&quot;headerlink&quot; title=&quot;NSData 与 UIImage&quot;&gt;&lt;/a&gt;NSData 与 UIImage&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//例：从本地文件沙盒中取图片并转换为NSData

NSString *path = [[NSBundle mainBundle] bundlePath];
NSString *name = [NSString stringWithFormat:@&amp;quot;ceshi.png&amp;quot;];
NSString *finalPath = [path stringByAppendingPathComponent:name];
NSData *imageData = [NSData dataWithContentsOfFile: finalPath];
UIImage *aimage = [UIImage imageWithData: imageData];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;base-64-编码解码&quot;&gt;&lt;a href=&quot;#base-64-编码解码&quot; class=&quot;headerlink&quot; title=&quot;base 64 编码解码&quot;&gt;&lt;/a&gt;base 64 编码解码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;编码：

NSString * stringExample = [NSString stringWithFormat:@&amp;quot;I Love You&amp;quot;];
NSData * data1 = [stringExample dataUsingEncoding:NSUTF8StringEncoding];
NSString * base64String = [data1 base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn]; 

解码：

NSData * dataFromString = [[NSData alloc] initWithBase64EncodedString:base64String options:NSDataBase64DecodingIgnoreUnknownCharacters];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;文件保存和读取&quot;&gt;&lt;a href=&quot;#文件保存和读取&quot; class=&quot;headerlink&quot; title=&quot;文件保存和读取&quot;&gt;&lt;/a&gt;文件保存和读取&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; //定义一个字符串，保存一个路径  
NSString * path = @&amp;quot;/tmp/ver.txt&amp;quot;; 

//把这个保存路径的字符串保存到另一个文件中  encoding是编码  
[path writeToFile:@&amp;quot;/tmp/string.txt&amp;quot; atomically:YES encoding:NSASCIIStringEncoding error:nil];


//创建文件管理器     
NSFileManager * fm = [NSFileManager defaultManager]; 

//创建缓冲区，利用NSFileManager对象来获取文件中的内容，也就是这个文件的属性可修改  
NSData * fileData = [fm contentsAtPath:@&amp;quot;/tmp/ver.txt&amp;quot;];   

//获取上面fileData对象中通过NSFileManager对象获取的文件中的内容，然后再创建一个新的路径，并存储  
[fm createFileAtPath:@&amp;quot;/tmp/test4.txt&amp;quot; contents:fileData attributes:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;可修改的数据存储器-NSMutableData&quot;&gt;&lt;a href=&quot;#可修改的数据存储器-NSMutableData&quot; class=&quot;headerlink&quot; title=&quot;可修改的数据存储器 NSMutableData&quot;&gt;&lt;/a&gt;可修改的数据存储器 NSMutableData&lt;/h3&gt;&lt;p&gt;   创建的方式： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *path = @&amp;quot;/Users/Allen/Desktop/test.dat&amp;quot;;
NSString *temp = @&amp;quot;Jarod Yv&amp;quot;;
int i = 100;
float f = 98.3333f; 

NSMutableData *writer = [[NSMutableData alloc] init];

[writer appendData:[temp dataUsingEncoding:NSUTF8StringEncoding]];
[writer appendBytes:&amp;amp;i length:sizeof(i)];
[writer appendBytes:&amp;amp;f length:sizeof(f)];

[writer writeToFile:path atomically:YES]; 

读取：     
int ii; 
float ff;
NSData *reader = [NSData dataWithContentsOfFile:path];

NSString *ttemp = [[NSString alloc] initWithData:[reader subdataWithRange:NSMakeRange(0, [temp length])]encoding:NSUTF8StringEncoding];

[reader getBytes:&amp;amp;ii range:NSMakeRange([temp length], sizeof(ii))];
[reader getBytes:&amp;amp;ff range:NSMakeRange([temp length] + sizeof(ii), sizeof(ff))]; 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;应该说在任何网络中，如何使用数据来传递信息，保存和读取信息，并将其变为可以产生价值的东西，而在计算机的世界里面除了0 和 1 ，我们眼中所见的东西在计算机眼里只不过是一堆 0 和 1 数据而已。那么在 iOS 里，又是如何进行数据间的转化的。
    
    </summary>
    
    
      <category term="［数据］" scheme="http://yoursite.com/tags/%EF%BC%BB%E6%95%B0%E6%8D%AE%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation和NSOperationQueue多线程的使用</title>
    <link href="http://yoursite.com/2016/03/17/NSOperation%E5%92%8CNSOperationQueue%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/17/NSOperation和NSOperationQueue多线程的使用/</id>
    <published>2016-03-17T11:37:41.000Z</published>
    <updated>2016-03-17T12:10:41.000Z</updated>
    
    <content type="html">&lt;p&gt; 最近学习了多线程编程 NSOperationQueue ，才比较清楚的明白了&lt;strong&gt;同步／异步&lt;/strong&gt;，&lt;strong&gt;阻塞／非阻塞&lt;/strong&gt;所表达的不同含义：所谓的同步／异步是对你得到消息的方式的描述，而阻塞／非阻塞则是你怎么样处理事情的做法，他们讲述的是不同层面的概念。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  现在来讲述一下可以实现多线程的三种方式中的 NSOperation 类。使用NSOperation和NSOperationQueue实现多线程编程，实现步骤大致是这样的：&lt;/p&gt;
&lt;p&gt;  1&amp;gt; 先将需要执行的操作封装到一个NSOperation对象中&lt;/p&gt;
&lt;p&gt;  2&amp;gt; 然后将NSOperation对象添加到NSOperationQueue中&lt;/p&gt;
&lt;p&gt;  3&amp;gt; 系统会自动将NSOperation中封装的操作放到一条新线程中执行&lt;/p&gt;
&lt;p&gt;  而由于  NSOperation 是一个抽象类，所以它的功能只能有其子类 NSBlockOperation 和 SInvocationOperation 来实现。&lt;/p&gt;
&lt;h4 id=&quot;NSBlockOperation-的使用&quot;&gt;&lt;a href=&quot;#NSBlockOperation-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSBlockOperation 的使用&quot;&gt;&lt;/a&gt;NSBlockOperation 的使用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt; NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){     
    NSLog(@&amp;quot;*执行第1次操作，线程：%@&amp;quot;, [NSThread currentThread]);       
   }];

[operation addExecutionBlock:^() {

   NSLog(@&amp;quot;**又执行了1个新的操作，线程：%@&amp;quot;, [NSThread currentThread]);

   }];

// 开始执行任务    
[operation start];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   注：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。&lt;/p&gt;
&lt;h4 id=&quot;NSInvocationOperation-的使用&quot;&gt;&lt;a href=&quot;#NSInvocationOperation-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSInvocationOperation 的使用&quot;&gt;&lt;/a&gt;NSInvocationOperation 的使用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ration2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downLoadImage:) object:URL];
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:operation2];

如果是有刷新界面的操作，那么必须将这个操作交给主线程来完成。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义-NSOperation-类&quot;&gt;&lt;a href=&quot;#自定义-NSOperation-类&quot; class=&quot;headerlink&quot; title=&quot;自定义 NSOperation 类&quot;&gt;&lt;/a&gt;自定义 NSOperation 类&lt;/h3&gt;&lt;p&gt;由于 NSOperation 类功能比较少， 一般情况下我们可以自定义一个 NSOperation 类。要定制这样的一个操作，可以遵循以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承 NSOperation 类&lt;/li&gt;
&lt;li&gt;重写“main”方法&lt;/li&gt;
&lt;li&gt;在“main”方法中创建一个“automaticreleasepool“&lt;/li&gt;
&lt;li&gt;将你的代码放在”autoreleasepool“中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  例子：&lt;br&gt;     &lt;em&gt;*&lt;/em&gt; .h 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface MyLengthyOperation : NSOperation
@property (nonatomic, strong, readonly) NSString *mark;
- (instancetype)initWithMark:(NSString *)mark;
@end 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;em&gt;*&lt;/em&gt; .m 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;MyLengthyOperation.h&amp;quot;
@interface MyLengthyOperation ()
@property (nonatomic, strong, readwrite) NSString *mark;
@end
@implementation MyLengthyOperation
- (instancetype)initWithMark:(NSString *)mark {  
   self = [super init];
   if (self) {      
       self.mark = mark;
    }
   return self;
   }
- (void)main {
    @autoreleasepool {
      for (int i = 0; i &amp;lt; 100; i ++) {
         if (self.isCancelled) {
             break;
         }
         NSLog(@&amp;quot;%@ - %f&amp;quot;, self.mark, sqrt(i));
        }
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//  初始化任务 
MyLengthyOperation *operation_1 = [[MyLengthyOperation alloc] initWithMark:@&amp;quot;operation_1&amp;quot;];
MyLengthyOperation *operation_2 = [[MyLengthyOperation alloc] initWithMark:@&amp;quot;operation_2&amp;quot;];

// 设置任务的优先级
[operation_1 setQueuePriority:NSOperationQueuePriorityVeryLow];
[operation_2 setQueuePriority:NSOperationQueuePriorityHigh];

// 添加从属关系
[operation_2 addDependency:operation_1]; （任务2在任务1结束后才会执行）

// 初始化队列
NSOperationQueue *myQueue = [[NSOperationQueue alloc] init];
myQueue.name = @&amp;quot;下载队列&amp;quot;;

// 将一个简单的任务队列添加进队列中 （使用 Block 回调方式）      
    NSURL *aURL = [NSURL URLWithString:URL];
    NSData *data = [NSData dataWithContentsOfURL:aURL];

    [[NSOperationQueue mainQueue] addOperationWithBlock:^{

        UIImage *image = [[UIImage alloc] initWithData:data];
        [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];
    }];
}];

// 设置任务队列的最大并发数
 myQueue.maxConcurrentOperationCount = 4;

// 添加进任务队列中执行
[myQueue addOperation:operation_1];
[myQueue addOperation:operation_2];

// 取消所有操作
[myQueue cancelAllOperations];

// 执行延时的操作（将执行代码放置在 block 中）
- (void)execute:(dispatch_block_t)block afterDelay:(int64_t)delta {

   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delta), dispatch_get_main_queue(), block);
 }

// 挂起操作
[myQueue setSuspended:YES];

// 取消任务
[operation_1 cancel];

//  任务完成后的回调可以表示任务已经结束
 [operation_1 setCompletionBlock:^{
      NSLog(@&amp;quot;任务1结束&amp;quot;);
  }];
 [operation_2 setCompletionBlock:^{
      NSLog(@&amp;quot;任务2结束&amp;quot;);
 }];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt; 最近学习了多线程编程 NSOperationQueue ，才比较清楚的明白了&lt;strong&gt;同步／异步&lt;/strong&gt;，&lt;strong&gt;阻塞／非阻塞&lt;/strong&gt;所表达的不同含义：所谓的同步／异步是对你得到消息的方式的描述，而阻塞／非阻塞则是你怎么样处理事情的做法，他们讲述的是不同层面的概念。
    
    </summary>
    
    
      <category term="［博客］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%8D%9A%E5%AE%A2%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>NSURLConnection 基本使用</title>
    <link href="http://yoursite.com/2016/03/15/NSURLConnection-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/15/NSURLConnection-基本使用/</id>
    <published>2016-03-15T13:38:59.000Z</published>
    <updated>2016-03-15T13:57:04.000Z</updated>
    
    <content type="html">&lt;p&gt;现如今大部分的网络请求都是使用 NSURLConnection 这个类来完成，那么了解这个类对网络数据请求来说就至关重要的。&lt;/p&gt;
&lt;h3 id=&quot;NSURLConnection-的常用类&quot;&gt;&lt;a href=&quot;#NSURLConnection-的常用类&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection 的常用类&quot;&gt;&lt;/a&gt;NSURLConnection 的常用类&lt;/h3&gt;&lt;p&gt;· NSURL ：请求地址&lt;/p&gt;
&lt;p&gt;· NSURLRequest ：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体….&lt;/p&gt;
&lt;p&gt;· NSMutableRequest ：NSURLRequest 的子类&lt;/p&gt;
&lt;p&gt;· NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;NSURLConnection的使用&quot;&gt;&lt;a href=&quot;#NSURLConnection的使用&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection的使用&quot;&gt;&lt;/a&gt;NSURLConnection的使用&lt;/h3&gt;&lt;p&gt;使用 NSURLConnection 这个类的步骤主要有三个：&lt;/p&gt;
&lt;p&gt;1）创建一个NSURL对象，设置请求路径（设置请求路径）&lt;/p&gt;
&lt;p&gt;2）传入NSURL创建一个NSURLRequest对象，设置请求头和请求体（创建请求对象）&lt;/p&gt;
&lt;p&gt;3）使用NSURLConnection发送NSURLRequest（发送请求）&lt;/p&gt;
&lt;p&gt;在请求数据的过程中根据连接服务器的方式分为&lt;strong&gt;同步请求&lt;/strong&gt;和&lt;strong&gt;异步请求&lt;/strong&gt;这两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;NSData *data=[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;－ 使用 block 回调&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSOperationQueue *queue=[NSOperationQueue mainQueue];
[NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) { }];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;－ 代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSURLConnection *conn=[NSURLConnection connectionWithRequest:request delegate:self];
[conn start];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在NSURLConnectionDataDelegate代理方法里面执行事件。&lt;/p&gt;
&lt;h3 id=&quot;NSMutableURLRequest-的妙用&quot;&gt;&lt;a href=&quot;#NSMutableURLRequest-的妙用&quot; class=&quot;headerlink&quot; title=&quot;NSMutableURLRequest 的妙用&quot;&gt;&lt;/a&gt;NSMutableURLRequest 的妙用&lt;/h3&gt;&lt;p&gt;NSMutableURLRequest是NSURLRequest的子类，常用方法有&lt;/p&gt;
&lt;p&gt;－ 设置请求超时等待时间（超过这个时间就算超时，请求失败）- (void)setTimeoutInterval:(NSTimeInterval)seconds;&lt;br&gt;－ 设置请求方法（比如GET和POST）- (void)setHTTPMethod:(NSString &lt;em&gt;)method;&lt;br&gt;－ 设置请求体 - (void)setHTTPBody:(NSData &lt;/em&gt;)data;&lt;br&gt;－ 设置请求头 - (void)setValue:(NSString &lt;em&gt;)value forHTTPHeaderField:(NSString &lt;/em&gt;)field;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现如今大部分的网络请求都是使用 NSURLConnection 这个类来完成，那么了解这个类对网络数据请求来说就至关重要的。&lt;/p&gt;
&lt;h3 id=&quot;NSURLConnection-的常用类&quot;&gt;&lt;a href=&quot;#NSURLConnection-的常用类&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection 的常用类&quot;&gt;&lt;/a&gt;NSURLConnection 的常用类&lt;/h3&gt;&lt;p&gt;· NSURL ：请求地址&lt;/p&gt;
&lt;p&gt;· NSURLRequest ：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体….&lt;/p&gt;
&lt;p&gt;· NSMutableRequest ：NSURLRequest 的子类&lt;/p&gt;
&lt;p&gt;· NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据&lt;/p&gt;
    
    </summary>
    
    
      <category term="［数据请求］" scheme="http://yoursite.com/tags/%EF%BC%BB%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS 之网络数据请求</title>
    <link href="http://yoursite.com/2016/03/15/iOS-%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2016/03/15/iOS-之网络数据请求/</id>
    <published>2016-03-15T13:25:35.000Z</published>
    <updated>2016-03-15T13:36:49.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 网络请求主要使用了 HTTP 和 HTTPS 协议。现在主要记录 HTTP 的网络请求方式。那么在讨论网络数据请求之前就必须先了解清楚：HTTP 请求报文和 HTTP 响应报文。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;HTTP-请求报文&quot;&gt;&lt;a href=&quot;#HTTP-请求报文&quot; class=&quot;headerlink&quot; title=&quot;HTTP 请求报文&quot;&gt;&lt;/a&gt;HTTP 请求报文&lt;/h3&gt;&lt;p&gt;一个HTTP请求报文由请求行（request line）,请求头部（head）,空行（blank line）和请求数据（request-body）4个部分组成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＜request-line＞
＜headers＞
＜blank line＞
[＜request-body＞
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;请求行&quot;&gt;&lt;a href=&quot;#请求行&quot; class=&quot;headerlink&quot; title=&quot;请求行&quot;&gt;&lt;/a&gt;请求行&lt;/h4&gt;&lt;p&gt;由请求方法字段，URL字段和HTTP协议版本字段 3个字段组成，用空格分隔&lt;/p&gt;
&lt;p&gt;HTTP 协议的请求方法有：GET，POST，HEAD，PUT，DELETE，OPTIONS，TRACE，CONNECT&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GET ：最常见的一种请求方式，方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;POST ：将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;amp;”符号隔开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HEAD：像GET，只不过服务端接受到HEAD请求后只返回响应行，而不会发送响应内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;请求头部&quot;&gt;&lt;a href=&quot;#请求头部&quot; class=&quot;headerlink&quot; title=&quot;请求头部&quot;&gt;&lt;/a&gt;请求头部&lt;/h4&gt;&lt;p&gt;请求头部由键/值对组成，每行一对，键和值用英文冒号“:”分隔&lt;/p&gt;
&lt;p&gt;请求头部通知服务器有关于客户端请求的信息，典型的请求头有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User-Agent：产生请求的客户端类型。

Accept：客户端可识别的内容类型列表。

Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。

Referer：参考者

Accept-Language: 客户端可识别的语言

Accept-Encoding: 客户端可识别的编码方式

Connection: 链接方式

Cookie:

Content-Length: 数据的长度

Content-Type: 数据的类型

Date: 时间 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;空行&quot;&gt;&lt;a href=&quot;#空行&quot; class=&quot;headerlink&quot; title=&quot;空行&quot;&gt;&lt;/a&gt;空行&lt;/h4&gt;&lt;p&gt;最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。&lt;/p&gt;
&lt;h4 id=&quot;请求数据&quot;&gt;&lt;a href=&quot;#请求数据&quot; class=&quot;headerlink&quot; title=&quot;请求数据&quot;&gt;&lt;/a&gt;请求数据&lt;/h4&gt;&lt;p&gt;请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。&lt;/p&gt;
&lt;h3 id=&quot;TTP-响应报文&quot;&gt;&lt;a href=&quot;#TTP-响应报文&quot; class=&quot;headerlink&quot; title=&quot;TTP 响应报文&quot;&gt;&lt;/a&gt;TTP 响应报文&lt;/h3&gt;&lt;p&gt;HTTP响应也由四个部分组成，分别是：状态行、响应头、空格、响应数据&lt;/p&gt;
&lt;p&gt;如下所示，HTTP响应的格式与请求的格式十分类似：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＜status-line＞
＜headers＞
＜blank line＞
[＜response-body＞]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;状态行（status line）通过提供一个状态码来说明所请求的资源情况。&lt;/p&gt;
&lt;p&gt;状态行格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP-Version Status-Code Reason-Phrase CRLF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code 表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。&lt;/p&gt;
&lt;p&gt;  • 1xx：指示信息–表示请求已接收，继续处理。&lt;br&gt;  • 2xx：成功–表示请求已被成功接收、理解、接受。&lt;br&gt;  • 3xx：重定向–要完成请求必须进行更进一步的操作。&lt;br&gt;  • 4xx：客户端错误–请求有语法错误或请求无法实现。&lt;br&gt;  • 5xx：服务器端错误–服务器未能实现合法的请求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 网络请求主要使用了 HTTP 和 HTTPS 协议。现在主要记录 HTTP 的网络请求方式。那么在讨论网络数据请求之前就必须先了解清楚：HTTP 请求报文和 HTTP 响应报文。
    
    </summary>
    
    
      <category term="［http 报文］" scheme="http://yoursite.com/tags/%EF%BC%BBhttp-%E6%8A%A5%E6%96%87%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>Core Text 基础2</title>
    <link href="http://yoursite.com/2016/03/14/Core-Text-%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2016/03/14/Core-Text-基础2/</id>
    <published>2016-03-14T13:14:41.000Z</published>
    <updated>2016-03-14T13:51:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;二-Core-Text对象模型&quot;&gt;&lt;a href=&quot;#二-Core-Text对象模型&quot; class=&quot;headerlink&quot; title=&quot;二. Core Text对象模型&quot;&gt;&lt;/a&gt;二. Core Text对象模型&lt;/h2&gt;&lt;p&gt;这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/drawflout.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/img/ctstruct.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;framesetter framesetter对应的类型是 CTFramesetter，通过CFAttributedString进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame&lt;/li&gt;
&lt;li&gt;CTFrame CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调&lt;/li&gt;
&lt;li&gt;CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs&lt;/li&gt;
&lt;li&gt;CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面说了这么多对也没一个东西和图片绘制有关系，其实吧，Core Text本身并&lt;strong&gt;不支持图片绘制&lt;/strong&gt;，图片的绘制你还得 &lt;strong&gt;通过Core Graphics&lt;/strong&gt; 来进行。只是Core Text可以通过CTRun的设置为你的图片在文本绘制的过程中留出适当的空间。这个设置就使用到CTRunDelegate了，看这个名字大概就可以知道什么意思了，CTRunDelegate作为CTRun相关属性或操作扩展的一个入口，使得我们可以对CTRun做一些自定义的行为。为图片留位置的方法就是加入一个空白的CTRun，自定义其ascent，descent，width等参数，使得绘制文本的时候留下空白位置给相应的图片。然后图片在相应的空白位置上使用Core Graphics接口进行绘制。 &lt;/p&gt;
&lt;p&gt;使用CTRunDelegateCreate可以创建一个CTRunDelegate，它接收两个参数，一个是callbacks结构体，一个是所有callback调用的时候需要传入的对象。 callbacks的结构体为CTRunDelegateCallbacks，主要是包含一些回调函数，比如有返回当前run的ascent，descent，width这些值的回调函数，至于函数中如何鉴别当前是哪个run，可以在CTRunDelegateCreate的第二个参数来达到目的，因为CTRunDelegateCreate的第二个参数会作为每一个回调调用时的入参。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二-Core-Text对象模型&quot;&gt;&lt;a href=&quot;#二-Core-Text对象模型&quot; class=&quot;headerlink&quot; title=&quot;二. Core Text对象模型&quot;&gt;&lt;/a&gt;二. Core Text对象模型&lt;/h2&gt;&lt;p&gt;这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/drawflout.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="informal" scheme="http://yoursite.com/tags/informal/"/>
    
  </entry>
  
  <entry>
    <title>Core Text 基础</title>
    <link href="http://yoursite.com/2016/03/14/Core-Text-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2016/03/14/Core-Text-基础/</id>
    <published>2016-03-14T13:05:46.000Z</published>
    <updated>2016-03-14T13:50:40.000Z</updated>
    
    <content type="html">&lt;p&gt; Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-Core-Text知识准备&quot;&gt;&lt;a href=&quot;#一-Core-Text知识准备&quot; class=&quot;headerlink&quot; title=&quot;一. Core Text知识准备&quot;&gt;&lt;/a&gt;一. Core Text知识准备&lt;/h2&gt;&lt;p&gt;   在进入任何一个新的编程领域之前，我们肯定要先接触相关的领域模型的知识。比如你软件是进行科学计算的，那么你就必须理解大量的数学原理；如果你的软件是搞银行系统，那么你就得事先了解相关的银行的业务知识。这些都是不可避免的事情。通常情况下领域知识具有较高的通用性。但在特定的环境下，某些知识点也会被特殊处理。 Core Text是用来进行文字精细排版的，所以了解文字相关的知识也不可避免。&lt;/p&gt;
&lt;h3 id=&quot;1-字符（Character）和字形（Glyphs）&quot;&gt;&lt;a href=&quot;#1-字符（Character）和字形（Glyphs）&quot; class=&quot;headerlink&quot; title=&quot;1. 字符（Character）和字形（Glyphs）&quot;&gt;&lt;/a&gt;1. 字符（Character）和字形（Glyphs）&lt;/h3&gt;&lt;p&gt;排版系统中文本显示的一个重要的过程就是字符到字形的转换，字符是信息本身的元素，而字形是字符的图形表征，字符还会有其它表征比如发音。 字符在计算机中其实就是一个编码，某个字符集中的编码，比如Unicode字符集，就囊括了大都数存在的字符。 而字形则是图形，一般都存储在字体文件中，字形也有它的编码，也就是它在字体中的索引。 一个字符可以对应多个字形（不同的字体，或者同种字体的不同样式:粗体斜体等）；多个字符也可能对应一个字形，比如字符的连写（ Ligatures）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/ligatures.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;Roman Ligatures&lt;/p&gt;
&lt;p&gt;下面就来详情看看字形的各个参数也就是所谓的字形度量Glyph Metrics&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/metrics.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/img/metrics2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bounding box（边界框 bbox），这是一个假想的框子，它尽可能紧密的装入字形。&lt;/li&gt;
&lt;li&gt;baseline（基线），一条假想的线,一行上的字形都以此线作为上下位置的参考，在这条线的左侧存在一个点叫做基线的原点.&lt;/li&gt;
&lt;li&gt;ascent（上行高度）从原点到字体中最高（这里的高深都是以基线为参照线的）的字形的顶部的距离，ascent是一个正值&lt;/li&gt;
&lt;li&gt;descent（下行高度）从原点到字体中最深的字形底部的距离，descent是一个负值（比如一个字体原点到最深的字形的底部的距离为2，那么descent就为-2）&lt;/li&gt;
&lt;li&gt;linegap（行距），linegap也可以称作leading（其实准确点讲应该叫做External leading）,行高lineHeight则可以通过 ascent + descent + linegap 来计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-坐标系&quot;&gt;&lt;a href=&quot;#2-坐标系&quot; class=&quot;headerlink&quot; title=&quot;2. 坐标系&quot;&gt;&lt;/a&gt;2. 坐标系&lt;/h3&gt;&lt;p&gt;首先不得不说 苹果编程中的坐标系花样百出，经常让开发者措手不及。 传统的Mac中的坐标系的原点在左下角，比如NSView默认的坐标系，原点就在左下角。但Mac中有些View为了其实现的便捷将原点变换到左上角，像NSTableView的坐标系坐标原点就在左上角。iOS UIKit的UIView的坐标系原点在左上角。&lt;br&gt;往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？ 在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。如果你细心，通过CGContextGetCTM(CGContextRef c)可以看到其返回的值并不是CGAffineTransformIdentity，通过打印出来看到值为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printing description of contextCTM:
(CGAffineTransform) contextCTM = {
       a = 1
       b = 0
       c = 0
       d = -1
      tx = 0
      ty = 460
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是非retina分辨率下的结果，如果是如果是retina上面的a,d,ty的值将会乘2，如果是iPhone 5，ty的值会再大些。 但是作用都是一样的就是将上下文空间坐标系进行了flip，使得原本左下角原点变到左上角，y轴正方向也变换成向下。&lt;/p&gt;
&lt;p&gt;上面说了一大堆，下面进入正题，Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。 但是iOS的UIView的drawRect方法的context被做了次flip，如果你啥也不做处理，直接在这个context上进行Core Text绘制，你会发现文字是镜像且上下颠倒。 &lt;/p&gt;
&lt;p&gt;所以在UIView的drawRect方法中的context上进行Core Text绘制之前需要对context&lt;strong&gt;进行一次Flip&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里再提及一个函数CGContextSetTextMatrix，它可以用来为每一个显示的字形单独设置变形矩阵。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-NSMutableAttributedString-和-CFMutableAttributedStringRef&quot;&gt;&lt;a href=&quot;#3-NSMutableAttributedString-和-CFMutableAttributedStringRef&quot; class=&quot;headerlink&quot; title=&quot;3. NSMutableAttributedString 和 CFMutableAttributedStringRef&quot;&gt;&lt;/a&gt;3. NSMutableAttributedString 和 CFMutableAttributedStringRef&lt;/h3&gt;&lt;p&gt;Core Foundation和Foundation中的有些数据类型只需要简单的强制类型转换就可以互换使用，这类类型我们叫他们为 Toll-Free Bridged Types。 CFMutableAttributedStringRef和NSMutableAttributedString就是其中的一对，Core Foundation的接口基本是C的接口，功能强大，但是使用起来没有Foundation中提供的Objc的接口简单好使，所以很多时候我们可以使用高层接口组织数据，然后将其传给低层函数接口使用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
