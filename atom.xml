<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-17T12:10:41.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NSOperation和NSOperationQueue多线程的使用</title>
    <link href="http://yoursite.com/2016/03/17/NSOperation%E5%92%8CNSOperationQueue%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/17/NSOperation和NSOperationQueue多线程的使用/</id>
    <published>2016-03-17T11:37:41.000Z</published>
    <updated>2016-03-17T12:10:41.000Z</updated>
    
    <content type="html">&lt;p&gt; 最近学习了多线程编程 NSOperationQueue ，才比较清楚的明白了&lt;strong&gt;同步／异步&lt;/strong&gt;，&lt;strong&gt;阻塞／非阻塞&lt;/strong&gt;所表达的不同含义：所谓的同步／异步是对你得到消息的方式的描述，而阻塞／非阻塞则是你怎么样处理事情的做法，他们讲述的是不同层面的概念。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  现在来讲述一下可以实现多线程的三种方式中的 NSOperation 类。使用NSOperation和NSOperationQueue实现多线程编程，实现步骤大致是这样的：&lt;/p&gt;
&lt;p&gt;  1&amp;gt; 先将需要执行的操作封装到一个NSOperation对象中&lt;/p&gt;
&lt;p&gt;  2&amp;gt; 然后将NSOperation对象添加到NSOperationQueue中&lt;/p&gt;
&lt;p&gt;  3&amp;gt; 系统会自动将NSOperation中封装的操作放到一条新线程中执行&lt;/p&gt;
&lt;p&gt;  而由于  NSOperation 是一个抽象类，所以它的功能只能有其子类 NSBlockOperation 和 SInvocationOperation 来实现。&lt;/p&gt;
&lt;h4 id=&quot;NSBlockOperation-的使用&quot;&gt;&lt;a href=&quot;#NSBlockOperation-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSBlockOperation 的使用&quot;&gt;&lt;/a&gt;NSBlockOperation 的使用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt; NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){     
    NSLog(@&amp;quot;*执行第1次操作，线程：%@&amp;quot;, [NSThread currentThread]);       
   }];

[operation addExecutionBlock:^() {

   NSLog(@&amp;quot;**又执行了1个新的操作，线程：%@&amp;quot;, [NSThread currentThread]);

   }];

// 开始执行任务    
[operation start];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   注：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。&lt;/p&gt;
&lt;h4 id=&quot;NSInvocationOperation-的使用&quot;&gt;&lt;a href=&quot;#NSInvocationOperation-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSInvocationOperation 的使用&quot;&gt;&lt;/a&gt;NSInvocationOperation 的使用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ration2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downLoadImage:) object:URL];
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:operation2];

如果是有刷新界面的操作，那么必须将这个操作交给主线程来完成。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义-NSOperation-类&quot;&gt;&lt;a href=&quot;#自定义-NSOperation-类&quot; class=&quot;headerlink&quot; title=&quot;自定义 NSOperation 类&quot;&gt;&lt;/a&gt;自定义 NSOperation 类&lt;/h3&gt;&lt;p&gt;由于 NSOperation 类功能比较少， 一般情况下我们可以自定义一个 NSOperation 类。要定制这样的一个操作，可以遵循以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承 NSOperation 类&lt;/li&gt;
&lt;li&gt;重写“main”方法&lt;/li&gt;
&lt;li&gt;在“main”方法中创建一个“automaticreleasepool“&lt;/li&gt;
&lt;li&gt;将你的代码放在”autoreleasepool“中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  例子：&lt;br&gt;     &lt;em&gt;*&lt;/em&gt; .h 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface MyLengthyOperation : NSOperation
@property (nonatomic, strong, readonly) NSString *mark;
- (instancetype)initWithMark:(NSString *)mark;
@end 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;em&gt;*&lt;/em&gt; .m 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;MyLengthyOperation.h&amp;quot;
@interface MyLengthyOperation ()
@property (nonatomic, strong, readwrite) NSString *mark;
@end
@implementation MyLengthyOperation
- (instancetype)initWithMark:(NSString *)mark {  
   self = [super init];
   if (self) {      
       self.mark = mark;
    }
   return self;
   }
- (void)main {
    @autoreleasepool {
      for (int i = 0; i &amp;lt; 100; i ++) {
         if (self.isCancelled) {
             break;
         }
         NSLog(@&amp;quot;%@ - %f&amp;quot;, self.mark, sqrt(i));
        }
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//  初始化任务 
MyLengthyOperation *operation_1 = [[MyLengthyOperation alloc] initWithMark:@&amp;quot;operation_1&amp;quot;];
MyLengthyOperation *operation_2 = [[MyLengthyOperation alloc] initWithMark:@&amp;quot;operation_2&amp;quot;];

// 设置任务的优先级
[operation_1 setQueuePriority:NSOperationQueuePriorityVeryLow];
[operation_2 setQueuePriority:NSOperationQueuePriorityHigh];

// 添加从属关系
[operation_2 addDependency:operation_1]; （任务2在任务1结束后才会执行）

// 初始化队列
NSOperationQueue *myQueue = [[NSOperationQueue alloc] init];
myQueue.name = @&amp;quot;下载队列&amp;quot;;

// 将一个简单的任务队列添加进队列中 （使用 Block 回调方式）      
    NSURL *aURL = [NSURL URLWithString:URL];
    NSData *data = [NSData dataWithContentsOfURL:aURL];

    [[NSOperationQueue mainQueue] addOperationWithBlock:^{

        UIImage *image = [[UIImage alloc] initWithData:data];
        [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];
    }];
}];

// 设置任务队列的最大并发数
 myQueue.maxConcurrentOperationCount = 4;

// 添加进任务队列中执行
[myQueue addOperation:operation_1];
[myQueue addOperation:operation_2];

// 取消所有操作
[myQueue cancelAllOperations];

// 执行延时的操作（将执行代码放置在 block 中）
- (void)execute:(dispatch_block_t)block afterDelay:(int64_t)delta {

   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delta), dispatch_get_main_queue(), block);
 }

// 挂起操作
[myQueue setSuspended:YES];

// 取消任务
[operation_1 cancel];

//  任务完成后的回调可以表示任务已经结束
 [operation_1 setCompletionBlock:^{
      NSLog(@&amp;quot;任务1结束&amp;quot;);
  }];
 [operation_2 setCompletionBlock:^{
      NSLog(@&amp;quot;任务2结束&amp;quot;);
 }];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt; 最近学习了多线程编程 NSOperationQueue ，才比较清楚的明白了&lt;strong&gt;同步／异步&lt;/strong&gt;，&lt;strong&gt;阻塞／非阻塞&lt;/strong&gt;所表达的不同含义：所谓的同步／异步是对你得到消息的方式的描述，而阻塞／非阻塞则是你怎么样处理事情的做法，他们讲述的是不同层面的概念。
    
    </summary>
    
    
      <category term="［博客］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%8D%9A%E5%AE%A2%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>NSURLConnection 基本使用</title>
    <link href="http://yoursite.com/2016/03/15/NSURLConnection-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/15/NSURLConnection-基本使用/</id>
    <published>2016-03-15T13:38:59.000Z</published>
    <updated>2016-03-15T13:57:04.000Z</updated>
    
    <content type="html">&lt;p&gt;现如今大部分的网络请求都是使用 NSURLConnection 这个类来完成，那么了解这个类对网络数据请求来说就至关重要的。&lt;/p&gt;
&lt;h3 id=&quot;NSURLConnection-的常用类&quot;&gt;&lt;a href=&quot;#NSURLConnection-的常用类&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection 的常用类&quot;&gt;&lt;/a&gt;NSURLConnection 的常用类&lt;/h3&gt;&lt;p&gt;· NSURL ：请求地址&lt;/p&gt;
&lt;p&gt;· NSURLRequest ：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体….&lt;/p&gt;
&lt;p&gt;· NSMutableRequest ：NSURLRequest 的子类&lt;/p&gt;
&lt;p&gt;· NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;NSURLConnection的使用&quot;&gt;&lt;a href=&quot;#NSURLConnection的使用&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection的使用&quot;&gt;&lt;/a&gt;NSURLConnection的使用&lt;/h3&gt;&lt;p&gt;使用 NSURLConnection 这个类的步骤主要有三个：&lt;/p&gt;
&lt;p&gt;1）创建一个NSURL对象，设置请求路径（设置请求路径）&lt;/p&gt;
&lt;p&gt;2）传入NSURL创建一个NSURLRequest对象，设置请求头和请求体（创建请求对象）&lt;/p&gt;
&lt;p&gt;3）使用NSURLConnection发送NSURLRequest（发送请求）&lt;/p&gt;
&lt;p&gt;在请求数据的过程中根据连接服务器的方式分为&lt;strong&gt;同步请求&lt;/strong&gt;和&lt;strong&gt;异步请求&lt;/strong&gt;这两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;NSData *data=[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;－ 使用 block 回调&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSOperationQueue *queue=[NSOperationQueue mainQueue];
[NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) { }];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;－ 代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSURLConnection *conn=[NSURLConnection connectionWithRequest:request delegate:self];
[conn start];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在NSURLConnectionDataDelegate代理方法里面执行事件。&lt;/p&gt;
&lt;h3 id=&quot;NSMutableURLRequest-的妙用&quot;&gt;&lt;a href=&quot;#NSMutableURLRequest-的妙用&quot; class=&quot;headerlink&quot; title=&quot;NSMutableURLRequest 的妙用&quot;&gt;&lt;/a&gt;NSMutableURLRequest 的妙用&lt;/h3&gt;&lt;p&gt;NSMutableURLRequest是NSURLRequest的子类，常用方法有&lt;/p&gt;
&lt;p&gt;－ 设置请求超时等待时间（超过这个时间就算超时，请求失败）- (void)setTimeoutInterval:(NSTimeInterval)seconds;&lt;br&gt;－ 设置请求方法（比如GET和POST）- (void)setHTTPMethod:(NSString &lt;em&gt;)method;&lt;br&gt;－ 设置请求体 - (void)setHTTPBody:(NSData &lt;/em&gt;)data;&lt;br&gt;－ 设置请求头 - (void)setValue:(NSString &lt;em&gt;)value forHTTPHeaderField:(NSString &lt;/em&gt;)field;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现如今大部分的网络请求都是使用 NSURLConnection 这个类来完成，那么了解这个类对网络数据请求来说就至关重要的。&lt;/p&gt;
&lt;h3 id=&quot;NSURLConnection-的常用类&quot;&gt;&lt;a href=&quot;#NSURLConnection-的常用类&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection 的常用类&quot;&gt;&lt;/a&gt;NSURLConnection 的常用类&lt;/h3&gt;&lt;p&gt;· NSURL ：请求地址&lt;/p&gt;
&lt;p&gt;· NSURLRequest ：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体….&lt;/p&gt;
&lt;p&gt;· NSMutableRequest ：NSURLRequest 的子类&lt;/p&gt;
&lt;p&gt;· NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据&lt;/p&gt;
    
    </summary>
    
    
      <category term="［数据请求］" scheme="http://yoursite.com/tags/%EF%BC%BB%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS 之网络数据请求</title>
    <link href="http://yoursite.com/2016/03/15/iOS-%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2016/03/15/iOS-之网络数据请求/</id>
    <published>2016-03-15T13:25:35.000Z</published>
    <updated>2016-03-15T13:36:49.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 网络请求主要使用了 HTTP 和 HTTPS 协议。现在主要记录 HTTP 的网络请求方式。那么在讨论网络数据请求之前就必须先了解清楚：HTTP 请求报文和 HTTP 响应报文。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;HTTP-请求报文&quot;&gt;&lt;a href=&quot;#HTTP-请求报文&quot; class=&quot;headerlink&quot; title=&quot;HTTP 请求报文&quot;&gt;&lt;/a&gt;HTTP 请求报文&lt;/h3&gt;&lt;p&gt;一个HTTP请求报文由请求行（request line）,请求头部（head）,空行（blank line）和请求数据（request-body）4个部分组成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＜request-line＞
＜headers＞
＜blank line＞
[＜request-body＞
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;请求行&quot;&gt;&lt;a href=&quot;#请求行&quot; class=&quot;headerlink&quot; title=&quot;请求行&quot;&gt;&lt;/a&gt;请求行&lt;/h4&gt;&lt;p&gt;由请求方法字段，URL字段和HTTP协议版本字段 3个字段组成，用空格分隔&lt;/p&gt;
&lt;p&gt;HTTP 协议的请求方法有：GET，POST，HEAD，PUT，DELETE，OPTIONS，TRACE，CONNECT&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GET ：最常见的一种请求方式，方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;POST ：将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;amp;”符号隔开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HEAD：像GET，只不过服务端接受到HEAD请求后只返回响应行，而不会发送响应内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;请求头部&quot;&gt;&lt;a href=&quot;#请求头部&quot; class=&quot;headerlink&quot; title=&quot;请求头部&quot;&gt;&lt;/a&gt;请求头部&lt;/h4&gt;&lt;p&gt;请求头部由键/值对组成，每行一对，键和值用英文冒号“:”分隔&lt;/p&gt;
&lt;p&gt;请求头部通知服务器有关于客户端请求的信息，典型的请求头有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User-Agent：产生请求的客户端类型。

Accept：客户端可识别的内容类型列表。

Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。

Referer：参考者

Accept-Language: 客户端可识别的语言

Accept-Encoding: 客户端可识别的编码方式

Connection: 链接方式

Cookie:

Content-Length: 数据的长度

Content-Type: 数据的类型

Date: 时间 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;空行&quot;&gt;&lt;a href=&quot;#空行&quot; class=&quot;headerlink&quot; title=&quot;空行&quot;&gt;&lt;/a&gt;空行&lt;/h4&gt;&lt;p&gt;最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。&lt;/p&gt;
&lt;h4 id=&quot;请求数据&quot;&gt;&lt;a href=&quot;#请求数据&quot; class=&quot;headerlink&quot; title=&quot;请求数据&quot;&gt;&lt;/a&gt;请求数据&lt;/h4&gt;&lt;p&gt;请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。&lt;/p&gt;
&lt;h3 id=&quot;TTP-响应报文&quot;&gt;&lt;a href=&quot;#TTP-响应报文&quot; class=&quot;headerlink&quot; title=&quot;TTP 响应报文&quot;&gt;&lt;/a&gt;TTP 响应报文&lt;/h3&gt;&lt;p&gt;HTTP响应也由四个部分组成，分别是：状态行、响应头、空格、响应数据&lt;/p&gt;
&lt;p&gt;如下所示，HTTP响应的格式与请求的格式十分类似：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＜status-line＞
＜headers＞
＜blank line＞
[＜response-body＞]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;状态行（status line）通过提供一个状态码来说明所请求的资源情况。&lt;/p&gt;
&lt;p&gt;状态行格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP-Version Status-Code Reason-Phrase CRLF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code 表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。&lt;/p&gt;
&lt;p&gt;  • 1xx：指示信息–表示请求已接收，继续处理。&lt;br&gt;  • 2xx：成功–表示请求已被成功接收、理解、接受。&lt;br&gt;  • 3xx：重定向–要完成请求必须进行更进一步的操作。&lt;br&gt;  • 4xx：客户端错误–请求有语法错误或请求无法实现。&lt;br&gt;  • 5xx：服务器端错误–服务器未能实现合法的请求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 网络请求主要使用了 HTTP 和 HTTPS 协议。现在主要记录 HTTP 的网络请求方式。那么在讨论网络数据请求之前就必须先了解清楚：HTTP 请求报文和 HTTP 响应报文。
    
    </summary>
    
    
      <category term="［http 报文］" scheme="http://yoursite.com/tags/%EF%BC%BBhttp-%E6%8A%A5%E6%96%87%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>Core Text 基础2</title>
    <link href="http://yoursite.com/2016/03/14/Core-Text-%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2016/03/14/Core-Text-基础2/</id>
    <published>2016-03-14T13:14:41.000Z</published>
    <updated>2016-03-14T13:51:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;二-Core-Text对象模型&quot;&gt;&lt;a href=&quot;#二-Core-Text对象模型&quot; class=&quot;headerlink&quot; title=&quot;二. Core Text对象模型&quot;&gt;&lt;/a&gt;二. Core Text对象模型&lt;/h2&gt;&lt;p&gt;这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/drawflout.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/img/ctstruct.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;framesetter framesetter对应的类型是 CTFramesetter，通过CFAttributedString进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame&lt;/li&gt;
&lt;li&gt;CTFrame CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调&lt;/li&gt;
&lt;li&gt;CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs&lt;/li&gt;
&lt;li&gt;CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面说了这么多对也没一个东西和图片绘制有关系，其实吧，Core Text本身并&lt;strong&gt;不支持图片绘制&lt;/strong&gt;，图片的绘制你还得 &lt;strong&gt;通过Core Graphics&lt;/strong&gt; 来进行。只是Core Text可以通过CTRun的设置为你的图片在文本绘制的过程中留出适当的空间。这个设置就使用到CTRunDelegate了，看这个名字大概就可以知道什么意思了，CTRunDelegate作为CTRun相关属性或操作扩展的一个入口，使得我们可以对CTRun做一些自定义的行为。为图片留位置的方法就是加入一个空白的CTRun，自定义其ascent，descent，width等参数，使得绘制文本的时候留下空白位置给相应的图片。然后图片在相应的空白位置上使用Core Graphics接口进行绘制。 &lt;/p&gt;
&lt;p&gt;使用CTRunDelegateCreate可以创建一个CTRunDelegate，它接收两个参数，一个是callbacks结构体，一个是所有callback调用的时候需要传入的对象。 callbacks的结构体为CTRunDelegateCallbacks，主要是包含一些回调函数，比如有返回当前run的ascent，descent，width这些值的回调函数，至于函数中如何鉴别当前是哪个run，可以在CTRunDelegateCreate的第二个参数来达到目的，因为CTRunDelegateCreate的第二个参数会作为每一个回调调用时的入参。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二-Core-Text对象模型&quot;&gt;&lt;a href=&quot;#二-Core-Text对象模型&quot; class=&quot;headerlink&quot; title=&quot;二. Core Text对象模型&quot;&gt;&lt;/a&gt;二. Core Text对象模型&lt;/h2&gt;&lt;p&gt;这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/drawflout.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="informal" scheme="http://yoursite.com/tags/informal/"/>
    
  </entry>
  
  <entry>
    <title>Core Text 基础</title>
    <link href="http://yoursite.com/2016/03/14/Core-Text-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2016/03/14/Core-Text-基础/</id>
    <published>2016-03-14T13:05:46.000Z</published>
    <updated>2016-03-14T13:50:40.000Z</updated>
    
    <content type="html">&lt;p&gt; Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-Core-Text知识准备&quot;&gt;&lt;a href=&quot;#一-Core-Text知识准备&quot; class=&quot;headerlink&quot; title=&quot;一. Core Text知识准备&quot;&gt;&lt;/a&gt;一. Core Text知识准备&lt;/h2&gt;&lt;p&gt;   在进入任何一个新的编程领域之前，我们肯定要先接触相关的领域模型的知识。比如你软件是进行科学计算的，那么你就必须理解大量的数学原理；如果你的软件是搞银行系统，那么你就得事先了解相关的银行的业务知识。这些都是不可避免的事情。通常情况下领域知识具有较高的通用性。但在特定的环境下，某些知识点也会被特殊处理。 Core Text是用来进行文字精细排版的，所以了解文字相关的知识也不可避免。&lt;/p&gt;
&lt;h3 id=&quot;1-字符（Character）和字形（Glyphs）&quot;&gt;&lt;a href=&quot;#1-字符（Character）和字形（Glyphs）&quot; class=&quot;headerlink&quot; title=&quot;1. 字符（Character）和字形（Glyphs）&quot;&gt;&lt;/a&gt;1. 字符（Character）和字形（Glyphs）&lt;/h3&gt;&lt;p&gt;排版系统中文本显示的一个重要的过程就是字符到字形的转换，字符是信息本身的元素，而字形是字符的图形表征，字符还会有其它表征比如发音。 字符在计算机中其实就是一个编码，某个字符集中的编码，比如Unicode字符集，就囊括了大都数存在的字符。 而字形则是图形，一般都存储在字体文件中，字形也有它的编码，也就是它在字体中的索引。 一个字符可以对应多个字形（不同的字体，或者同种字体的不同样式:粗体斜体等）；多个字符也可能对应一个字形，比如字符的连写（ Ligatures）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/ligatures.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;Roman Ligatures&lt;/p&gt;
&lt;p&gt;下面就来详情看看字形的各个参数也就是所谓的字形度量Glyph Metrics&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/metrics.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/img/metrics2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bounding box（边界框 bbox），这是一个假想的框子，它尽可能紧密的装入字形。&lt;/li&gt;
&lt;li&gt;baseline（基线），一条假想的线,一行上的字形都以此线作为上下位置的参考，在这条线的左侧存在一个点叫做基线的原点.&lt;/li&gt;
&lt;li&gt;ascent（上行高度）从原点到字体中最高（这里的高深都是以基线为参照线的）的字形的顶部的距离，ascent是一个正值&lt;/li&gt;
&lt;li&gt;descent（下行高度）从原点到字体中最深的字形底部的距离，descent是一个负值（比如一个字体原点到最深的字形的底部的距离为2，那么descent就为-2）&lt;/li&gt;
&lt;li&gt;linegap（行距），linegap也可以称作leading（其实准确点讲应该叫做External leading）,行高lineHeight则可以通过 ascent + descent + linegap 来计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-坐标系&quot;&gt;&lt;a href=&quot;#2-坐标系&quot; class=&quot;headerlink&quot; title=&quot;2. 坐标系&quot;&gt;&lt;/a&gt;2. 坐标系&lt;/h3&gt;&lt;p&gt;首先不得不说 苹果编程中的坐标系花样百出，经常让开发者措手不及。 传统的Mac中的坐标系的原点在左下角，比如NSView默认的坐标系，原点就在左下角。但Mac中有些View为了其实现的便捷将原点变换到左上角，像NSTableView的坐标系坐标原点就在左上角。iOS UIKit的UIView的坐标系原点在左上角。&lt;br&gt;往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？ 在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。如果你细心，通过CGContextGetCTM(CGContextRef c)可以看到其返回的值并不是CGAffineTransformIdentity，通过打印出来看到值为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printing description of contextCTM:
(CGAffineTransform) contextCTM = {
       a = 1
       b = 0
       c = 0
       d = -1
      tx = 0
      ty = 460
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是非retina分辨率下的结果，如果是如果是retina上面的a,d,ty的值将会乘2，如果是iPhone 5，ty的值会再大些。 但是作用都是一样的就是将上下文空间坐标系进行了flip，使得原本左下角原点变到左上角，y轴正方向也变换成向下。&lt;/p&gt;
&lt;p&gt;上面说了一大堆，下面进入正题，Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。 但是iOS的UIView的drawRect方法的context被做了次flip，如果你啥也不做处理，直接在这个context上进行Core Text绘制，你会发现文字是镜像且上下颠倒。 &lt;/p&gt;
&lt;p&gt;所以在UIView的drawRect方法中的context上进行Core Text绘制之前需要对context&lt;strong&gt;进行一次Flip&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里再提及一个函数CGContextSetTextMatrix，它可以用来为每一个显示的字形单独设置变形矩阵。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-NSMutableAttributedString-和-CFMutableAttributedStringRef&quot;&gt;&lt;a href=&quot;#3-NSMutableAttributedString-和-CFMutableAttributedStringRef&quot; class=&quot;headerlink&quot; title=&quot;3. NSMutableAttributedString 和 CFMutableAttributedStringRef&quot;&gt;&lt;/a&gt;3. NSMutableAttributedString 和 CFMutableAttributedStringRef&lt;/h3&gt;&lt;p&gt;Core Foundation和Foundation中的有些数据类型只需要简单的强制类型转换就可以互换使用，这类类型我们叫他们为 Toll-Free Bridged Types。 CFMutableAttributedStringRef和NSMutableAttributedString就是其中的一对，Core Foundation的接口基本是C的接口，功能强大，但是使用起来没有Foundation中提供的Objc的接口简单好使，所以很多时候我们可以使用高层接口组织数据，然后将其传给低层函数接口使用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
