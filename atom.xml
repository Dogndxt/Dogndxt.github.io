<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-22T14:29:35.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文件的处理－见识filemanager的强大</title>
    <link href="http://yoursite.com/2016/04/22/%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%8D%E8%A7%81%E8%AF%86filemanager%E7%9A%84%E5%BC%BA%E5%A4%A7/"/>
    <id>http://yoursite.com/2016/04/22/文件的处理－见识filemanager的强大/</id>
    <published>2016-04-22T14:29:05.000Z</published>
    <updated>2016-04-22T14:29:35.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;获取-Documents-目录文件&quot;&gt;&lt;a href=&quot;#获取-Documents-目录文件&quot; class=&quot;headerlink&quot; title=&quot;获取 Documents 目录文件&quot;&gt;&lt;/a&gt;获取 Documents 目录文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Library-目录路径&quot;&gt;&lt;a href=&quot;#获取-Library-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Library 目录路径&quot;&gt;&lt;/a&gt;获取 Library 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSArray *paths2 = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
NSString *libraryDirectofry = [paths2 lastObject]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取-Tmp-目录路径&quot;&gt;&lt;a href=&quot;#获取-Tmp-目录路径&quot; class=&quot;headerlink&quot; title=&quot;获取 Tmp 目录路径&quot;&gt;&lt;/a&gt;获取 Tmp 目录路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *tmpDirectory = NSTemporaryDirectory(); 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件夹&quot;&gt;&lt;a href=&quot;#创建文件夹&quot; class=&quot;headerlink&quot; title=&quot;创建文件夹&quot;&gt;&lt;/a&gt;创建文件夹&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSFileManager *fileManager = [NSFileManager defaultManager];
NSString *testDirectory = [documentsDirectory stringByAppendingString:@&amp;quot;test&amp;quot;];
BOOL res = [fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil];   
if (res) {

    NSLog(@&amp;quot;创建文件夹成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件夹失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;创建文件&quot;&gt;&lt;a href=&quot;#创建文件&quot; class=&quot;headerlink&quot; title=&quot;创建文件&quot;&gt;&lt;/a&gt;创建文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSData *data = [NSData dataWithContentsOfFile:@&amp;quot;/Users/zxq/Desktop/userInfor&amp;quot;];
NSString *testPath = [testDirectory stringByAppendingPathComponent:@&amp;quot;test.txt&amp;quot;];
BOOL res2 = [fileManager createFileAtPath:testPath contents:data attributes:nil]; 
if (res2) {

    NSLog(@&amp;quot;创建文件成功&amp;quot;);
} else {

    NSLog(@&amp;quot;创建文件失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;测试写入内容&quot;&gt;&lt;a href=&quot;#测试写入内容&quot; class=&quot;headerlink&quot; title=&quot;测试写入内容&quot;&gt;&lt;/a&gt;测试写入内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content = @&amp;quot;测试写入内容&amp;quot;;
BOOL res3 = [content writeToFile:testPath atomically:YES encoding:NSUTF8StringEncoding error:nil]; 
if (res3) {

    NSLog(@&amp;quot;文件写入成功&amp;quot;);
} else {

    NSLog(@&amp;quot;文件写入失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;读取文件内容&quot;&gt;&lt;a href=&quot;#读取文件内容&quot; class=&quot;headerlink&quot; title=&quot;读取文件内容&quot;&gt;&lt;/a&gt;读取文件内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *content2 = [NSString stringWithContentsOfFile:testPath encoding:NSUTF8StringEncoding error:nil]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取文件属性&quot;&gt;&lt;a href=&quot;#获取文件属性&quot; class=&quot;headerlink&quot; title=&quot;获取文件属性&quot;&gt;&lt;/a&gt;获取文件属性&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDictionary *fileAttributes = [fileManager attributesOfItemAtPath:testPath error:nil]; 
for (int i = 0; i &amp;lt; [[fileAttributes allKeys] count]; i ++) {

    NSLog(@&amp;quot;key: %@, value:%@&amp;quot;, [[fileAttributes allKeys] objectAtIndex:i], [fileAttributes objectForKey:[[fileAttributes allKeys] objectAtIndex:i]]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;删除文件&quot;&gt;&lt;a href=&quot;#删除文件&quot; class=&quot;headerlink&quot; title=&quot;删除文件&quot;&gt;&lt;/a&gt;删除文件&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;BOOL res4 = [fileManager removeItemAtPath:testPath error:nil]; 
if (res4) {

    NSLog(@&amp;quot;删除成功&amp;quot;);
} else {

    NSLog(@&amp;quot;删除失败&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;获取应用沙盒根路径&quot;&gt;&lt;a href=&quot;#获取应用沙盒根路径&quot; class=&quot;headerlink&quot; title=&quot;获取应用沙盒根路径&quot;&gt;&lt;/a&gt;获取应用沙盒根路径&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSString *dirHome = NSHomeDirectory(); 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>内存空间Zone的挖掘</title>
    <link href="http://yoursite.com/2016/04/22/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4Zone%E7%9A%84%E6%8C%96%E6%8E%98/"/>
    <id>http://yoursite.com/2016/04/22/内存空间Zone的挖掘/</id>
    <published>2016-04-22T14:26:34.000Z</published>
    <updated>2016-04-22T14:27:11.000Z</updated>
    
    <content type="html">&lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;所以你为什么想要去用你自己的NSZone呢？&lt;/p&gt;
&lt;p&gt;如果你大量分配数百个小对象，事实上你会发现你花费精力来为他们分配内存是有意义的。因为这种标准的（默认的）空间会被一直使用，它会变得斑驳起来；释放对象的过程会给整个内存留下令人尴尬的空隙。标准空间的分配器（allocator）也知道知道这一点，所以它尝试着优先去使用被用户释放的内存，去填补这些空隙，但是这种方式只有在空间(zone) 变得很大时才有明显效果。&lt;/p&gt;
&lt;p&gt;如果你想为大量对象分配内存，然后，你可以创建你自己的空间（zone）并且告诉它不用去为了为新对象分配内存而去查找那些空隙。分配器现在能够每次跳到内存分配的末尾为你的新对象分配内存，能起到不错的效果。&lt;/p&gt;
&lt;p&gt;另外，分配器也能为你节省时间，当分配器向操作系统请求更多内存时，分配器去查找哪块空间什么时候被填满，需要花费不少时间。一种更快的时间是一次去请求一大块内存，你也能告诉你的NSZone在这儿做什么。&lt;/p&gt;
&lt;p&gt;NSZone也能节省你释放内存的时间。它有方法释放大量分配的内存，而不打扰释放器（deallocators）。如果用一个集合（set）包含一系列对象，这样能够节省时间，你可以一次释放它们而不用去乏味地一个个释放它们。&lt;/p&gt;
&lt;p&gt;NSZone is Apple’s way of optimizing object allocation and freeing. NSZone is not an object; it is an opaque C-struct storing information about how memory should be handled for a set of objects.&lt;/p&gt;
&lt;p&gt;One rarely needs to worry about handling your own zones in applications; Cocoa handles it transparently. A default NSZone is created&amp;gt;If you are mass-allocating hundreds of cheap objects, you may find the cost of actually allocating space for them becomes significant. Because the standard zone is used all the time, it can become very patchy; deleted objects can leave awkward gaps throughout memory. The allocator for the standard NSZone knows this, and it tries to fill these gaps in preference to grabbing more memory off the system, but this can be costly in time if the zone has grown quite large.&lt;/p&gt;
&lt;p&gt;If you want to mass-allocate objects, then, you can create your own zone and tell it not to bother with finding gaps to put new objects in. The allocator can now jump to the end of its allotted memory each time and quickly assign memory to your new objects, saving a lot of effort.&lt;/p&gt;
&lt;p&gt;Allocators can save you time elsewhere, too, as asking the OS for more memory, which a zone needs to do whenever it fills up, is another costly operation if it’s done a lot. Much quicker is to ask for huge chunks of memory at a time, and you can tell your NSZone what to do here as well.&lt;/p&gt;
&lt;p&gt;Rumor has it that NSZone could save you deallocation time in the Good Old Days, too, with a method that simply chucks away all the allotted memory without bothering to call deallocators. If a set of objects is self-contained, this could save a lot of time, as you can chuck them all away at style=”font-weight:bold”&amp;gt;NSZone method (NSRecycleZone) carefully puts all the objects in a zone neatly style=”font-weight:bold”&amp;gt;NSZone. Not exactly a huge time-saver.&lt;/p&gt;
&lt;p&gt;So, in summary, zones save you time in mass allocations. &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSZone 是苹果对内存分配和释放的优化方式。NSZone不是一个对象；它是一个难懂的C结构，它被用于纪录关于内存处理（管理）一系列对象的信息。你几乎不需要担忧你自己的应用（applications）是怎样管理你自己的空间（zones）的 ；Cocoa透明地管理它。默认的NSZone在程序启动和所有对象被分配时创建。&lt;br&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>错误类error的学习</title>
    <link href="http://yoursite.com/2016/04/22/%E9%94%99%E8%AF%AF%E7%B1%BBerror%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/04/22/错误类error的学习/</id>
    <published>2016-04-22T14:24:31.000Z</published>
    <updated>2016-04-22T14:25:03.000Z</updated>
    
    <content type="html">&lt;p&gt;获取系统的错误信息 &lt;/p&gt;
&lt;p&gt;比如移动文件时，获取文件操作错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NSError *e = nil;
  [[NSFileManager defaultManager] moveItemAtPath:sourcePath toPath:targetPath error:&amp;amp;e];
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
先定一个空的错误信息
  NSError *e = nil;
取地址
  &amp;amp;e   
如果有错误信息，打印错误的本地化描述
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;自定义错误信息&quot;&gt;&lt;a href=&quot;#自定义错误信息&quot; class=&quot;headerlink&quot; title=&quot;自定义错误信息&quot;&gt;&lt;/a&gt;自定义错误信息&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;通常可以通过下面语句，自定义个NSError对象

   #define CustomErrorDomain @&amp;quot;com.xiaodao.test&amp;quot;
     typedef enum {

   　　  XDefultFailed = -1000,
   　　  XRegisterFailed,
   　　  XConnectFailed,
   　　  XNotBindedFailed
     }CustomErrorFailed;

   NSDictionary *userInfo = [NSDictionary dictionaryWithObject:@&amp;quot;is a error test&amp;quot;                                                                      forKey:NSLocalizedDescriptionKey];
   NSError *aError = [NSError errorWithDomain:CustomErrorDomain code:XDefultFailed userInfo:userInfo];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，自定义错误域对象CustomErrorDomain，通常用域名反写，也可以是任何其他字符串code错误标识, 系统的code一般都大于零，自定code可以用枚举（最好用负数, 但不是必须的）userInfo自定义错误信息，NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述可以通过NSError的localizedDescription方法获得对应的值信息&lt;/p&gt;
&lt;p&gt;主调用函数一般传入NSError指针的指针，来获取错误信息，例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (Bool)doSomething:(NSDictionary *)parameter1 error:(NSError **)aError
{
   //TODO: do something
　　*aError = [NSError errorWithDomain:CustomErrorDomain code:XDefultFailed userInfo:userInfo];
　　return Yes;

}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSError头文件解析&quot;&gt;&lt;a href=&quot;#NSError头文件解析&quot; class=&quot;headerlink&quot; title=&quot;NSError头文件解析&quot;&gt;&lt;/a&gt;NSError头文件解析&lt;/h3&gt;&lt;h4 id=&quot;NSError对象中，主要有三个私有变量&quot;&gt;&lt;a href=&quot;#NSError对象中，主要有三个私有变量&quot; class=&quot;headerlink&quot; title=&quot;NSError对象中，主要有三个私有变量&quot;&gt;&lt;/a&gt;NSError对象中，主要有三个私有变量&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;错误域（NSInteger）： _domain

错误标示（NSString *）：_code

错误详细信息（NSDictionary *）：_userInfo

通常用_domain和_code一起标识一个错误信息


获取_domain
- (NSString *)domain;

获取 _code
- (NSInteger)code;

获取 _userInfo
- (NSDictionary *)userInfo;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;预定义域&quot;&gt;&lt;a href=&quot;#预定义域&quot; class=&quot;headerlink&quot; title=&quot;预定义域&quot;&gt;&lt;/a&gt;预定义域&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;AppKit和Foundation库中主要的错误域
     NSString *const NSCocoaErrorDomain;

其他域
     NSString *const NSPOSIXErrorDomain;
     NSString *const NSOSStatusErrorDomain;
     NSString *const NSMachErrorDomain;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;预定义的userinfo键名&quot;&gt;&lt;a href=&quot;#预定义的userinfo键名&quot; class=&quot;headerlink&quot; title=&quot;预定义的userinfo键名&quot;&gt;&lt;/a&gt;预定义的userinfo键名&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;推荐的标准方式，通用键
    NSString *const NSUnderlyingErrorKey;

其他键，对应各自读取信息的方法：

详细描述键
    NSString *const NSLocalizedDescriptionKey;

取方法
   - (NSString *)localizedDescription;

失败原因键
    NSString *const NSLocalizedFailureReasonErrorKey

取方法
    - (NSString *)localizedFailureReason;

恢复建议键
    NSString *const NSLocalizedRecoverySuggestionErrorKey;

取方法
    - (NSString *)localizedRecoverySuggestion;

恢复选项键
    NSString *const NSLocalizedRecoveryOptionsErrorKey

取方法
    - (NSArray *)localizedRecoveryOptions;

其他键
    NSString *const NSRecoveryAttempterErrorKey; 
    NSString *const NSHelpAnchorErrorKey;
    NSString *const NSStringEncodingErrorKey ;
    NSString *const NSURLErrorKey;
    NSString *const NSFilePathErrorKey;
用法：
NSDictionary *userInfo ＝ [NSDictionary dictionaryWithObjectsAndKeys:@&amp;quot;这是错误详细的描述信息&amp;quot;, NSLocalizedDescriptionKey, error, NSUnderlyingErrorKey, nil]];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;主要的初始化方法：&quot;&gt;&lt;a href=&quot;#主要的初始化方法：&quot; class=&quot;headerlink&quot; title=&quot;主要的初始化方法：&quot;&gt;&lt;/a&gt;主要的初始化方法：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (id)initWithDomain:(NSString *)domain code:(NSInteger)code userInfo:(NSDictionary *)dict;
+ (id)errorWithDomain:(NSString *)domain code:(NSInteger)code userInfo:(NSDictionary *)dict;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;获取系统的错误信息 &lt;/p&gt;
&lt;p&gt;比如移动文件时，获取文件操作错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  NSError *e = nil;
  [[NSFileManager defaultManager] moveItemAtPath:sourcePath toPath:targetPath error:&amp;amp;e];
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
先定一个空的错误信息
  NSError *e = nil;
取地址
  &amp;amp;e   
如果有错误信息，打印错误的本地化描述
  if (e) {
  　　NSLog(@&amp;quot;move failed:%@&amp;quot;, [e localizedDescription]);
  }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS程序的五种状态</title>
    <link href="http://yoursite.com/2016/04/22/iOS%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2016/04/22/iOS程序的五种状态/</id>
    <published>2016-04-22T14:21:54.000Z</published>
    <updated>2016-04-22T14:23:20.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;IOS应用程序5种状态&quot;&gt;&lt;a href=&quot;#IOS应用程序5种状态&quot; class=&quot;headerlink&quot; title=&quot;IOS应用程序5种状态&quot;&gt;&lt;/a&gt;IOS应用程序5种状态&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Not running:应用还没有启动，或者应用正在运行但是途中被系统停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inactive:当前应用正在前台运行，但是并不接收事件（当前 或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不 同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时 间比较长的情况是：当用户 锁屏时，或者系统提示用户去响应某 些（诸如电话来电、有未读短信等）事件的时候。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Active:当前应用正在前台运行，并且接收事件。这是应用正在前台运行时所处的正常状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Background:应用处在后台，并且还在执行代码。大多数将 要进入Suspended状态的应用，会先短暂进入此状态。然而，对于请求 需要额外的执行时间的应用，会在此状态保持更长一段时间。另外， 如果一个应用要 求启动时直接进入后台运行，这样的应用会直接 从Not running状态进入Background状态，中途不会经过Inactive状 态。比如没有界面的应用。注此处并不特指没有界面的应用，其实 也可以是 有界面的应用，只是如果要直接进入background状态的 话，该应用界面不会被显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Suspended:应用处在后台，并且已停止执行代码。系统自动 的将应用移入此状态，且在此举之前不会对应用做任何通知。当处在 此状态时，应用依然驻留内存但不执行任何程序代码。当系统发生 低内存告警时，系统将会将处 于Suspended状态的应用清除出内 存以为正在前台运行的应用提供足够的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IOS应用程序5种状态&quot;&gt;&lt;a href=&quot;#IOS应用程序5种状态&quot; class=&quot;headerlink&quot; title=&quot;IOS应用程序5种状态&quot;&gt;&lt;/a&gt;IOS应用程序5种状态&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Not running:应用还没有启动，或者应用正在运行但是途中被系统停止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Inactive:当前应用正在前台运行，但是并不接收事件（当前 或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不 同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时 间比较长的情况是：当用户 锁屏时，或者系统提示用户去响应某 些（诸如电话来电、有未读短信等）事件的时候。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［iOS］" scheme="http://yoursite.com/tags/%EF%BC%BBiOS%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>单例UIApplication-总结</title>
    <link href="http://yoursite.com/2016/04/22/%E5%8D%95%E4%BE%8BUIApplication-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/04/22/单例UIApplication-总结/</id>
    <published>2016-04-22T14:16:58.000Z</published>
    <updated>2016-04-22T14:21:05.000Z</updated>
    
    <content type="html">&lt;p&gt;If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIKIT_EXTERN int UIApplicationMain (

   int argc, 
   char *argv[], 
   NSString * __nullable principalClassName, 
   NSString * __nullable delegateClassName
);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责-三件-事情：&quot;&gt;&lt;a href=&quot;#那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责-三件-事情：&quot; class=&quot;headerlink&quot; title=&quot;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责 三件 事情：&quot;&gt;&lt;/a&gt;那么UIApplicationMain函数到底做了哪些事情呢？这个函数主要负责 三件 事情：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1）从给定的类名初始化应用程序对象，也就是初始化UIApplication或者子类对象的一个实例，
如果你在这里给定的是nil，那么 系统会默认UIApplication类，也就主要是这个类来控制以及协调应用程序的运行。
在后续的工作中，你可以用静态方法sharedApplication 来获取应用程序的句柄。 
2）从给定的应用程序委托类，初始化一个应用程序委托。并把该委托设置为应用程序的委托，这里就有如果传入参数为nil，会调用函数访问 Info.plist文件来寻找主nib文件，获取应用程序委托。 
3）启动主事件循环，并开始接收事件。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;UIApplication（或-者子类）对象的职责，这个对象主要做下面几件事：&quot;&gt;&lt;a href=&quot;#UIApplication（或-者子类）对象的职责，这个对象主要做下面几件事：&quot; class=&quot;headerlink&quot; title=&quot;UIApplication（或 者子类）对象的职责，这个对象主要做下面几件事：&quot;&gt;&lt;/a&gt;UIApplication（或 者子类）对象的职责，这个对象主要做下面几件事：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1）负责处理到来的用户事件，并分发事件消息到应该处理该消息的目标对象（sender,  action)。 
2）管理以及控制视图，包括呈现、控制行为、当前显示视图等。 
3）该对象有一个应用程序委托对象，当一些生命周期内重要事件（可以包括系统事件或者生命周期控制事件）发生时，应用程序通知该对象。
例如，应用程序启动、内存不够了或者应用程序结束等，让这些事件发生时，应用程序委托去响应。 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot;&gt;&lt;a href=&quot;#我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot; class=&quot;headerlink&quot; title=&quot;我们可以从应用程序的单例类对象中得到应用程序委托的对象&quot;&gt;&lt;/a&gt;我们可以从应用程序的单例类对象中得到应用程序委托的对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UIApplicationDelegate* myDelegate = [[UIApplication sharedApplication] delegate]; 

UIApplication 接收到所有的系统事件和生命周期事件时，都会把事件传递给UIApplicationDelegate进行处理，
对于用户输入 事件，则传递给相应的目标对象去处理
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;创建UIApplication对象并指定其代理&quot;&gt;&lt;a href=&quot;#创建UIApplication对象并指定其代理&quot; class=&quot;headerlink&quot; title=&quot;创建UIApplication对象并指定其代理&quot;&gt;&lt;/a&gt;创建UIApplication对象并指定其代理&lt;/h3&gt;&lt;p&gt;通过UIApplicationMain函数创建UIApplication对象并 指定其代理对象AppDelegate;第三个参数为指定 UIApplication的子类来生成UIApplication对象，为nil时由 UIApplication类初始化默认对象；第四个参数为指定代理 对象。&lt;/p&gt;
&lt;h3 id=&quot;UIApplication的代理对象&quot;&gt;&lt;a href=&quot;#UIApplication的代理对象&quot; class=&quot;headerlink&quot; title=&quot;UIApplication的代理对象&quot;&gt;&lt;/a&gt;UIApplication的代理对象&lt;/h3&gt;&lt;p&gt;作为UIApplication的代理类，必须要先实现 UIApplicationDelegate协议，协议里明确了作为代理应 该做或可以做哪些事情。 UIApplication对象负责监听应用程序的生命周期事件， 并将生命周期事件交由UIApplication代理对象处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;If nil is specified for principalClassName, the value for NSPrincipalClass from the Info.plist is used. If there is no NSPrincipalClass key specified, the UIApplication class is used. The delegate class will be instantiated using init.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIKIT_EXTERN int UIApplicationMain (

   int argc, 
   char *argv[], 
   NSString * __nullable principalClassName, 
   NSString * __nullable delegateClassName
);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC关键字</title>
    <link href="http://yoursite.com/2016/04/15/OC%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/04/15/OC关键字/</id>
    <published>2016-04-15T14:50:55.000Z</published>
    <updated>2016-04-15T14:53:08.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;import和-include的区别&quot;&gt;&lt;a href=&quot;#import和-include的区别&quot; class=&quot;headerlink&quot; title=&quot;#import和#include的区别&quot;&gt;&lt;/a&gt;#import和#include的区别&lt;/h3&gt;&lt;p&gt;  当我们在代码中使用两次#include的时候会报错：因为#include相当于拷贝头文件中的声明内容，所以会报重复定义的错误但是使用两次#import的话，不会报错，所以他可以解决重复导入的问题，他会做一次判断，如果已经导入一次就不导入了&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;class&quot;&gt;&lt;a href=&quot;#class&quot; class=&quot;headerlink&quot; title=&quot;@class&quot;&gt;&lt;/a&gt;@class&lt;/h3&gt;&lt;p&gt;  不会将Student.h拷贝过来，只是告诉编译器Student这个类在别的地方中有定义，这样就不知道这个类中任何信息(哪些属性和方法) &lt;/p&gt;
&lt;p&gt;#import指令是Object-C针对#include的改进版本，#import确保引用的文件只会被引用一次，这样就不会陷入递归包含的问题中。&lt;/p&gt;
&lt;h3 id=&quot;import与-class二者的区别在于：&quot;&gt;&lt;a href=&quot;#import与-class二者的区别在于：&quot; class=&quot;headerlink&quot; title=&quot;#import与@class二者的区别在于：&quot;&gt;&lt;/a&gt;#import与@class二者的区别在于：&lt;/h3&gt;&lt;p&gt;　　 &lt;/p&gt;
&lt;p&gt; #import会链入该头文件的全部信息，包括实体变量和方法等；而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑。在头文件中， 一般只需要知道被引用的类的名称就可以了。&lt;br&gt;　　&lt;br&gt; 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;import和-include的区别&quot;&gt;&lt;a href=&quot;#import和-include的区别&quot; class=&quot;headerlink&quot; title=&quot;#import和#include的区别&quot;&gt;&lt;/a&gt;#import和#include的区别&lt;/h3&gt;&lt;p&gt;  当我们在代码中使用两次#include的时候会报错：因为#include相当于拷贝头文件中的声明内容，所以会报重复定义的错误但是使用两次#import的话，不会报错，所以他可以解决重复导入的问题，他会做一次判断，如果已经导入一次就不导入了&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OC的实例方法和类方法的区别</title>
    <link href="http://yoursite.com/2016/04/15/OC%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/15/OC的实例方法和类方法的区别/</id>
    <published>2016-04-15T14:48:32.000Z</published>
    <updated>2016-04-15T14:50:21.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;-对象方法&lt;/strong&gt; 即OO的基本精神之一 —— 封装／信息隐藏，这个需要你对OO有理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+类方法&lt;/strong&gt; 一般用作命名空间，用以组织一组功能函数；又或用作类的工厂函数，用以产生类的对象；不管哪种，都需要有大型项目的经验，才知道如何组织程序的复杂性及使用设计模式&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;类方法和实例方法&quot;&gt;&lt;a href=&quot;#类方法和实例方法&quot; class=&quot;headerlink&quot; title=&quot;类方法和实例方法&quot;&gt;&lt;/a&gt;类方法和实例方法&lt;/h3&gt;&lt;p&gt;实例方法是— ， 类开头是+&lt;br&gt;实例方法是用实例对象访问，类方法的对象是类而不是实例，通常创建对象或者工具类。&lt;/p&gt;
&lt;p&gt;在实例方法里，根据继承原理发送消息给self和super其实都是发送给self&lt;/p&gt;
&lt;p&gt;在类方法里面self是其他的类的类方法，在类方法中给self发送消息只能发类方法，self是类super也是&lt;/p&gt;
&lt;p&gt;什么时候用类方法：要创建一个实例时候获取一个共享实例，或者获取关于类的一些共有信息&lt;/p&gt;
&lt;p&gt;1、类方法是属于整个类，而不属于某个对象。&lt;br&gt;2、类方法只能访问类成员变量，不能访问实例变量，而实例方法可以访问类成员变量和实例变量。&lt;br&gt;3、类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问。&lt;br&gt;4、类方法只能访问类方法，而实例方法可以访问类方法和实例方法。&lt;br&gt;5、类方法不能被覆盖，实例方法可以被覆盖。 &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;-对象方法&lt;/strong&gt; 即OO的基本精神之一 —— 封装／信息隐藏，这个需要你对OO有理解&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+类方法&lt;/strong&gt; 一般用作命名空间，用以组织一组功能函数；又或用作类的工厂函数，用以产生类的对象；不管哪种，都需要有大型项目的经验，才知道如何组织程序的复杂性及使用设计模式&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>NSSet_集合（无序）</title>
    <link href="http://yoursite.com/2016/04/15/NSSet-%E9%9B%86%E5%90%88%EF%BC%88%E6%97%A0%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2016/04/15/NSSet-集合（无序）/</id>
    <published>2016-04-15T14:46:28.000Z</published>
    <updated>2016-04-15T14:47:26.000Z</updated>
    
    <content type="html">&lt;p&gt;NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;//判断是否含有age字符串
if([set containsObject:@&amp;quot;age&amp;quot;]) {
    NSLog(@&amp;quot;set包含age&amp;quot;);
}

//判断set 是否等于set1
if ([set isEqualToSet:set1]) {
    NSLog(@&amp;quot;set 等于 set1&amp;quot;);
}

//判断set是否是否是set1的子集合
if ([set isSubsetOfSet:set1]) {
    NSLog(@&amp;quot;set isSubsetOfSet set1&amp;quot;);
}

//获取所有set对象
NSArray *array = [set allObjects];
NSLog(@&amp;quot;array:%@&amp;quot;, array);

//迭代遍历
NSEnumerator *enumerator = [set objectEnumerator];
for (NSObject *object in enumerator) {
    NSLog(@&amp;quot;set1里的对象:%@&amp;quot;, object);
}

//添加对象到集合里面
[set setByAddingObject:@&amp;quot;123&amp;quot;];

// 类方法处理方式
NSSet *set3 = [NSSet set];
NSSet *set4 = [NSSet setWithObject:@&amp;quot;123&amp;quot;];
NSSet *set5 = [NSSet setWithObjects:@&amp;quot;1&amp;quot;, @&amp;quot;2&amp;quot;, nil];
NSSet *set6 = [NSSet setWithArray:array];
NSSet *set7 = [NSSet setWithSet:set6];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSMutableSet的使用&quot;&gt;&lt;a href=&quot;#NSMutableSet的使用&quot; class=&quot;headerlink&quot; title=&quot;NSMutableSet的使用&quot;&gt;&lt;/a&gt;NSMutableSet的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSMutableSet继承NSSet，它可以使用NSSet的方法。

[NSMutableSet setWithCapacity:6]:创建可变集合对象，并且初始化长度为6。
[set addObject: obj] : 向集合中动态的添加对象。
[set removeObject:obj]:删除集合中的一个对象。
[set removeAllObjects]:删除集合中的所有对象。
[set unionSet:obj]:向集合中添加一个obj集合的所有数据。
[set minusSet:obj]:向集合中删除一个obj集合的所有数据。
[set intersectSet]:向集合中删除一个不包含obj集合的所有数据。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;NSSet和NSMutableSet是无序的, 但是它保证数据的唯一性。当插入相同的数据时，不会有任何效果。从内部实现来说是hash表，所以可以常数时间内查找一个数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中 @synthesize 和 @dynamic 的区别</title>
    <link href="http://yoursite.com/2016/04/14/iOS%E4%B8%AD-synthesize-%E5%92%8C-dynamic-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/14/iOS中-synthesize-和-dynamic-的区别/</id>
    <published>2016-04-14T13:28:35.000Z</published>
    <updated>2016-04-14T13:40:13.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其主要的作用就是用在NSManagerObject对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，core data 框架会在程序运行的时候为此类属性生成getter和setter方法。&lt;/p&gt;
&lt;p&gt;被指定为动态实现的方法的dynamicMethod的参数有如下的要求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A.第一个、第二个参数必须是id、SEL；
B.第三个参数开始，你可以按照原方法（例如：setHeight:(float)）的参数定义。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再接下来，你需要覆盖NSObject 的类方法resolveInstanceMethod，这个方法会把需要动态实现的方法（setHeight:）的选择器传递进来，我们判断一下是否是需要动态实现的选择器，如果是就把处理权转交给dynamicMethod。&lt;/p&gt;
&lt;h3 id=&quot;如何转交呢？&quot;&gt;&lt;a href=&quot;#如何转交呢？&quot; class=&quot;headerlink&quot; title=&quot;如何转交呢？&quot;&gt;&lt;/a&gt;如何转交呢？&lt;/h3&gt;&lt;p&gt;这里我们就要用到运行时函数class_addMethod(Class,SEL,IMP,char[])。&lt;/p&gt;
&lt;p&gt;运行时函数位于objc/runtime.h，正如名字一样，这里面都是C 语言的函数。按照这些函数的功能的不同，主要分为如下几类：操作类型、操作对象、操作协议等。大多数的函数都可以通过名字看出是什么意思，例如：class_addProtocol 动态的为一个类型在运行时增加协议、objc_getProtocol 把一个字符串转换为协议等。&lt;/p&gt;
&lt;p&gt;言归正传，我们来解释一下这里需要用到的class_addmethod 方法，这个方法有四个参数，Class 表示你要为哪个类型增加方法，SEL 参数表示你要增加的方法的选择器，IMP 表示你要添加的方法的运行时的具体实现的函数指针。其实在这里你能够看出SEL 并不能在运行时找到真正要调用的方法，IMP 才可以真正的找到实现方法的。&lt;/p&gt;
&lt;p&gt;现在我们来正式的看以下第四个参数v@:f 的含义，它描述了IMP 指向的函数的描述信息，按照@encode 指令编译之后的字符说明，第一个字符v 表示返回值为void，剩余的字符为dynamicMethod 函数的参数描述，@表示第一个参数id，:自然就是第二个参数SEL，f 就是第三个参数float。由于前面说过动态方法的实现的前两个参数必须是id、SEL，所以第四个参数中的字符串的第二、三个字符一定是@:。我们看到resolveInstanceMethod 方法的返回值为BOOL，也就是这个方法返回YES 表示找到了动态方法的具体实现，否则就表示没有在运行时找到真实的实现，程序就汇报错。&lt;/p&gt;
&lt;p&gt;经过了上面的处理，Objective-C 的运行时只要发现你调用了@dynamic 标注的属性的setter、getter 方法，就会自动到resolveInstanceMethod 里去寻找真实的实现。这也就是说你在main.m 中调用peson.height 的时候，实际上dynamicMethod 函数被调用了。实际上除了@dynamic 标注的属性之外，如果你调用了类型中不存在的方法，也会被 resolveInstanceMethod 或者resolveClassMethod 截获，但由于你没有处理，所以会报告不能识别的消息的错误。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;譬如：从网络下载一个升级包，不需要退出原有的程序，就可以动态的替换掉旧的功能等类似的需求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数－ 函数调用2</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8D-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A82/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数－-函数调用2/</id>
    <published>2016-04-14T13:21:38.000Z</published>
    <updated>2016-04-14T13:47:29.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;补充：respondsToSelector&quot;&gt;&lt;a href=&quot;#补充：respondsToSelector&quot; class=&quot;headerlink&quot; title=&quot;补充：respondsToSelector&quot;&gt;&lt;/a&gt;补充：respondsToSelector&lt;/h3&gt;&lt;p&gt;   +(BOOL)respondsToSelector:(SEL)aSelector &lt;/p&gt;
&lt;p&gt;这个函数大家再熟悉不过了，用来检查对象是否实现了某函数。&lt;/p&gt;
&lt;p&gt;此函数通常是不需要重载的，但是在动态实现了查找过程后，需要重载此函数让对外接口查找动态实现函数的时候返回YES，保证对外接口的行为统一。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; - (BOOL) respondsToSelector:(SEL)aSelector
    {
       if (@selector(setTitle:) == aSelector ||
       @selector(title) == aSelector ||
       @selector(setAuthor:) == aSelector ||
       @selector(author) == aSelector)
      {
        return YES;
      }

       return [super respondsToSelector: aSelector];
    }

  //全局函数
 1.void dynamicMethodIMP(id self, SEL _cmd)
        {
           // implementation ....
        }

 2.+ (BOOL) resolveInstanceMethod:(SEL)aSEL
       {
        if (aSEL == @selector(resolveThisMethodDynamically))
        {
            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &amp;quot;v@:&amp;quot;);
            return YES;
         }
         return [super resolveInstanceMethod:aSel];
       }

  //将消息转出某对象
3.- (id)forwardingTargetForSelector:(SEL)aSelector
      {
       NSLog(@&amp;quot;MyTestObject _cmd: %@&amp;quot;, NSStringFromSelector(_cmd));

        NoneClass *none = [[NoneClass alloc] init];
        if ([none respondsToSelector: aSelector]) {
          return none;
       }

       return [super forwardingTargetForSelector: aSelector];
      }

4.- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector
    {
      NSString *sel = NSStringFromSelector(selector);
      if ([sel rangeOfString:@&amp;quot;set&amp;quot;].location == 0) {
        //动态造一个 setter函数
        return [NSMethodSignature signatureWithObjCTypes:&amp;quot;v@:@&amp;quot;];
      } else {
        //动态造一个 getter函数
        return [NSMethodSignature signatureWithObjCTypes:&amp;quot;@@:&amp;quot;];
      }
   }

5.- (void)forwardInvocation:(NSInvocation *)invocation
      {
       //拿到函数名
       NSString *key = NSStringFromSelector([invocation selector]);
       if ([key rangeOfString:@&amp;quot;set&amp;quot;].location == 0) {
          //setter函数形如 setXXX: 拆掉 set和冒号 
          key = [[key substringWithRange:NSMakeRange(3, [key length]-4)] lowercaseString];
          NSString *obj;
          //从参数列表中找到值
          [invocation getArgument:&amp;amp;obj atIndex:2];
          [data setObject:obj forKey:key];
        } else {
          //getter函数就相对简单了，直接把函数名做 key就好了。
          NSString *obj = [data objectForKey:key];
          [invocation setReturnValue:&amp;amp;obj];
        }
      }
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;补充：respondsToSelector&quot;&gt;&lt;a href=&quot;#补充：respondsToSelector&quot; class=&quot;headerlink&quot; title=&quot;补充：respondsToSelector&quot;&gt;&lt;/a&gt;补充：respondsToSelector&lt;/h3&gt;&lt;p&gt;   +(BOOL)respondsToSelector:(SEL)aSelector &lt;/p&gt;
&lt;p&gt;这个函数大家再熟悉不过了，用来检查对象是否实现了某函数。&lt;/p&gt;
&lt;p&gt;此函数通常是不需要重载的，但是在动态实现了查找过程后，需要重载此函数让对外接口查找动态实现函数的时候返回YES，保证对外接口的行为统一。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数－ 函数调用</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8D-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数－-函数调用/</id>
    <published>2016-04-14T13:20:13.000Z</published>
    <updated>2016-04-14T13:48:24.000Z</updated>
    
    <content type="html">&lt;p&gt;  Objective-C是一门动态语言，一个函数是由一个selector(SEL)，和一个implement(IML)组成的。Selector相当于门牌号，而Implement才是真正的住户（函数实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  和现实生活一样，门牌可以随便发（@selector(XXX)），但是不一定都找得到住户，如果找不到系统会给程序几次机会来程序正常运行，实在没出路了才会抛出异常。下图是objc_msgSend调用时，查找SEL的IML的过程。咱们以这个流程为例看看其中涉及的很有用的函数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/img/objc_msgSend.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;resolveInstanceMethod-函数&quot;&gt;&lt;a href=&quot;#resolveInstanceMethod-函数&quot; class=&quot;headerlink&quot; title=&quot;resolveInstanceMethod 函数&quot;&gt;&lt;/a&gt;resolveInstanceMethod 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+ (BOOL)resolveInstanceMethod:(SEL)name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数在运行时(runtime)，没有找到SEL的IML时就会执行。这个函数是给类利用class_addMethod添加函数的机会。根据文档，如果实现了添加函数代码则返回YES，未实现返回NO。&lt;/p&gt;
&lt;h3 id=&quot;forwardingTargetForSelector-函数&quot;&gt;&lt;a href=&quot;#forwardingTargetForSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;forwardingTargetForSelector 函数&quot;&gt;&lt;/a&gt;forwardingTargetForSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;流程到了这里，系统给了个将这个SEL转给其他对象的机会。返回参数是一个对象，如果这个对象非nil、非self的话，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。&lt;/p&gt;
&lt;h3 id=&quot;methodSignatureForSelector-函数&quot;&gt;&lt;a href=&quot;#methodSignatureForSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;methodSignatureForSelector 函数&quot;&gt;&lt;/a&gt;methodSignatureForSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数和后面的forwardInvocation:是最后一个寻找IML的机会。这个函数让重载方有机会抛出一个函数的签名，再由后面的forwardInvocation:去执行。&lt;/p&gt;
&lt;h3 id=&quot;forwardInvocation-函数&quot;&gt;&lt;a href=&quot;#forwardInvocation-函数&quot; class=&quot;headerlink&quot; title=&quot;forwardInvocation 函数&quot;&gt;&lt;/a&gt;forwardInvocation 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真正执行从methodSignatureForSelector:返回的NSMethodSignature。在这个函数里可以将NSInvocation多次转发到多个对象中，这也是这种方式灵活的地方。（forwardingTargetForSelector只能以Selector的形式转向一个对象）&lt;/p&gt;
&lt;h3 id=&quot;doesNotRecognizeSelector-函数&quot;&gt;&lt;a href=&quot;#doesNotRecognizeSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;doesNotRecognizeSelector 函数&quot;&gt;&lt;/a&gt;doesNotRecognizeSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)doesNotRecognizeSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为找不到函数实现的最后一步，NSObject实现这个函数只有一个功能，就是抛出异常。&lt;/p&gt;
&lt;p&gt;虽然理论上可以重载这个函数实现保证不抛出异常（不调用super实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;在一个函数找不到时，Objective-C提供了三种方式去补救：&lt;/p&gt;
&lt;p&gt;1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数&lt;/p&gt;
&lt;p&gt;2、调用forwardingTargetForSelector让别的对象去执行这个函数&lt;/p&gt;
&lt;p&gt;3、调用methodSignatureForSelector（函数符号制造器）和forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。&lt;/p&gt;
&lt;p&gt;如果都不中，调用doesNotRecognizeSelector抛出异常。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  Objective-C是一门动态语言，一个函数是由一个selector(SEL)，和一个implement(IML)组成的。Selector相当于门牌号，而Implement才是真正的住户（函数实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数load 和 initialize</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0load-%E5%92%8C-initialize/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数load-和-initialize/</id>
    <published>2016-04-14T13:17:18.000Z</published>
    <updated>2016-04-14T13:43:09.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;初始化阶段-－－-load-函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-load-函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ load 函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ load 函数&lt;/h3&gt;&lt;p&gt; +(void)load&lt;/p&gt;
&lt;p&gt;当类被引用进程序的时候会执行这个函数。&lt;/p&gt;
&lt;p&gt;在一个程序开始运行之前（在main函数开始执行之前）,在库开始被程序加载，load函数就会开始被执行。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们开发的程序都可以认为是一个库，但是库又不会独立存在（我们的程序还会引用其他库，也可能被其他函数引用），所以库的初始化顺序可以如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 初始化我们引用的库
2. 执行我们自己库的Objective-C的load函数
3. 执行C++和C的static初始化变量
4. 初始化引用我们库的其他库
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在我们的编写的库中，会有很多类重写load函数，他们之间的执行顺序是不确定的。&lt;/p&gt;
&lt;p&gt;当父类和子类都实现load函数时，父类的load函数会被先执行。load函数是系统自动加载的，因此不需要调用父类的load函数，否则父类的load函数会多次执行。&lt;/p&gt;
&lt;p&gt;在Category中写load函数是不会替换原始类中的load函数的，原始类和Category中的load函数都会被执行，原始类的load会先被执行，再执行Category中的load函数。当有多个Category都实现了load函数，这几个load函数执行顺序不确定。&lt;/p&gt;
&lt;h3 id=&quot;初始化阶段-－－-Initialize函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-Initialize函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ Initialize函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ Initialize函数&lt;/h3&gt;&lt;p&gt; +(void)initialize&lt;/p&gt;
&lt;p&gt;当类第一次被执行到的时候这个函数会被执行。&lt;/p&gt;
&lt;p&gt;如果类包含继承关系，父类的initialize函数会比子类先执行。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。&lt;/p&gt;
&lt;p&gt;假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。&lt;/p&gt;
&lt;h3 id=&quot;Load-or-Initialize&quot;&gt;&lt;a href=&quot;#Load-or-Initialize&quot; class=&quot;headerlink&quot; title=&quot;Load or Initialize&quot;&gt;&lt;/a&gt;Load or Initialize&lt;/h3&gt;&lt;p&gt;这两个函数没有交集，也没有执行的先后顺序，他们各自遵循着各自的调用原则。因此在写逻辑的时候，不能有逻辑依赖load函数比initialize函数先行调用。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;将针对于类修改放在intialize中，将针对Category的修改放在load中。&lt;/p&gt;
&lt;p&gt;但是假如我们是修改系统的类，一般会通过添加Category来添加功能，但是如果修改initialize会导致原生的intialize不会执行，所以&lt;strong&gt;放在load中&lt;/strong&gt;会比较妥当。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初始化阶段-－－-load-函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-load-函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ load 函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ load 函数&lt;/h3&gt;&lt;p&gt; +(void)load&lt;/p&gt;
&lt;p&gt;当类被引用进程序的时候会执行这个函数。&lt;/p&gt;
&lt;p&gt;在一个程序开始运行之前（在main函数开始执行之前）,在库开始被程序加载，load函数就会开始被执行。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>定时器NSTimer</title>
    <link href="http://yoursite.com/2016/04/08/%E5%AE%9A%E6%97%B6%E5%99%A8NSTimer/"/>
    <id>http://yoursite.com/2016/04/08/定时器NSTimer/</id>
    <published>2016-04-08T14:13:12.000Z</published>
    <updated>2016-04-08T14:19:48.000Z</updated>
    
    <content type="html">&lt;p&gt;定时器类具有五种初始化方法，包含四种工厂方法和一个实例化方法。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 invocation:invocation repeats:NO];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer2 = [NSTimer scheduledTimerWithTimeInterval:2.0 invocation:invocation repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer3 = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(myLog) userInfo:@”123” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer4 = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(myLog) userInfo:@”456” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer5 = [[NSTimer alloc] initWithFireDate:date interval:2.0 target:self selector:@selector(myLog) userInfo:@”789” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法
 target : 需要执行方法的对象。
 selector : 需要执行的方法
 repeats : 是否需要循环
 userInfo : 用户信息

方法中需要调用的对象：

      NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(initW)]];
      [invocation setTarget:self];
      [invocation setSelector:@selector(myLog)];

  需要分别实现 **initW **和 **myLog** 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;将-NSTimer-对象加入Runloop&quot;&gt;&lt;a href=&quot;#将-NSTimer-对象加入Runloop&quot; class=&quot;headerlink&quot; title=&quot;将 NSTimer 对象加入Runloop&quot;&gt;&lt;/a&gt;将 NSTimer 对象加入Runloop&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[NSRunLoop mainRunLoop] addTimer:timer3 forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;释放方法&quot;&gt;&lt;a href=&quot;#释放方法&quot; class=&quot;headerlink&quot; title=&quot;释放方法&quot;&gt;&lt;/a&gt;释放方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[timer invalidate];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;启动方法&quot;&gt;&lt;a href=&quot;#启动方法&quot; class=&quot;headerlink&quot; title=&quot;启动方法&quot;&gt;&lt;/a&gt;启动方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. [timer2 fire];

2. timer4.fireDate = [NSDate distantPast];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;定时器类具有五种初始化方法，包含四种工厂方法和一个实例化方法。
    
    </summary>
    
    
      <category term="［定时器］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>路径类NSURL的使用</title>
    <link href="http://yoursite.com/2016/04/07/%E8%B7%AF%E5%BE%84%E7%B1%BBNSURL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/07/路径类NSURL的使用/</id>
    <published>2016-04-07T13:00:28.000Z</published>
    <updated>2016-04-07T13:01:20.000Z</updated>
    
    <content type="html">&lt;p&gt;NSURL 类作为路径和地址的表示类，在各种场合都发挥很大的作用。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;共有18中初始化方法 （9种实例化方法 + 9种工厂方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init...
URLWith...
fileURLWith...
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;比较方法&quot;&gt;&lt;a href=&quot;#比较方法&quot; class=&quot;headerlink&quot; title=&quot;比较方法&quot;&gt;&lt;/a&gt;比较方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;isEqual:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查询一个NSURL&quot;&gt;&lt;a href=&quot;#查询一个NSURL&quot; class=&quot;headerlink&quot; title=&quot;查询一个NSURL&quot;&gt;&lt;/a&gt;查询一个NSURL&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;checkResourceIsReachableAndReturnError:  返回一个文件URL指向的资源是否可达
isFileReferenceURL
isFileURL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h3&gt;&lt;p&gt;NSURLFileScheme  : 文件URL的scheme&lt;br&gt;还有一堆文件资源的key，如 属性修改日期、访问日期、内容修改日期、创建日期、自定义Icon、文件标识符、文件类型、文件安全、是否隐藏扩展名、是否是文件夹等&lt;/p&gt;
&lt;h3 id=&quot;NSURL的属性：&quot;&gt;&lt;a href=&quot;#NSURL的属性：&quot; class=&quot;headerlink&quot; title=&quot;NSURL的属性：&quot;&gt;&lt;/a&gt;NSURL的属性：&lt;/h3&gt;&lt;p&gt;例如：scheme、user、password、host、port、path、pathComponents、pathExtension、lastPathComponent、parameterString、fragment&lt;/p&gt;
&lt;h3 id=&quot;get和set-File-System-Resource-Properties-这部分需要加强理解&quot;&gt;&lt;a href=&quot;#get和set-File-System-Resource-Properties-这部分需要加强理解&quot; class=&quot;headerlink&quot; title=&quot;get和set File System Resource Properties(这部分需要加强理解)&quot;&gt;&lt;/a&gt;get和set File System Resource Properties(这部分需要加强理解)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString *size = Nil;
NSError *error = [[NSError alloc] initWithDomain:@&amp;quot;1&amp;quot; code:1 userInfo:Nil];

NSURL *samplePath = [[NSURL alloc] initWithString:@&amp;quot;file://Users/Users/zxq/Desktop/1.pdf&amp;quot;];

//获取文件的大小
[samplePath getResourceValue:&amp;amp;size forKey:NSURLFileSizeKey error:&amp;amp;error];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLTotalFileSizeKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取文件地址
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLPathKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取最后修改的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLCreationDateKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取文件名
[samplePath getResourceValue:&amp;amp;size forKey:NSURLNameKey error:&amp;amp;error];
NSLog(@&amp;quot;Error == %@&amp;quot;, error);
NSLog(@&amp;quot;size == %@&amp;quot;, size);


//是否可达
NSLog(@&amp;quot;%d&amp;quot;, [samplePath checkPromisedItemIsReachableAndReturnError:&amp;amp;error]);

NSLog(@&amp;quot;%d&amp;quot;, [samplePath isFileReferenceURL]);
NSLog(@&amp;quot;%d&amp;quot;, [samplePath isFileURL]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;NSURL 类作为路径和地址的表示类，在各种场合都发挥很大的作用。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;共有18中初始化方法 （9种实例化方法 + 9种工厂方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init...
URLWith...
fileURLWith...
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［NSURL］" scheme="http://yoursite.com/tags/%EF%BC%BBNSURL%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>十个iOS面试问题</title>
    <link href="http://yoursite.com/2016/03/31/%E5%8D%81%E4%B8%AAiOS%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/03/31/十个iOS面试问题/</id>
    <published>2016-03-31T12:01:39.000Z</published>
    <updated>2016-03-31T12:04:57.000Z</updated>
    
    <content type="html">&lt;p&gt;哪一天我能解决这十个问题了，我也算是有小成了，直接上题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;您是否做过异步的网络处理和通讯方面的工作？如果有，能具体介绍一些实现策略么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;哪一天我能解决这十个问题了，我也算是有小成了，直接上题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？
    
    </summary>
    
    
      <category term="iOS 成长之路" scheme="http://yoursite.com/tags/iOS-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>随机数的生成</title>
    <link href="http://yoursite.com/2016/03/31/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2016/03/31/随机数的生成/</id>
    <published>2016-03-31T11:49:15.000Z</published>
    <updated>2016-03-31T11:55:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;如何生成一个-Objective-C-的随机数&quot;&gt;&lt;a href=&quot;#如何生成一个-Objective-C-的随机数&quot; class=&quot;headerlink&quot; title=&quot;如何生成一个 Objective-C 的随机数&quot;&gt;&lt;/a&gt;如何生成一个 Objective-C 的随机数&lt;/h3&gt;&lt;p&gt;   具体而言，产生一个 0 和 N - 1 之间的随机数，使用 arc4random_uniform()，从而避免模偏差(modulo bias)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;0 到 N - 1 之间的随机整数&lt;/p&gt;
&lt;p&gt;  NSUInteger r = arc4random_uniform(N);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;1 到 N 之间的随机整数 &lt;/p&gt;
&lt;p&gt;  NSUInteger r = arc4random_uniform(N) + 1;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;0 到 1 之间的随机浮点数（double）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你要生成一个随机 double 或 float，另一个很好的选择是功能较模糊的 rand48 家族，包括 drand48(3)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;srand48(time(0));
double r = drand48();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 不像 arc4random 函数， rand48 函数在产生随机数之前需要种子的初始值。这个种子函数 srand48(3) 应该只运行一次&lt;/p&gt;
&lt;h4 id=&quot;我如何从一个-NSArray-选择一个随机元素？&quot;&gt;&lt;a href=&quot;#我如何从一个-NSArray-选择一个随机元素？&quot; class=&quot;headerlink&quot; title=&quot;我如何从一个 NSArray 选择一个随机元素？&quot;&gt;&lt;/a&gt;我如何从一个 NSArray 选择一个随机元素？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;if ([array count] &amp;gt; 0) {
  id obj = array[arc4random_uniform([array count])];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;我如何随机排序一个-NSArray？&quot;&gt;&lt;a href=&quot;#我如何随机排序一个-NSArray？&quot; class=&quot;headerlink&quot; title=&quot;我如何随机排序一个 NSArray？&quot;&gt;&lt;/a&gt;我如何随机排序一个 NSArray？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
NSUInteger count = [mutableArray count];

if (count &amp;gt; 1) {
  for (NSUInteger i = count - 1; i &amp;gt; 0; --i) {
      [mutableArray exchangeObjectAtIndex:i withObjectAtIndex:arc4random_uniform((int32_t)(i + 1))];
   }
}
NSArray *randomArray = [NSArray arrayWithArray:mutableArray];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;生成一个随机的小写-NSString&quot;&gt;&lt;a href=&quot;#生成一个随机的小写-NSString&quot; class=&quot;headerlink&quot; title=&quot;生成一个随机的小写 NSString&quot;&gt;&lt;/a&gt;生成一个随机的小写 NSString&lt;/h4&gt;&lt;p&gt;如果你是对一个已知的，连续范围的 Unicode 字符做处理，例如小写字母 (U+0061 — U+007A)，你可以从 char 做一个简单的换算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *letter = [NSString stringWithFormat:@&amp;quot;%c&amp;quot;, arc4random_uniform(26) + &amp;apos;a&amp;apos;];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;从一个-NSString-选择一个随机字符&quot;&gt;&lt;a href=&quot;#从一个-NSString-选择一个随机字符&quot; class=&quot;headerlink&quot; title=&quot;从一个 NSString 选择一个随机字符&quot;&gt;&lt;/a&gt;从一个 NSString 选择一个随机字符&lt;/h4&gt;&lt;p&gt;另外，从一组你选择的字符中来挑选随机字母的一个简单的方法是简单地创建一个包含所有可能的字母的字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *vowels = @&amp;quot;aeiouy&amp;quot;;
NSString *letter = [vowels substringWithRange:NSMakeRange(arc4random_uniform([vowels length]), 1)];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;为什么要使用-arc4random-3-，而不是-rand-3-或-random-3-？&quot;&gt;&lt;a href=&quot;#为什么要使用-arc4random-3-，而不是-rand-3-或-random-3-？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用 arc4random(3)，而不是 rand(3) 或 random(3)？&quot;&gt;&lt;/a&gt;为什么要使用 arc4random(3)，而不是 rand(3) 或 random(3)？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;arc4random 不需要初始种子（用 srand 或 srandom），使它更加容易使用。
arc4random 范围可达 0x100000000 (4294967296)，而 rand 和 random 的上限在 RAND_MAX = 0x7fffffff (2147483647)。
rand 经常定期被周期低位的方式，使其更可预测执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;什么是-rand-3-random-3-和-arc4random-3-，以及它们从哪里来的？&quot;&gt;&lt;a href=&quot;#什么是-rand-3-random-3-和-arc4random-3-，以及它们从哪里来的？&quot; class=&quot;headerlink&quot; title=&quot;什么是 rand(3), random(3), 和 arc4random(3)，以及它们从哪里来的？&quot;&gt;&lt;/a&gt;什么是 rand(3), random(3), 和 arc4random(3)，以及它们从哪里来的？&lt;/h4&gt;&lt;p&gt;rand 是一个标准的 C 函数。&lt;br&gt;random 是定义为 POSIX 标准的一部分。&lt;br&gt;arc4random 是在 BSD 和派生平台。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何生成一个-Objective-C-的随机数&quot;&gt;&lt;a href=&quot;#如何生成一个-Objective-C-的随机数&quot; class=&quot;headerlink&quot; title=&quot;如何生成一个 Objective-C 的随机数&quot;&gt;&lt;/a&gt;如何生成一个 Objective-C 的随机数&lt;/h3&gt;&lt;p&gt;   具体而言，产生一个 0 和 N - 1 之间的随机数，使用 arc4random_uniform()，从而避免模偏差(modulo bias)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;0 到 N - 1 之间的随机整数&lt;/p&gt;
&lt;p&gt;  NSUInteger r = arc4random_uniform(N);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>nil_Nil_NULL和NSNull</title>
    <link href="http://yoursite.com/2016/03/31/nil-Nil-NULL%E5%92%8CNSNull/"/>
    <id>http://yoursite.com/2016/03/31/nil-Nil-NULL和NSNull/</id>
    <published>2016-03-31T11:46:08.000Z</published>
    <updated>2016-03-31T11:55:41.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/img/null_nil.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C用0来作为不存在的原始值，而NULL作为指针(这在指针环境中相当于0)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。虽然它在语义上与NULL不同，但它们在技术上是相等的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在框架层面，Foundation定义了NSNull，即一个类方法+null，它返回一个单独的NSNull对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外，在Foundation/NSObjCRuntime.h中，Nil被定义为指向零的类指针。这个nil的鲜为人知的大写的表兄并不常常出现，但它至少值得注意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;刚被分配的NSObject的内容被设置为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/null_nil.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="nil" scheme="http://yoursite.com/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C的警告</title>
    <link href="http://yoursite.com/2016/03/31/Objective-C%E7%9A%84%E8%AD%A6%E5%91%8A/"/>
    <id>http://yoursite.com/2016/03/31/Objective-C的警告/</id>
    <published>2016-03-31T11:41:07.000Z</published>
    <updated>2016-03-31T12:05:53.000Z</updated>
    
    <content type="html">&lt;p&gt;Apple LLVM 7.0 - Warning - objective C &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Direct userage of ‘isa’                  直接使用 isa&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Duplicate Method Definitions             重复的方法定义   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implict Atomic Objective - C Properties  隐式的原子属性&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implict Synthesized Properties           隐式的合成属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Incomplete Objective - C Protocols       不完整的实现协议方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Overridding Deprecated Objective - C Methods  压倒一切弃用的oc方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strict Selector Matching       严格的选择器匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Undeclared Selector            未申报的选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unintentional Root Class       无意的根类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;警告的种类&quot;&gt;&lt;a href=&quot;#警告的种类&quot; class=&quot;headerlink&quot; title=&quot;警告的种类&quot;&gt;&lt;/a&gt;警告的种类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;-Wall 并不是所有警告。这一个警告组开启的是编译器开发者对于“你所写的代码中有问题”这一命题有着很高的自信的那些警告。要是在这一组设定下你的代码出现了警告，那基本上就是你的代码真的存在严重问题了。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;-Wextra 如其所名，-Wextra组提供“额外的”警告。这个组和-Wall组几乎一样有用，但是有些情况下对于代码相对过于严苛。一个很常见的例子是，-Wextra中包含了-Wsign-compare，这个警告标识会开启比较时候对signed和unsigned的类型检查，当比较符两边一边是signed一边是unsigned时，产生警告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-Weverything 这个是真正的所有警告。但是一般开发者不会选择使用这个标识，因为它包含了那些还正在开发中的可能尚存bug的警告提示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;控制警告，局部加入或关闭&quot;&gt;&lt;a href=&quot;#控制警告，局部加入或关闭&quot; class=&quot;headerlink&quot; title=&quot;控制警告，局部加入或关闭&quot;&gt;&lt;/a&gt;控制警告，局部加入或关闭&lt;/h3&gt;&lt;p&gt;Clang提供了我们自己加入警告或者暂时关闭警告的办法。&lt;/p&gt;
&lt;p&gt;强制加入一个警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Generate a warning
#pragma message &amp;quot;Warning 1&amp;quot;

//Another way to generate a warning
#warning &amp;quot;Warning 2&amp;quot;

//Generate an error to fail the build.
#error &amp;quot;Something wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关闭某个警告：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果需要全局关闭的话，直接在Other C Flags里写-Wno-…就行了，比如-Wextra -Wno-sign-compare就是一个常见的组合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果相对某几个文件开启或禁用警告，在Build Phases的Compile Source相应的文件中加入对应的编译标识即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果只是想在某几行关闭某个警告的话，可以通过临时改变诊断编译标记来抑制指定类型的警告，具体如下：&lt;/p&gt;
&lt;p&gt; #pragma clang diagnostic push&lt;br&gt; #pragma clang diagnostic ignored “-Wunused-variable”&lt;br&gt; int a;&lt;br&gt; #pragma clang diagnostic pop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注： 把某些警告当作错误，-Werror=…即可，同样地，也可以在-Werror被激活时使用-Wno-error=…来使某些警告不成为错误。结合使用这些编译标识可以达到很好的控制。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Apple LLVM 7.0 - Warning - objective C &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Direct userage of ‘isa’                  直接使用 isa&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Duplicate Method Definitions             重复的方法定义   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implict Atomic Objective - C Properties  隐式的原子属性&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NS_Enum &amp; NS_Options</title>
    <link href="http://yoursite.com/2016/03/31/NS-Enum-NS-Options/"/>
    <id>http://yoursite.com/2016/03/31/NS-Enum-NS-Options/</id>
    <published>2016-03-31T11:37:57.000Z</published>
    <updated>2016-04-14T13:56:19.000Z</updated>
    
    <content type="html">&lt;p&gt;一个专业的 Objective-C 工程师应该在面向对象和面向过程范式间优雅地切换，同时能够掌握&lt;br&gt;二者的优势。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;    typedef NS_ENUM(NSInteger, UITableViewCellStyle) {         &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  UITableViewCellStyleDefault,
  UITableViewCellStyleValue1,
  UITableViewCellStyleValue2,
  UITableViewCellStyleSubtitle
};
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。&lt;br&gt; 这种实现方法提取了之前各种不同实现的优点，甚至有提示编辑器在进行 switch 判断时检查类型匹配的功能。&lt;/p&gt;
&lt;p&gt;enum 也可以被定义为&lt;strong&gt;按位掩码（bitmask）&lt;/strong&gt;。用简单的OR (|)和AND (&amp;amp;)数学运算即可实现对一个整型值的编码。每一个值不是自动被赋予从0开始依次累加1的值，而是手动被赋予一个带有一个bit偏移量的值：类似1 &amp;lt;&amp;lt; 0、 1 &amp;lt;&amp;lt; 1、 1 &amp;lt;&amp;lt; 2等。如果你能够心算出每个数字的二进制表示法，例如：10110 代表 22，每一位都可以被认为是一个单独的布尔值。例如在UIKit中， UIViewAutoresizing 就是一个可以表示任何flexible top、bottom、 left 或 right margins、width、height组合的位掩码。&lt;/p&gt;
&lt;p&gt;不像 NS_ENUM ，&lt;strong&gt;位掩码用 NS_OPTIONS 宏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。同样的，注意值的区间不要超过所使用类型的最大容纳范围。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一个专业的 Objective-C 工程师应该在面向对象和面向过程范式间优雅地切换，同时能够掌握&lt;br&gt;二者的优势。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;    typedef NS_ENUM(NSInteger, UITableViewCellStyle) {         &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  UITableViewCellStyleDefault,
  UITableViewCellStyleValue1,
  UITableViewCellStyleValue2,
  UITableViewCellStyleSubtitle
};
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>2016年了，要毕业了QAQ</title>
    <link href="http://yoursite.com/2016/03/28/2016%E5%B9%B4%E4%BA%86%EF%BC%8C%E8%A6%81%E6%AF%95%E4%B8%9A%E4%BA%86QAQ/"/>
    <id>http://yoursite.com/2016/03/28/2016年了，要毕业了QAQ/</id>
    <published>2016-03-28T12:28:42.000Z</published>
    <updated>2016-03-28T13:05:49.000Z</updated>
    
    <content type="html">&lt;p&gt;2016年，今年好像又有奥运会了，回想起三年前的那个夏天懵懵懂懂地来到了现在的母校。第一学期过的是那么的开心的，感觉自己的大学好大，里面的女生都好漂亮的，毕竟是师范类院校。在这个大学里面认识了很多人，也尝遍了很多人情事故。记得大学里面很流行的一种风俗，说什么朋友才是陪伴你一生的，其他奖学金，预备党员什么的，学生干部什么的其实都不重要。可是也许我比较另类吧，当了三年的学生干部，也拿了三年的奖学金，所幸也有几个还算好的朋友。&lt;/p&gt;
&lt;p&gt;一年之际在于春，既然如此顺便展望一下我的未来吧！&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2016年，今年应该会成为我成长最快的一年的吧。步入社会，去寻找属于自己的方向。算起来我接触iOS已经有半年多了，洋洋洒洒写下的oc代码也大概有三四万行了。一般的项目也基本不在话下了。最近尝试写了几个小框架，虽然也能算个框架，不过跟yy比起来那真是差的有点太多了。不过我好像是的不知天高地厚的家伙，yy能办到的事也许我一年内办不到，那我一年的努力总应该能达到他的一半多吧。那么我该怎么做呢？如果可以的话，在这一年度里，我的代码量应该达到15万行。然后再学习一下Python这门语言，用它来强化一下我的算法。&lt;/p&gt;
&lt;p&gt;那么就大概安排一下具体的计划：&lt;/p&gt;
&lt;p&gt; 3-4月：将 iOS 可能使用的框架类别理解清楚，还有三四个框架还需要详细了解一下才好。&lt;/p&gt;
&lt;p&gt; 5-7月：大量阅读github 上开源的项目，哈哈，有点题海战术的味道&lt;/p&gt;
&lt;p&gt; 8-10: 这个时候我应该差不多能写出稍微好看一点的框架来吧&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，今年好像又有奥运会了，回想起三年前的那个夏天懵懵懂懂地来到了现在的母校。第一学期过的是那么的开心的，感觉自己的大学好大，里面的女生都好漂亮的，毕竟是师范类院校。在这个大学里面认识了很多人，也尝遍了很多人情事故。记得大学里面很流行的一种风俗，说什么朋友才是陪伴你一生的，其他奖学金，预备党员什么的，学生干部什么的其实都不重要。可是也许我比较另类吧，当了三年的学生干部，也拿了三年的奖学金，所幸也有几个还算好的朋友。&lt;/p&gt;
&lt;p&gt;一年之际在于春，既然如此顺便展望一下我的未来吧！
    
    </summary>
    
    
      <category term="［你好，请多多指教～］" scheme="http://yoursite.com/tags/%EF%BC%BB%E4%BD%A0%E5%A5%BD%EF%BC%8C%E8%AF%B7%E5%A4%9A%E5%A4%9A%E6%8C%87%E6%95%99%EF%BD%9E%EF%BC%BD/"/>
    
  </entry>
  
</feed>
