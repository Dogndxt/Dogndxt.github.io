<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-14T13:51:14.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Core Text 基础2</title>
    <link href="http://yoursite.com/2016/03/14/Core-Text-%E5%9F%BA%E7%A1%802/"/>
    <id>http://yoursite.com/2016/03/14/Core-Text-基础2/</id>
    <published>2016-03-14T13:14:41.000Z</published>
    <updated>2016-03-14T13:51:14.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;二-Core-Text对象模型&quot;&gt;&lt;a href=&quot;#二-Core-Text对象模型&quot; class=&quot;headerlink&quot; title=&quot;二. Core Text对象模型&quot;&gt;&lt;/a&gt;二. Core Text对象模型&lt;/h2&gt;&lt;p&gt;这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/drawflout.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/img/ctstruct.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;framesetter framesetter对应的类型是 CTFramesetter，通过CFAttributedString进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame&lt;/li&gt;
&lt;li&gt;CTFrame CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调&lt;/li&gt;
&lt;li&gt;CTLine 可以看做Core Text绘制中的一行的对象 通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs&lt;/li&gt;
&lt;li&gt;CTRun 或者叫做 Glyph Run，是一组共享想相同attributes（属性）的字形的集合体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面说了这么多对也没一个东西和图片绘制有关系，其实吧，Core Text本身并&lt;strong&gt;不支持图片绘制&lt;/strong&gt;，图片的绘制你还得 &lt;strong&gt;通过Core Graphics&lt;/strong&gt; 来进行。只是Core Text可以通过CTRun的设置为你的图片在文本绘制的过程中留出适当的空间。这个设置就使用到CTRunDelegate了，看这个名字大概就可以知道什么意思了，CTRunDelegate作为CTRun相关属性或操作扩展的一个入口，使得我们可以对CTRun做一些自定义的行为。为图片留位置的方法就是加入一个空白的CTRun，自定义其ascent，descent，width等参数，使得绘制文本的时候留下空白位置给相应的图片。然后图片在相应的空白位置上使用Core Graphics接口进行绘制。 &lt;/p&gt;
&lt;p&gt;使用CTRunDelegateCreate可以创建一个CTRunDelegate，它接收两个参数，一个是callbacks结构体，一个是所有callback调用的时候需要传入的对象。 callbacks的结构体为CTRunDelegateCallbacks，主要是包含一些回调函数，比如有返回当前run的ascent，descent，width这些值的回调函数，至于函数中如何鉴别当前是哪个run，可以在CTRunDelegateCreate的第二个参数来达到目的，因为CTRunDelegateCreate的第二个参数会作为每一个回调调用时的入参。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二-Core-Text对象模型&quot;&gt;&lt;a href=&quot;#二-Core-Text对象模型&quot; class=&quot;headerlink&quot; title=&quot;二. Core Text对象模型&quot;&gt;&lt;/a&gt;二. Core Text对象模型&lt;/h2&gt;&lt;p&gt;这节主要来看看Core Text绘制的一些细节问题了，首先是Core Text绘制的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/drawflout.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="informal" scheme="http://yoursite.com/tags/informal/"/>
    
  </entry>
  
  <entry>
    <title>Core Text 基础</title>
    <link href="http://yoursite.com/2016/03/14/Core-Text-%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2016/03/14/Core-Text-基础/</id>
    <published>2016-03-14T13:05:46.000Z</published>
    <updated>2016-03-14T13:50:40.000Z</updated>
    
    <content type="html">&lt;p&gt; Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-Core-Text知识准备&quot;&gt;&lt;a href=&quot;#一-Core-Text知识准备&quot; class=&quot;headerlink&quot; title=&quot;一. Core Text知识准备&quot;&gt;&lt;/a&gt;一. Core Text知识准备&lt;/h2&gt;&lt;p&gt;   在进入任何一个新的编程领域之前，我们肯定要先接触相关的领域模型的知识。比如你软件是进行科学计算的，那么你就必须理解大量的数学原理；如果你的软件是搞银行系统，那么你就得事先了解相关的银行的业务知识。这些都是不可避免的事情。通常情况下领域知识具有较高的通用性。但在特定的环境下，某些知识点也会被特殊处理。 Core Text是用来进行文字精细排版的，所以了解文字相关的知识也不可避免。&lt;/p&gt;
&lt;h3 id=&quot;1-字符（Character）和字形（Glyphs）&quot;&gt;&lt;a href=&quot;#1-字符（Character）和字形（Glyphs）&quot; class=&quot;headerlink&quot; title=&quot;1. 字符（Character）和字形（Glyphs）&quot;&gt;&lt;/a&gt;1. 字符（Character）和字形（Glyphs）&lt;/h3&gt;&lt;p&gt;排版系统中文本显示的一个重要的过程就是字符到字形的转换，字符是信息本身的元素，而字形是字符的图形表征，字符还会有其它表征比如发音。 字符在计算机中其实就是一个编码，某个字符集中的编码，比如Unicode字符集，就囊括了大都数存在的字符。 而字形则是图形，一般都存储在字体文件中，字形也有它的编码，也就是它在字体中的索引。 一个字符可以对应多个字形（不同的字体，或者同种字体的不同样式:粗体斜体等）；多个字符也可能对应一个字形，比如字符的连写（ Ligatures）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/ligatures.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;Roman Ligatures&lt;/p&gt;
&lt;p&gt;下面就来详情看看字形的各个参数也就是所谓的字形度量Glyph Metrics&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/metrics.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/img/metrics2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bounding box（边界框 bbox），这是一个假想的框子，它尽可能紧密的装入字形。&lt;/li&gt;
&lt;li&gt;baseline（基线），一条假想的线,一行上的字形都以此线作为上下位置的参考，在这条线的左侧存在一个点叫做基线的原点.&lt;/li&gt;
&lt;li&gt;ascent（上行高度）从原点到字体中最高（这里的高深都是以基线为参照线的）的字形的顶部的距离，ascent是一个正值&lt;/li&gt;
&lt;li&gt;descent（下行高度）从原点到字体中最深的字形底部的距离，descent是一个负值（比如一个字体原点到最深的字形的底部的距离为2，那么descent就为-2）&lt;/li&gt;
&lt;li&gt;linegap（行距），linegap也可以称作leading（其实准确点讲应该叫做External leading）,行高lineHeight则可以通过 ascent + descent + linegap 来计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-坐标系&quot;&gt;&lt;a href=&quot;#2-坐标系&quot; class=&quot;headerlink&quot; title=&quot;2. 坐标系&quot;&gt;&lt;/a&gt;2. 坐标系&lt;/h3&gt;&lt;p&gt;首先不得不说 苹果编程中的坐标系花样百出，经常让开发者措手不及。 传统的Mac中的坐标系的原点在左下角，比如NSView默认的坐标系，原点就在左下角。但Mac中有些View为了其实现的便捷将原点变换到左上角，像NSTableView的坐标系坐标原点就在左上角。iOS UIKit的UIView的坐标系原点在左上角。&lt;br&gt;往底层看，Core Graphics的context使用的坐标系的原点是在左下角。而在iOS中的底层界面绘制就是通过Core Graphics进行的，那么坐标系列是如何变换的呢？ 在UIView的drawRect方法中我们可以通过UIGraphicsGetCurrentContext()来获得当前的Graphics Context。drawRect方法在被调用前，这个Graphics Context被创建和配置好，你只管使用便是。如果你细心，通过CGContextGetCTM(CGContextRef c)可以看到其返回的值并不是CGAffineTransformIdentity，通过打印出来看到值为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Printing description of contextCTM:
(CGAffineTransform) contextCTM = {
       a = 1
       b = 0
       c = 0
       d = -1
      tx = 0
      ty = 460
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是非retina分辨率下的结果，如果是如果是retina上面的a,d,ty的值将会乘2，如果是iPhone 5，ty的值会再大些。 但是作用都是一样的就是将上下文空间坐标系进行了flip，使得原本左下角原点变到左上角，y轴正方向也变换成向下。&lt;/p&gt;
&lt;p&gt;上面说了一大堆，下面进入正题，Core Text一开始便是定位于桌面的排版系统，使用了传统的原点在左下角的坐标系，所以它在绘制文本的时候都是参照左下角的原点进行绘制的。 但是iOS的UIView的drawRect方法的context被做了次flip，如果你啥也不做处理，直接在这个context上进行Core Text绘制，你会发现文字是镜像且上下颠倒。 &lt;/p&gt;
&lt;p&gt;所以在UIView的drawRect方法中的context上进行Core Text绘制之前需要对context&lt;strong&gt;进行一次Flip&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里再提及一个函数CGContextSetTextMatrix，它可以用来为每一个显示的字形单独设置变形矩阵。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-NSMutableAttributedString-和-CFMutableAttributedStringRef&quot;&gt;&lt;a href=&quot;#3-NSMutableAttributedString-和-CFMutableAttributedStringRef&quot; class=&quot;headerlink&quot; title=&quot;3. NSMutableAttributedString 和 CFMutableAttributedStringRef&quot;&gt;&lt;/a&gt;3. NSMutableAttributedString 和 CFMutableAttributedStringRef&lt;/h3&gt;&lt;p&gt;Core Foundation和Foundation中的有些数据类型只需要简单的强制类型转换就可以互换使用，这类类型我们叫他们为 Toll-Free Bridged Types。 CFMutableAttributedStringRef和NSMutableAttributedString就是其中的一对，Core Foundation的接口基本是C的接口，功能强大，但是使用起来没有Foundation中提供的Objc的接口简单好使，所以很多时候我们可以使用高层接口组织数据，然后将其传给低层函数接口使用。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Core Text是和Core Graphics配合使用的，一般是在UIView的drawRect方法中的Graphics Context上进行绘制的。 且Core Text真正负责绘制的是文本部分，图片还是需要自己去手动绘制，所以你必须关注很多绘制的细节部分。
    
    </summary>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
