<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-10T12:15:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 使用Cycript进行运行时分析</title>
    <link href="http://yoursite.com/2017/04/10/iOS-%E4%BD%BF%E7%94%A8Cycript%E8%BF%9B%E8%A1%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/04/10/iOS-使用Cycript进行运行时分析/</id>
    <published>2017-04-10T12:14:50.000Z</published>
    <updated>2017-04-10T12:15:45.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;获得进程-PID&quot;&gt;&lt;a href=&quot;#获得进程-PID&quot; class=&quot;headerlink&quot; title=&quot;获得进程 PID&quot;&gt;&lt;/a&gt;获得进程 PID&lt;/h3&gt;&lt;p&gt;在越狱设备中开启某个项目，并切回到越狱设备的终端，找到项目的进程编号 PID。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ps aux | grep &amp;quot;项目名&amp;quot;

＊ mobile    3098   0.0  2.6   636116  25480   ??  Ss    3:51PM   0:02.18 /Applications/AutoGetRedPacket.app/AutoGetRedPacket
＊ root      3140   0.0  0.0   525864    200 s000  R+    4:17PM   0:00.01 grep AutoGetRedPacket
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  找到 mobile 对应的 PID 949，之后利用 Cycript 进行运行时分析&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;使用-Cycript&quot;&gt;&lt;a href=&quot;#使用-Cycript&quot; class=&quot;headerlink&quot; title=&quot;使用 Cycript&quot;&gt;&lt;/a&gt;使用 Cycript&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;cycript -p PID   执行之后进入相应的进程
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;使用Cycript有如下好处：&quot;&gt;&lt;a href=&quot;#使用Cycript有如下好处：&quot; class=&quot;headerlink&quot; title=&quot;使用Cycript有如下好处：&quot;&gt;&lt;/a&gt;使用Cycript有如下好处：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. 我们能够挂钩正在运行的进程，并且找出正被使用的类信息，例如view controllers，内部和第3方库，甚至程序的delegate的名称。
2. 对于一个特定的类，例如View Controller, App delegate或者任何其他的类，我们能够得到所有被使用的方法名称。
3. 我们能够得到所有实例变量的名称和在程序运行的任意时刻实例变量的值。
4. 我们能够在运行时修改实例变量的值。
5. 我们能够执行Method Swizzling，例如替换一个特定方法的实现。
6. 我们可以在运行时调用任意方法，即使这个方法目前并不在应用的实际代码当中。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Cycript高级技巧   &lt;a href=&quot;http://www.jianshu.com/p/fbb824c285d0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/fbb824c285d0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cycript Tricks   &lt;a href=&quot;http://iphonedevwiki.net/index.php/Cycript_Tricks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://iphonedevwiki.net/index.php/Cycript_Tricks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;获得进程-PID&quot;&gt;&lt;a href=&quot;#获得进程-PID&quot; class=&quot;headerlink&quot; title=&quot;获得进程 PID&quot;&gt;&lt;/a&gt;获得进程 PID&lt;/h3&gt;&lt;p&gt;在越狱设备中开启某个项目，并切回到越狱设备的终端，找到项目的进程编号 PID。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; ps aux | grep &amp;quot;项目名&amp;quot;

＊ mobile    3098   0.0  2.6   636116  25480   ??  Ss    3:51PM   0:02.18 /Applications/AutoGetRedPacket.app/AutoGetRedPacket
＊ root      3140   0.0  0.0   525864    200 s000  R+    4:17PM   0:00.01 grep AutoGetRedPacket
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  找到 mobile 对应的 PID 949，之后利用 Cycript 进行运行时分析&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AFNetWorking是如何进行数据缓存的--之AFImageCache &amp; NSURLCache 详解</title>
    <link href="http://yoursite.com/2017/04/10/AFNetWorking%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E7%9A%84-%E4%B9%8BAFImageCache-NSURLCache-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/04/10/AFNetWorking是如何进行数据缓存的-之AFImageCache-NSURLCache-详解/</id>
    <published>2017-04-10T12:10:19.000Z</published>
    <updated>2017-04-10T12:11:29.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;AFAutoPurgingImageCache-图片缓存类&quot;&gt;&lt;a href=&quot;#AFAutoPurgingImageCache-图片缓存类&quot; class=&quot;headerlink&quot; title=&quot;AFAutoPurgingImageCache 图片缓存类&quot;&gt;&lt;/a&gt;AFAutoPurgingImageCache 图片缓存类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;缓存机制: 这个类通过 
@property (nonatomic, strong) NSMutableDictionary &amp;lt;NSString* , AFCachedImage*&amp;gt; *cachedImages;

这个字典属性进行图片数据的存储。每一张图片对于唯一的一个标示字符串，如果是请求链接则将链接作为键值。添加图片的时候会计算图片的大小，进行存储空间的控制，超过初始化的大小进行时间排序，久的图片的删除，或者收到内存警告的时候，则清除所有的图片。
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;AFImageDownloader-图片下载类&quot;&gt;&lt;a href=&quot;#AFImageDownloader-图片下载类&quot; class=&quot;headerlink&quot; title=&quot;AFImageDownloader 图片下载类&quot;&gt;&lt;/a&gt;AFImageDownloader 图片下载类&lt;/h5&gt;&lt;h3 id=&quot;清除本地请求数据的缓存&quot;&gt;&lt;a href=&quot;#清除本地请求数据的缓存&quot; class=&quot;headerlink&quot; title=&quot;清除本地请求数据的缓存&quot;&gt;&lt;/a&gt;清除本地请求数据的缓存&lt;/h3&gt;&lt;p&gt;可以禁用NSURLCache，只需要将内存和磁盘空间设置为0就行了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:0
                                                        diskCapacity:0
                                                            diskPath:nil];
[NSURLCache setSharedURLCache:sharedCache];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AFAutoPurgingImageCache-图片缓存类&quot;&gt;&lt;a href=&quot;#AFAutoPurgingImageCache-图片缓存类&quot; class=&quot;headerlink&quot; title=&quot;AFAutoPurgingImageCache 图片缓存类&quot;&gt;&lt;/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Charles 从入门到精通</title>
    <link href="http://yoursite.com/2017/04/10/Charles-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>http://yoursite.com/2017/04/10/Charles-从入门到精通/</id>
    <published>2017-04-10T12:06:46.000Z</published>
    <updated>2017-04-10T12:16:24.000Z</updated>
    
    <content type="html">&lt;p&gt;Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。&lt;br&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。&lt;br&gt;除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。（&lt;a href=&quot;http://blog.devtang.com/2015/11/14/charles-introduction/）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.devtang.com/2015/11/14/charles-introduction/）&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Charles 主要的功能包括：

1. 截取 Http 和 Https 网络封包。
2. 支持重发网络请求，方便后端调试。
3. 支持修改网络请求参数。
4. 支持网络请求的截获并动态修改。
5. 支持模拟慢速网络。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;安装-Charles&quot;&gt;&lt;a href=&quot;#安装-Charles&quot; class=&quot;headerlink&quot; title=&quot;安装 Charles&quot;&gt;&lt;/a&gt;安装 Charles&lt;/h3&gt;&lt;p&gt;去 Charles 的官方网站（&lt;a href=&quot;http://www.charlesproxy.com）下载最新版的&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.charlesproxy.com）下载最新版的&lt;/a&gt; Charles 安装包，是一个 dmg 后缀的文件。打开后将 Charles 拖到 Application 目录下即完成安装。&lt;/p&gt;
&lt;h3 id=&quot;将-Charles-设置成系统代理&quot;&gt;&lt;a href=&quot;#将-Charles-设置成系统代理&quot; class=&quot;headerlink&quot; title=&quot;将 Charles 设置成系统代理&quot;&gt;&lt;/a&gt;将 Charles 设置成系统代理&lt;/h3&gt;&lt;p&gt;启动 Charles 后，第一次 Charles 会请求你给它设置系统代理的权限。你可以输入登录密码授予 Charles 该权限。你也可以忽略该请求，然后在需要将 Charles 设置成系统代理时，选择菜单中的 “Proxy” -&amp;gt; “Mac OS X Proxy” 来将 Charles 设置成系统代理。&lt;/p&gt;
&lt;h3 id=&quot;Charles-主界面介绍&quot;&gt;&lt;a href=&quot;#Charles-主界面介绍&quot; class=&quot;headerlink&quot; title=&quot;Charles 主界面介绍&quot;&gt;&lt;/a&gt;Charles 主界面介绍&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Charles 主要提供两种查看封包的视图，分别名为 “Structure” 和 “Sequence”。

    1. Structure 视图将网络请求按访问的域名分类。
    2. Sequence 视图将网络请求按访问的时间排序。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;过滤网络请求&quot;&gt;&lt;a href=&quot;#过滤网络请求&quot; class=&quot;headerlink&quot; title=&quot;过滤网络请求&quot;&gt;&lt;/a&gt;过滤网络请求&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;方法一：在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：http://yuantiku.com , 那么只需要在 Filter 栏中填入 yuantiku 即可。

方法二：在 Charles 的菜单栏选择 “Proxy”-&amp;gt;”Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。

方法三：在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;截取-iPhone-上的网络封包&quot;&gt;&lt;a href=&quot;#截取-iPhone-上的网络封包&quot; class=&quot;headerlink&quot; title=&quot;截取 iPhone 上的网络封包&quot;&gt;&lt;/a&gt;截取 iPhone 上的网络封包&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Charles 上的设置&lt;/p&gt;
&lt;p&gt;要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”-&amp;gt;”Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;iPhone 上的设置&lt;/p&gt;
&lt;p&gt;首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&amp;gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址。&lt;/p&gt;
&lt;p&gt;然后在 iPhone 的 “ 设置 “-&amp;gt;” 无线局域网 “ 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有「HTTP 代理」一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;截取-Https-通讯信息&quot;&gt;&lt;a href=&quot;#截取-Https-通讯信息&quot; class=&quot;headerlink&quot; title=&quot;截取 Https 通讯信息&quot;&gt;&lt;/a&gt;截取 Https 通讯信息&lt;/h3&gt;&lt;p&gt;通过网络上的方法设置之后没有成功获取到 https 的数据，暂时搁置。&lt;/p&gt;
&lt;h3 id=&quot;模拟慢速网络&quot;&gt;&lt;a href=&quot;#模拟慢速网络&quot; class=&quot;headerlink&quot; title=&quot;模拟慢速网络&quot;&gt;&lt;/a&gt;模拟慢速网络&lt;/h3&gt;&lt;p&gt;在 Charles 的菜单上，选择 “Proxy”-&amp;gt;”Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型&lt;/p&gt;
&lt;h3 id=&quot;修改网络请求内容&quot;&gt;&lt;a href=&quot;#修改网络请求内容&quot; class=&quot;headerlink&quot; title=&quot;修改网络请求内容&quot;&gt;&lt;/a&gt;修改网络请求内容&lt;/h3&gt;&lt;p&gt;Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。 &lt;/p&gt;
&lt;p&gt;我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图所示）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便。&lt;/p&gt;
&lt;h3 id=&quot;给服务器做压力测试&quot;&gt;&lt;a href=&quot;#给服务器做压力测试&quot; class=&quot;headerlink&quot; title=&quot;给服务器做压力测试&quot;&gt;&lt;/a&gt;给服务器做压力测试&lt;/h3&gt;&lt;p&gt;我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择 「Repeat Advanced」菜单项&lt;/p&gt;
&lt;h3 id=&quot;修改服务器返回内容&quot;&gt;&lt;a href=&quot;#修改服务器返回内容&quot; class=&quot;headerlink&quot; title=&quot;修改服务器返回内容&quot;&gt;&lt;/a&gt;修改服务器返回内容&lt;/h3&gt;&lt;p&gt;有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1. Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。
    2. Rewrite 功能适合对网络请求进行一些正则替换。
    3. Breakpoints 功能适合做一些临时性的修改。


1. Map 功能

  Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。
  在 Charles 的菜单中，选择 “Tools”-&amp;gt;”Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。
  对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将所有 ytk1.yuanku.ws（测试服务器）的请求重定向到了 www.yuantiku.com（线上服务器）。
  对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地，然后稍加修改，成为我们的目标映射文件。


2. Rewrite 功能

  Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。
  例如，我们的客户端有一个 API 请求是获得用户昵称，而我当前的昵称是 “tangqiaoboy”，如下所示：
  我们想试着直接修改网络返回值，将 tangqiaoboy 换成成 iosboy。于是我们启用 Rewrite 功能，然后设置如下的规则：
  完成设置之后，我们就可以从 Charles 中看到，之后的 API 获得的昵称被自动 Rewrite 成了 iosboy


3. Breakpoints 功能

  上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。
  Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。
  下图是我们临时修改获取用户信息的 API，将用户的昵称进行了更改，修改完成后点击 “Execute” 则可以让网络请求继续进行。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Charles 是在 Mac 下常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。&lt;br&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。&lt;br&gt;除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。（&lt;a href=&quot;http://blog.devtang.com/2015/11/14/charles-introduction/）&quot;&gt;http://blog.devtang.com/2015/11/14/charles-introduction/）&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Charles 主要的功能包括：

1. 截取 Http 和 Https 网络封包。
2. 支持重发网络请求，方便后端调试。
3. 支持修改网络请求参数。
4. 支持网络请求的截获并动态修改。
5. 支持模拟慢速网络。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反编译工具</title>
    <link href="http://yoursite.com/2017/04/10/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2017/04/10/反编译工具/</id>
    <published>2017-04-10T12:02:31.000Z</published>
    <updated>2017-04-10T12:05:23.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;WinDbg&quot;&gt;&lt;a href=&quot;#WinDbg&quot; class=&quot;headerlink&quot; title=&quot;WinDbg&quot;&gt;&lt;/a&gt;WinDbg&lt;/h4&gt;&lt;p&gt; WinDbg是微软发布的一款相当优秀的源码级(source-level)调试工具，可以用于Kernel模式调试和用户模式调试，还可以调试Dump文件。&lt;/p&gt;
&lt;h4 id=&quot;OllyDbg&quot;&gt;&lt;a href=&quot;#OllyDbg&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg&quot;&gt;&lt;/a&gt;OllyDbg&lt;/h4&gt;&lt;p&gt;OLLYDBG是一个新的动态追踪工具，将IDA与SoftICE结合起来的思想，Ring 3级调试器，非常容易上手，己代替SoftICE成为当今最为流行的调试解密工具了。同时还支持插件扩展功能，是目前最强大的调试工具。&lt;/p&gt;
&lt;h4 id=&quot;Immunity-Debugger&quot;&gt;&lt;a href=&quot;#Immunity-Debugger&quot; class=&quot;headerlink&quot; title=&quot;Immunity Debugger&quot;&gt;&lt;/a&gt;Immunity Debugger&lt;/h4&gt;&lt;p&gt;Immunity Debugger软件专门用于加速漏洞利用程序的开发，辅助漏洞挖掘以及恶意软件分析。它具备一个完整的图形用户界面，同时还配备了迄今为止最为强的python安全工具库。它巧妙的将动态调试功能与一个强大的静态分析引擎融合于一体，它还附带了一套高度可定制的纯python图形算法，可用于帮助我们绘制出直观的函数体控制流以及函数中的各个基本块。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;PEiD&quot;&gt;&lt;a href=&quot;#PEiD&quot; class=&quot;headerlink&quot; title=&quot;PEiD&quot;&gt;&lt;/a&gt;PEiD&lt;/h4&gt;&lt;p&gt;PEiD(PE Identifier)是一款著名的查壳工具，其功能强大，几乎可以侦测出所有的壳，其数量已超过470 种PE 文档 的加壳类型和签名。&lt;/p&gt;
&lt;h4 id=&quot;ILSpy&quot;&gt;&lt;a href=&quot;#ILSpy&quot; class=&quot;headerlink&quot; title=&quot;ILSpy&quot;&gt;&lt;/a&gt;ILSpy&lt;/h4&gt;&lt;p&gt;ILSpy 是一个开源的.NET反编译工具，简洁强大易用是它的特征。在绝大多数情况下，它都能很好的完成你对未知程序集内部代码的探索。&lt;/p&gt;
&lt;h4 id=&quot;Metasploit&quot;&gt;&lt;a href=&quot;#Metasploit&quot; class=&quot;headerlink&quot; title=&quot;Metasploit&quot;&gt;&lt;/a&gt;Metasploit&lt;/h4&gt;&lt;p&gt;Metasploit是一款开源的安全漏洞检测工具，可以帮助安全和IT专业人士识别安全性问题，验证漏洞的缓解措施，并管理专家驱动的安全性进行评估，提供真正的安全风险情报。这些功能包括智能开发，代码审计，Web应用程序扫描，社会工程。团队合作，在Metasploit和综合报告提出了他们的发现。&lt;/p&gt;
&lt;h4 id=&quot;Putty&quot;&gt;&lt;a href=&quot;#Putty&quot; class=&quot;headerlink&quot; title=&quot;Putty&quot;&gt;&lt;/a&gt;Putty&lt;/h4&gt;&lt;p&gt;PuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。较早的版本仅支持Windows平台，在最近的版本中开始支持各类Unix平台，并打算移植至Mac OS X上。除了官方版本外，有许多第三方的团体或个人将PuTTY移植到其他平台上，像是以Symbian为基础的移动电话。PuTTY为一开放源代码软件，主要由Simon Tatham维护，使用MIT licence授权。随着Linux在服务器端应用的普及，Linux系统管理越来越依赖于远程。在各种远程登录工具中，Putty是出色的工具之一。Putty是一个免费的、Windows x86平台下的Telnet、SSH和rlogin客户端，但是功能丝毫不逊色于商业的Telnet类工具。目前最新的版本为 0.68 latest release&lt;/p&gt;
&lt;h4 id=&quot;WinSCP&quot;&gt;&lt;a href=&quot;#WinSCP&quot; class=&quot;headerlink&quot; title=&quot;WinSCP&quot;&gt;&lt;/a&gt;WinSCP&lt;/h4&gt;&lt;p&gt;WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件&lt;/p&gt;
&lt;h4 id=&quot;C32Asm&quot;&gt;&lt;a href=&quot;#C32Asm&quot; class=&quot;headerlink&quot; title=&quot;C32Asm&quot;&gt;&lt;/a&gt;C32Asm&lt;/h4&gt;&lt;p&gt;c32asm 的确是款非常好用的反汇编程序，小编测试后发现它的功能已强于winhex 16、W32Dasm，具有反汇编模式和十六进制编辑模式，能跟踪exe文件的断点，也可直接修改软件内部代码。&lt;/p&gt;
&lt;h4 id=&quot;010Editor&quot;&gt;&lt;a href=&quot;#010Editor&quot; class=&quot;headerlink&quot; title=&quot;010Editor&quot;&gt;&lt;/a&gt;010Editor&lt;/h4&gt;&lt;p&gt; SweetScape 010 Editor是一个全新的十六进位文件编辑器，它有别於传统的十六进位编辑器在於它可用’范本’来解析二进位文件, 从而让你读懂和编辑它. 它还可用来比较一切可视的二进位文件.&lt;/p&gt;
&lt;h4 id=&quot;SysinternalsSuite&quot;&gt;&lt;a href=&quot;#SysinternalsSuite&quot; class=&quot;headerlink&quot; title=&quot;SysinternalsSuite&quot;&gt;&lt;/a&gt;SysinternalsSuite&lt;/h4&gt;&lt;p&gt;sysinternals 的网站创立于1996年由Mark russinovich和布赖科格斯韦尔主办其先进的系统工具和技术资料·微软于2006年7月收购sysinternals公司 . 不管你是一个IT高级工作者还是一个开发者，你都会发现sysinternals工具可以帮助您管理、故障分析和诊断你的Windows系统和应用程序· 如果您有关于如何使用这些工具的问题，请访问sysinternals论坛从其他用户和我们的团队获取解答和帮助&lt;/p&gt;
&lt;h4 id=&quot;PCHunter&quot;&gt;&lt;a href=&quot;#PCHunter&quot; class=&quot;headerlink&quot; title=&quot;PCHunter&quot;&gt;&lt;/a&gt;PCHunter&lt;/h4&gt;&lt;p&gt; 基于XueTr源码重新开发而来，应该超越了XueTr。&lt;/p&gt;
&lt;h4 id=&quot;InnoExtractor&quot;&gt;&lt;a href=&quot;#InnoExtractor&quot; class=&quot;headerlink&quot; title=&quot;InnoExtractor&quot;&gt;&lt;/a&gt;InnoExtractor&lt;/h4&gt;&lt;p&gt; 使用InnoExtractor能够提取Inno制作的安装包中的文件，直接浏览安装程序的内部文件结构。&lt;br&gt; InnoExtractor(Inno解包工具)能够反编译安装文件的CompiledCode.bin，支持文件拖放、支持输入密码提取、文件查找、支持Unicode等。&lt;/p&gt;
&lt;h4 id=&quot;ApkTool&quot;&gt;&lt;a href=&quot;#ApkTool&quot; class=&quot;headerlink&quot; title=&quot;ApkTool&quot;&gt;&lt;/a&gt;ApkTool&lt;/h4&gt;&lt;p&gt; APKTool是GOOGLE提供的APK编译工具，能够反编译及回编译apk，同时安装反编译系统apk所需要的framework-res框架，清理上次反编译文件夹等功能。需要java支持&lt;/p&gt;
&lt;h4 id=&quot;JD-GUI&quot;&gt;&lt;a href=&quot;#JD-GUI&quot; class=&quot;headerlink&quot; title=&quot;JD-GUI&quot;&gt;&lt;/a&gt;JD-GUI&lt;/h4&gt;&lt;p&gt;JD分为JD-GUI、JD-Eclipse两种运行方式，JD-GUI是以单独的程序的方式运行，JD-Eclipse则是以一个Eclipse插件的方式运行。&lt;/p&gt;
&lt;h4 id=&quot;dex2jar&quot;&gt;&lt;a href=&quot;#dex2jar&quot; class=&quot;headerlink&quot; title=&quot;dex2jar&quot;&gt;&lt;/a&gt;dex2jar&lt;/h4&gt;&lt;p&gt;反编译安卓的软件&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;WinDbg&quot;&gt;&lt;a href=&quot;#WinDbg&quot; class=&quot;headerlink&quot; title=&quot;WinDbg&quot;&gt;&lt;/a&gt;WinDbg&lt;/h4&gt;&lt;p&gt; WinDbg是微软发布的一款相当优秀的源码级(source-level)调试工具，可以用于Kernel模式调试和用户模式调试，还可以调试Dump文件。&lt;/p&gt;
&lt;h4 id=&quot;OllyDbg&quot;&gt;&lt;a href=&quot;#OllyDbg&quot; class=&quot;headerlink&quot; title=&quot;OllyDbg&quot;&gt;&lt;/a&gt;OllyDbg&lt;/h4&gt;&lt;p&gt;OLLYDBG是一个新的动态追踪工具，将IDA与SoftICE结合起来的思想，Ring 3级调试器，非常容易上手，己代替SoftICE成为当今最为流行的调试解密工具了。同时还支持插件扩展功能，是目前最强大的调试工具。&lt;/p&gt;
&lt;h4 id=&quot;Immunity-Debugger&quot;&gt;&lt;a href=&quot;#Immunity-Debugger&quot; class=&quot;headerlink&quot; title=&quot;Immunity Debugger&quot;&gt;&lt;/a&gt;Immunity Debugger&lt;/h4&gt;&lt;p&gt;Immunity Debugger软件专门用于加速漏洞利用程序的开发，辅助漏洞挖掘以及恶意软件分析。它具备一个完整的图形用户界面，同时还配备了迄今为止最为强的python安全工具库。它巧妙的将动态调试功能与一个强大的静态分析引擎融合于一体，它还附带了一套高度可定制的纯python图形算法，可用于帮助我们绘制出直观的函数体控制流以及函数中的各个基本块。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>指纹识别</title>
    <link href="http://yoursite.com/2017/04/10/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/2017/04/10/指纹识别/</id>
    <published>2017-04-10T11:58:09.000Z</published>
    <updated>2017-04-10T12:01:53.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h3&gt;&lt;p&gt;指纹识别功能是 iphone 5S之后推出的, SDK是 iOS 8.0 推出!&lt;br&gt;推出指纹识别功能的目的,是为了简化移动支付环节,占领移动支付市场. 同时可以作为需要较高级别保护用户隐私的 APP 的登录检验方式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**
 指纹识别
 */
- (void)localAuthentication {
    float version = [UIDevice currentDevice].systemVersion.floatValue;

    if (version &amp;lt; 8.0) {
        NSLog(@&amp;quot;系统版本太低,请升级至最新系统&amp;quot;);
        return;
    }

    LAContext *laCtx = [[LAContext alloc] init];
    if (![laCtx canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:nil]) {
        NSLog(@&amp;quot;该设备不支持指纹识别功能&amp;quot;);
        return;
    }
    [laCtx evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:@&amp;quot;指纹登陆&amp;quot; reply:^(BOOL success, NSError * _Nullable error) {
        if (success) {
            NSLog(@&amp;quot;指纹识别成功!&amp;quot;);
        } else {
            NSLog(@&amp;quot;指纹识别错误,请再次尝试&amp;quot;);
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h3&gt;&lt;p&gt;指纹识别功能是 iphone 5S之后推出的, SDK是 iOS 8.0 推出!&lt;br&gt;推出指纹识别功能的目的,是为了简化移动支付环节,占领移动支付市场. 同时可以作为需要较高级别保护用户隐私的 APP 的登录检验方式。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2017, 展望未来，拥抱变化</title>
    <link href="http://yoursite.com/2017/04/03/2017-%E5%B1%95%E6%9C%9B%E6%9C%AA%E6%9D%A5%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/04/03/2017-展望未来，拥抱变化/</id>
    <published>2017-04-03T02:36:25.000Z</published>
    <updated>2017-04-03T03:29:07.000Z</updated>
    
    <content type="html">&lt;p&gt;2016 已经远去，不留一点痕迹，自从去年搭建这个博客之后，到今天，总共发布的博客数量也有 80+ 了，其它的因为还不知道要不要发布的博客有四五十篇了。怎么说呢，在搭建好这个博客之后，感觉自己有了其它人没办法随意进出的小岛了吧。一个属于我自己的世界，我可以在这里“恣意妄为”，完全不顾外界的评价。在这过去的 一年的时光里，发生了很多的事情，也成长了很多，对未来的路程也越来越清晰了。过往的经历也终将成为我未来前进的动力，在我无助想退堂鼓的时候，也能不断地鞭策的我。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;去年定了计划也大都完成了，除了框架的开发，因为工作繁忙，没有太多的时间进行研究，导致写出来的框架便没有太大的技术水准，不过其它的也都达到了，这倒是值得欣慰的地方。&lt;/p&gt;
&lt;p&gt;去年毕业前夕的时候在闲闪公司工作了三个多月，然后因为各种原因后面就离开了，拿到毕业证书之后就到了现在的公司（千夏软件科技）工作。对闲闪这家公司不想做什么评价，如果非要做评价的话，那绝对足够我在“你会因为什么原因离开这家公司？”这个问题厦门洋洋洒洒写个千百个字的，至于现在的公司，从我进来的那天到如今，公司经历了翻天覆地的变化了，从我刚进入只要负责一个项目，到同时做 2，3，4。。。最多同时负责 8 个项目在历程发展，直到最近因为公司发展原因才又降回 2 个项目。这里面有痛苦也有收获吧。大量的累积了项目经验，以一种非人的速度成长。&lt;/p&gt;
&lt;p&gt;不过这个情况在一个月前有了改善，现在只要好好专心做元翔专车项目了。这个项目应该会走的比较远的，毕竟项目的背后有个有钱的爸爸。我也从对技术的宽度变成了深度拓展，开始提高产品的质量。因为元翔进行了安全检测，也有了机会进行项目安全研究，同时敲开了逆向工程的大门，有点兴奋，逆向工程我可是筹备了一年多的时间，之前因为时间和自身能力一直没有深入学习，只是停留在了表面。机不可失，顺着这个起点，一周前开始了逆向工程的学习。慢慢地，对代码，框架的架构的能力和认识，也会跟着提升。&lt;/p&gt;
&lt;p&gt;前路漫漫，不知道未来还会遇到什么样的困难与机会。到时候我能解决那些困难么 ？ 亦或者我能把握好一闪而过的机会让自己更上一层么？ 不好说。谁知道呢，但是现在提高自己的能力总是不会错的，加油吧！！！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016 已经远去，不留一点痕迹，自从去年搭建这个博客之后，到今天，总共发布的博客数量也有 80+ 了，其它的因为还不知道要不要发布的博客有四五十篇了。怎么说呢，在搭建好这个博客之后，感觉自己有了其它人没办法随意进出的小岛了吧。一个属于我自己的世界，我可以在这里“恣意妄为”，完全不顾外界的评价。在这过去的 一年的时光里，发生了很多的事情，也成长了很多，对未来的路程也越来越清晰了。过往的经历也终将成为我未来前进的动力，在我无助想退堂鼓的时候，也能不断地鞭策的我。&lt;/p&gt;
    
    </summary>
    
    
      <category term="2017，请多多指教！" scheme="http://yoursite.com/tags/2017%EF%BC%8C%E8%AF%B7%E5%A4%9A%E5%A4%9A%E6%8C%87%E6%95%99%EF%BC%81/"/>
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结5</title>
    <link href="http://yoursite.com/2017/04/03/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%935/"/>
    <id>http://yoursite.com/2017/04/03/iOS特别技能点总结5/</id>
    <published>2017-04-03T02:25:40.000Z</published>
    <updated>2017-04-03T02:28:58.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;字典转为Json字符串&quot;&gt;&lt;a href=&quot;#字典转为Json字符串&quot; class=&quot;headerlink&quot; title=&quot;字典转为Json字符串&quot;&gt;&lt;/a&gt;字典转为Json字符串&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;  //字典转为Json字符串
+(NSString *)dictionaryToJson:(NSDictionary *)dic
{
    NSError *error = nil;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;amp;error];
    re
    turn [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;iOS-隐藏顶部状态栏方式&quot;&gt;&lt;a href=&quot;#iOS-隐藏顶部状态栏方式&quot; class=&quot;headerlink&quot; title=&quot;iOS_隐藏顶部状态栏方式&quot;&gt;&lt;/a&gt;iOS_隐藏顶部状态栏方式&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Storyboard

界面上选中UIViewController,最右边Simulated Metrics找到 Status Bar 设定成 None

ViewController

iOS 6通过[UIApplication sharedApplication] 取得app的单例，然后调用setStatusBarHidden方法隐藏 Status Bar。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;生成-n-位随机数&quot;&gt;&lt;a href=&quot;#生成-n-位随机数&quot; class=&quot;headerlink&quot; title=&quot;生成 n 位随机数&quot;&gt;&lt;/a&gt;生成 n 位随机数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString *string = [[NSString alloc]init];
for (int i = 0; i &amp;lt; 32; i++) {
    int number = arc4random() % 36;
    if (number &amp;lt; 10) {
        int figure = arc4random() % 10;
       NSString *tempString = [NSString stringWithFormat:@&amp;quot;%d&amp;quot;, figure];
        string = [string stringByAppendingString:tempString];
    }else {
        int figure = (arc4random() % 26) + 97;
        char character = figure;
         NSString *tempString = [NSString stringWithFormat:@&amp;quot;%c&amp;quot;, character];
        string = [string stringByAppendingString:tempString];
    }
}
NSLog(@&amp;quot;%@&amp;quot;, string);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;获取-UDID&quot;&gt;&lt;a href=&quot;#获取-UDID&quot; class=&quot;headerlink&quot; title=&quot;获取 UDID&quot;&gt;&lt;/a&gt;获取 UDID&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString *_String = [[NSUUID UUID] UUIDString];//随机字符串
NSLog(@&amp;quot;%@&amp;quot;,_String);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;大数据存储单位介绍-TB、PB、EB、ZB、YB有多大&quot;&gt;&lt;a href=&quot;#大数据存储单位介绍-TB、PB、EB、ZB、YB有多大&quot; class=&quot;headerlink&quot; title=&quot;大数据存储单位介绍(TB、PB、EB、ZB、YB有多大)&quot;&gt;&lt;/a&gt;大数据存储单位介绍(TB、PB、EB、ZB、YB有多大)&lt;/h3&gt;&lt;p&gt; 　　Byte字节，计算机信息的一种基本单位，也就是信息的存储单元。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1Byte = 8 Bit 

1 KB = 1,024 Bytes　 

1 MB = 1,024 KB = 1,048,576 Bytes　 

1 GB = 1,024 MB = 1,048,576 KB = 1,073,741,824 Bytes 

1 TB = 1,024 GB = 1,048,576 MB = 1,073,741,824 KB = 1,099,511,627,776 Bytes 

1 PB = 1,024 TB = 1,048,576 GB =1,125,899,906,842,624 Bytes 

1 EB = 1,024 PB = 1,048,576 TB = 1,152,921,504,606,846,976 Bytes 

1 ZB = 1,024 EB = 1,180,591,620,717,411,303,424 Bytes 

1 YB = 1,024 ZB = 1,208,925,819,614,629,174,706,176 Bytes 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;XCode调试技巧之EXC-BAD-ACCESS中BUG解决&quot;&gt;&lt;a href=&quot;#XCode调试技巧之EXC-BAD-ACCESS中BUG解决&quot; class=&quot;headerlink&quot; title=&quot;XCode调试技巧之EXC_BAD_ACCESS中BUG解决&quot;&gt;&lt;/a&gt;XCode调试技巧之EXC_BAD_ACCESS中BUG解决&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、通过编辑Edit Scheme，选择Diagnostics，勾选Enable Zombie Objects &amp;amp; Malloc Stack（注意、调试完毕后必须取消勾选，因为Zombile模式不会释放内存，很危险）

2、重新run你的程序，reproduce crash流程，控制台会输出如下log:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;iOS断言-NSAssert的使用&quot;&gt;&lt;a href=&quot;#iOS断言-NSAssert的使用&quot; class=&quot;headerlink&quot; title=&quot;iOS断言 NSAssert的使用&quot;&gt;&lt;/a&gt;iOS断言 NSAssert的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;在程序设计中，断言（assertion）是一种放在程序中的一阶逻辑（如一个结果为真或是假的逻辑判断式），
目的是为了标示与验证程序开发者预期的结果－当程序运行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止运行，并给出错误消息。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字典转为Json字符串&quot;&gt;&lt;a href=&quot;#字典转为Json字符串&quot; class=&quot;headerlink&quot; title=&quot;字典转为Json字符串&quot;&gt;&lt;/a&gt;字典转为Json字符串&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;  //字典转为Json字符串
+(NSString *)dictionaryToJson:(NSDictionary *)dic
{
    NSError *error = nil;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:dic options:NSJSONWritingPrettyPrinted error:&amp;amp;error];
    re
    turn [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>加密算法和网络</title>
    <link href="http://yoursite.com/2017/04/03/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/04/03/加密算法和网络/</id>
    <published>2017-04-03T02:18:46.000Z</published>
    <updated>2017-04-03T02:23:19.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;堵塞”-Logjam&quot;&gt;&lt;a href=&quot;#堵塞”-Logjam&quot; class=&quot;headerlink&quot; title=&quot;堵塞”(Logjam)&quot;&gt;&lt;/a&gt;堵塞”(Logjam)&lt;/h3&gt;&lt;p&gt;堵塞”(Logjam)漏洞威胁许多网页服务器和邮件服务器，影响所有主流浏览器以及支持512位迪菲-赫尔曼(Diffie-Hellman)密钥交换协议的服务器。而且，美国国家安全局(NSA)很可能就是利用这个漏洞破解VPN、HTTPS和SSH等协议，以访问相关网络流量的。&lt;/p&gt;
&lt;h3 id=&quot;Diffie-Hellman&quot;&gt;&lt;a href=&quot;#Diffie-Hellman&quot; class=&quot;headerlink&quot; title=&quot;Diffie-Hellman&quot;&gt;&lt;/a&gt;Diffie-Hellman&lt;/h3&gt;&lt;p&gt;Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法，它是OAKLEY的一个组成部分。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;Oakley算法&quot;&gt;&lt;a href=&quot;#Oakley算法&quot; class=&quot;headerlink&quot; title=&quot;Oakley算法&quot;&gt;&lt;/a&gt;Oakley算法&lt;/h3&gt;&lt;p&gt;Oakley算法是对Diffie-Hellman密钥交换算法的优化，它保留了后者的优点，同时克服了其弱点. Oakley算法具有五个重要特征： 它采用称为cookie程序的机制来对抗阻塞攻击. 它使得双方能够协商一个全局参数集合. 它使用了现时来保证抵抗重演攻击. 它能够交换Diffie-Hellman公开密钥. 它对Diffie-Hellman交换进行鉴别以对抗中间人的攻击.&lt;/p&gt;
&lt;h3 id=&quot;清除本地网络请求数据&quot;&gt;&lt;a href=&quot;#清除本地网络请求数据&quot; class=&quot;headerlink&quot; title=&quot;清除本地网络请求数据&quot;&gt;&lt;/a&gt;清除本地网络请求数据&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;   // 清除本地数据请求缓存
 NSURLCache *sharedCache = [[NSURLCache alloc] initWithMemoryCapacity:0 diskCapacity:0 diskPath:0];
[NSURLCache setSharedURLCache:sharedCache];

 // http://www.jb51.net/article/73573.htm
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;iOS-Https协议-自签证书访问数据&quot;&gt;&lt;a href=&quot;#iOS-Https协议-自签证书访问数据&quot; class=&quot;headerlink&quot; title=&quot;iOS Https协议 自签证书访问数据&quot;&gt;&lt;/a&gt;iOS Https协议 自签证书访问数据&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;http://www.jianshu.com/p/ec61e5ab6fbb
http://note.youdao.com/share/?id=f2c11b7d4c12d5d219ca2a42ac367584&amp;amp;type=note#/

demo ： https://github.com/fenglongteng/AfnHttpsSSLDemo
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;SocketRocket——符合标准的Objective-C-WebSocket客户端类库&quot;&gt;&lt;a href=&quot;#SocketRocket——符合标准的Objective-C-WebSocket客户端类库&quot; class=&quot;headerlink&quot; title=&quot;SocketRocket——符合标准的Objective-C WebSocket客户端类库&quot;&gt;&lt;/a&gt;SocketRocket——符合标准的Objective-C WebSocket客户端类库&lt;/h3&gt;&lt;p&gt;SocketRocket是一个WebSocket客户端，它采用现代Objective-C语言编写。SocketRocket遵循最新的WebSocket规范RFC 6455文件、支持WSS，同时，它也使用CFStream和NSStream。&lt;/p&gt;
&lt;p&gt;开发者表示，这也就意味着SocketRocket在没有任何外部依赖下也支持iOS 4.x系统（应该也可以运行于OS X）不需要任何UI包依赖。SocketRocket使用Automatic Reference Counting代码简单化，Grand Central Dispatch的背景合理化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  特性：
       1、支持TLS(wss)；
       2、使用NSStream/CFNetworking；
       3、使用ARC；
       4、并行的架构，大多数的工作都是在后台的工作者队列中完成；
       5、基于Delegate。

Github托管地址：https://github.com/square/SocketRocket
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堵塞”-Logjam&quot;&gt;&lt;a href=&quot;#堵塞”-Logjam&quot; class=&quot;headerlink&quot; title=&quot;堵塞”(Logjam)&quot;&gt;&lt;/a&gt;堵塞”(Logjam)&lt;/h3&gt;&lt;p&gt;堵塞”(Logjam)漏洞威胁许多网页服务器和邮件服务器，影响所有主流浏览器以及支持512位迪菲-赫尔曼(Diffie-Hellman)密钥交换协议的服务器。而且，美国国家安全局(NSA)很可能就是利用这个漏洞破解VPN、HTTPS和SSH等协议，以访问相关网络流量的。&lt;/p&gt;
&lt;h3 id=&quot;Diffie-Hellman&quot;&gt;&lt;a href=&quot;#Diffie-Hellman&quot; class=&quot;headerlink&quot; title=&quot;Diffie-Hellman&quot;&gt;&lt;/a&gt;Diffie-Hellman&lt;/h3&gt;&lt;p&gt;Diffie-Hellman:一种确保共享KEY安全穿越不安全网络的方法，它是OAKLEY的一个组成部分。Whitefield与Martin Hellman在1976年提出了一个奇妙的密钥交换协议，称为Diffie-Hellman密钥交换协议/算法(Diffie-Hellman Key Exchange/Agreement Algorithm).这个机制的巧妙在于需要安全通信的双方可以用这个方法确定对称密钥。然后可以用这个密钥进行加密和解密。但是注意，这个密钥交换协议/算法只能用于密钥的交换，而不能进行消息的加密和解密。双方确定要用的密钥后，要使用其他对称密钥操作加密算法实际加密和解密消息。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 本地文件路径</title>
    <link href="http://yoursite.com/2017/04/03/iOS-%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2017/04/03/iOS-本地文件路径/</id>
    <published>2017-04-03T02:12:37.000Z</published>
    <updated>2017-04-03T02:16:14.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、本地文件存储位置&quot;&gt;&lt;a href=&quot;#一、本地文件存储位置&quot; class=&quot;headerlink&quot; title=&quot;一、本地文件存储位置&quot;&gt;&lt;/a&gt;一、本地文件存储位置&lt;/h3&gt;&lt;p&gt;1、Documents 目录：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。&lt;/p&gt;
&lt;p&gt;2、AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。&lt;/p&gt;
&lt;p&gt;3、Library 目录：这个目录下有两个子目录：Caches 和 Preferences&lt;/p&gt;
&lt;p&gt;Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.&lt;br&gt;Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。&lt;/p&gt;
&lt;p&gt;4、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;二、获得文件保存路径&quot;&gt;&lt;a href=&quot;#二、获得文件保存路径&quot; class=&quot;headerlink&quot; title=&quot;二、获得文件保存路径&quot;&gt;&lt;/a&gt;二、获得文件保存路径&lt;/h3&gt;&lt;p&gt; 1.”应用程序包”: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *path = [[NSBundle mainBundle] bundlePath];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 2.Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 3.Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 4.tmp: iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *path = NSTemporaryDirectory();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 5.Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、本地文件存储位置&quot;&gt;&lt;a href=&quot;#一、本地文件存储位置&quot; class=&quot;headerlink&quot; title=&quot;一、本地文件存储位置&quot;&gt;&lt;/a&gt;一、本地文件存储位置&lt;/h3&gt;&lt;p&gt;1、Documents 目录：您应该将所有的应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。&lt;/p&gt;
&lt;p&gt;2、AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。&lt;/p&gt;
&lt;p&gt;3、Library 目录：这个目录下有两个子目录：Caches 和 Preferences&lt;/p&gt;
&lt;p&gt;Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好.&lt;br&gt;Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。&lt;/p&gt;
&lt;p&gt;4、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关联ObjC</title>
    <link href="http://yoursite.com/2017/02/14/%E5%85%B3%E8%81%94ObjC/"/>
    <id>http://yoursite.com/2017/02/14/关联ObjC/</id>
    <published>2017-02-14T11:06:41.000Z</published>
    <updated>2017-02-14T12:05:24.000Z</updated>
    
    <content type="html">&lt;p&gt;关联(objc_setAssociatedObject、objc_getAssociatedObject、objc_removeAssociatedObjects）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义：关联是指把两个对象相互关联起来，使得其中的一个对象作为另外一个对象的一部分。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;在类的定义之外为类增加额外的存储空间&quot;&gt;&lt;a href=&quot;#在类的定义之外为类增加额外的存储空间&quot; class=&quot;headerlink&quot; title=&quot;在类的定义之外为类增加额外的存储空间&quot;&gt;&lt;/a&gt;在类的定义之外为类增加额外的存储空间&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;使用关联，我们可以不用修改类的定义而为其对象增加存储空间。这在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用。

关联是基于关键字的，因此，我们可以为任何对象增加任意多的关联，每个都使用不同的关键字即可。关联是可以保证被关联的对象在关联对象的整个生命周期都是可用的（在垃圾自动回收环境下也不会导致资源不可回收）。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;创建关联&quot;&gt;&lt;a href=&quot;#创建关联&quot; class=&quot;headerlink&quot; title=&quot;创建关联&quot;&gt;&lt;/a&gt;创建关联&lt;/h4&gt;&lt;pre&gt;&lt;code&gt; 创建关联要使用到Objective-C的运行时函数：objc_setAssociatedObject 来把一个对象与另外一个对象进行关联。

该函数需要四个参数：源对象，关键字，关联的对象和一个关联策略。

 ■  关键字是一个void类型的指针。每一个关联的关键字必须是唯一的。通常都是会采用静态变量来作为关键字。
 ■  关联策略表明了相关的对象是通过赋值，保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;获取相关联的对象&quot;&gt;&lt;a href=&quot;#获取相关联的对象&quot; class=&quot;headerlink&quot; title=&quot;获取相关联的对象&quot;&gt;&lt;/a&gt;获取相关联的对象&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;获取相关联的对象时使用Objective-C函数objc_getAssociatedObject。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;断开关联&quot;&gt;&lt;a href=&quot;#断开关联&quot; class=&quot;headerlink&quot; title=&quot;断开关联&quot;&gt;&lt;/a&gt;断开关联&lt;/h4&gt;&lt;p&gt;断开关联是使用objc_setAssociatedObject函数，传入nil值即可。&lt;/p&gt;
&lt;p&gt;使用函数objc_removeAssociatedObjects可以断开所有关联。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (_FDViewControllerWillAppearInjectBlock)fd_willAppearInjectBlock
{
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setFd_willAppearInjectBlock:(_FDViewControllerWillAppearInjectBlock)block
{
    objc_setAssociatedObject(self, @selector(fd_willAppearInjectBlock), block, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;关联(objc_setAssociatedObject、objc_getAssociatedObject、objc_removeAssociatedObjects）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;定义：关联是指把两个对象相互关联起来，使得其中的一个对象作为另外一个对象的一部分。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;在类的定义之外为类增加额外的存储空间&quot;&gt;&lt;a href=&quot;#在类的定义之外为类增加额外的存储空间&quot; class=&quot;headerlink&quot; title=&quot;在类的定义之外为类增加额外的存储空间&quot;&gt;&lt;/a&gt;在类的定义之外为类增加额外的存储空间&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;使用关联，我们可以不用修改类的定义而为其对象增加存储空间。这在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用。

关联是基于关键字的，因此，我们可以为任何对象增加任意多的关联，每个都使用不同的关键字即可。关联是可以保证被关联的对象在关联对象的整个生命周期都是可用的（在垃圾自动回收环境下也不会导致资源不可回收）。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UICollectionView - 使用二</title>
    <link href="http://yoursite.com/2016/12/18/UICollectionView-%E4%BD%BF%E7%94%A8%E4%BA%8C/"/>
    <id>http://yoursite.com/2016/12/18/UICollectionView-使用二/</id>
    <published>2016-12-18T11:43:22.000Z</published>
    <updated>2016-12-18T11:47:40.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;UICollectionViewLayout&quot;&gt;&lt;a href=&quot;#UICollectionViewLayout&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewLayout&quot;&gt;&lt;/a&gt;UICollectionViewLayout&lt;/h3&gt;&lt;p&gt;终于到UICollectionView的精髓了…这也是UICollectionView和UITableView最大的不同。&lt;br&gt;UICollectionViewLayout可以说是UICollectionView的大脑和中枢，它负责了将各个cell、Supplementary View和Decoration Views进行组织，为它们设定各自的属性，包括但不限于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    位置
    尺寸
    透明度
    层级关系
    形状
    等等等等…

Layout决定了UICollectionView是如何显示在界面上的。
在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UICollectionViewFlowLayout&quot;&gt;&lt;a href=&quot;#UICollectionViewFlowLayout&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewFlowLayout&quot;&gt;&lt;/a&gt;UICollectionViewFlowLayout&lt;/h3&gt;&lt;p&gt;Apple为我们提供了一个最简单可能也是最常用的默认layout对象，￼￼￼UICollectionViewFlowLayout。&lt;br&gt;Flow Layout简单说是一个直线对齐的layout，最常见的Grid View形式即为一种Flow Layout配置。上面的照片架界面就是一个典型的Flow Layout。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 首先一个重要的属性是itemSize，它定义了每一个item的大小。通过设定itemSize可以全局地改变所有cell的尺寸，如果想要对某个cell制定尺寸，可以使用
     -collectionView:layout:sizeForItemAtIndexPath:方法。

间隔 可以指定item之间的间隔和每一行之间的间隔，和size类似，有全局属性，也可以对每一个item和每一个section做出设定：

    @property (CGSize) minimumInteritemSpacing
    @property (CGSize) minimumLineSpacing
    -collectionView:layout:minimumInteritemSpacingForSectionAtIndex:
    -collectionView:layout:minimumLineSpacingForSectionAtIndex:

滚动方向 由属性scrollDirection确定scroll view的方向，将影响Flow Layout的基本方向和由header及footer确定的section之间的宽度

    UICollectionViewScrollDirectionVertical
    UICollectionViewScrollDirectionHorizontal

Header和Footer尺寸 同样地分为全局和部分。需要注意根据滚动方向不同，header和footer的高和宽中只有一个会起作用。
垂直滚动时section间宽度为该尺寸的高，而水平滚动时为宽度起作用。

    @property (CGSize) headerReferenceSize
    @property (CGSize) footerReferenceSize
    -collectionView:layout:referenceSizeForHeaderInSection:
    -collectionView:layout:referenceSizeForFooterInSection:
缩进

    @property UIEdgeInsets sectionInset;
    -collectionView:layout:insetForSectionAtIndex:

总结
    一个UICollectionView的实现包括两个必要部分：UICollectionViewDataSource和UICollectionViewLayout，和一个交互部分：
    UICollectionViewDelegate。而Apple给出的UICollectionViewFlowLayout已经是一个很强力的layout方案了。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;UICollectionViewLayoutAttributes&quot;&gt;&lt;a href=&quot;#UICollectionViewLayoutAttributes&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewLayoutAttributes&quot;&gt;&lt;/a&gt;UICollectionViewLayoutAttributes&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; UICollectionViewLayoutAttributes是一个非常重要的类，先来看看property列表：

     @property (nonatomic) CGRect frame
     @property (nonatomic) CGPoint center
     @property (nonatomic) CGSize size
     @property (nonatomic) CATransform3D transform3D
     @property (nonatomic) CGFloat alpha
     @property (nonatomic) NSInteger zIndex
     @property (nonatomic, getter=isHidden) BOOL hidden

可以看到，UICollectionViewLayoutAttributes的实例中包含了诸如边框，中心点，大小，形状，透明度，层次关系和是否隐藏等信息。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义的UICollectionViewLayout&quot;&gt;&lt;a href=&quot;#自定义的UICollectionViewLayout&quot; class=&quot;headerlink&quot; title=&quot;自定义的UICollectionViewLayout&quot;&gt;&lt;/a&gt;自定义的UICollectionViewLayout&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UICollectionViewLayout的功能为向UICollectionView提供布局信息，不仅包括cell的布局信息，也包括追加视图和装饰视图的布局信息。
实现一个自定义layout的常规做法是继承UICollectionViewLayout类，然后重载下列方法：


  - (CGSize)collectionViewContentSize    返回collectionView的内容的尺寸

  -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect

    返回rect中的所有的元素的布局属性
    返回的是包含 UICollectionViewLayoutAttributes的NSArray
    UICollectionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，
    通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollectionViewLayoutAttributes：

        layoutAttributesForItemAtIndexPath:
        layoutAttributesForSupplementaryViewOfKind:withIndexPath:
        layoutAttributesForDecorationViewOfKind:withIndexPath:

 -(UICollectionViewLayoutAttributes _)layoutAttributesForItemAtIndexPath:(NSIndexPath _)indexPath

     返回对应于indexPath的位置的cell的布局属性

 -(UICollectionViewLayoutAttributes _)layoutAttributesForSupplementaryViewOfKind:(NSString _)kind atIndexPath:(NSIndexPath *)indexPath

     回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载

 -(UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString_)decorationViewKind atIndexPath:(NSIndexPath _)indexPath

     返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载

 -(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds

    当边界发生改变时，是否应该刷新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;另外需要了解的是&lt;/strong&gt;，在初始化一个UICollectionViewLayout实例后，会有一系列准备方法被自动调用，以保证layout实例的正确。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，-(void)prepareLayout将被调用，默认下该方法什么没做，但是在自己的子类实现中，一般在该方法中设定一些必要的layout的结构和初始需要的参数等。

之后，-(CGSize) collectionViewContentSize将被调用，以确定collection应该占据的尺寸。注意这里的尺寸不是指可视部分的尺寸，
而应该是所有内容所占的尺寸。collectionView的本质是一个scrollView，因此需要这个尺寸来配置滚动行为。

接下来-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect被调用，这个没什么值得多说的。初始的layout的外观将由该方法返回的UICollectionViewLayoutAttributes来决定。

另外，在需要更新layout时，需要给当前layout发送 -invalidateLayout，该消息会立即返回，并且预约在下一个loop的时候刷新当前layout，这一点和UIView的setNeedsLayout方法十分类似。
在-invalidateLayout后的下一个collectionView的刷新loop中，又会从prepareLayout开始，依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;UICollectionViewLayout&quot;&gt;&lt;a href=&quot;#UICollectionViewLayout&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewLayout&quot;&gt;&lt;/a&gt;UICollectionViewLayout&lt;/h3&gt;&lt;p&gt;终于到UICollectionView的精髓了…这也是UICollectionView和UITableView最大的不同。&lt;br&gt;UICollectionViewLayout可以说是UICollectionView的大脑和中枢，它负责了将各个cell、Supplementary View和Decoration Views进行组织，为它们设定各自的属性，包括但不限于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    位置
    尺寸
    透明度
    层级关系
    形状
    等等等等…

Layout决定了UICollectionView是如何显示在界面上的。
在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UICollectionView - 使用一</title>
    <link href="http://yoursite.com/2016/12/18/UICollectionView-%E4%BD%BF%E7%94%A8%E4%B8%80/"/>
    <id>http://yoursite.com/2016/12/18/UICollectionView-使用一/</id>
    <published>2016-12-18T11:39:38.000Z</published>
    <updated>2016-12-18T11:41:50.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;什么是UICollectionView&quot;&gt;&lt;a href=&quot;#什么是UICollectionView&quot; class=&quot;headerlink&quot; title=&quot;什么是UICollectionView&quot;&gt;&lt;/a&gt;什么是UICollectionView&lt;/h3&gt;&lt;p&gt;UICollectionView是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView(请一定注意这是UICollectionView的最最简单的形式)。&lt;/p&gt;
&lt;p&gt;最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。标准的UICollectionView包含三个部分，它们都是UIView的子类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊  Cells 用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容 
＊  Supplementary Views 追加视图 如果你对UITableView比较熟悉的话，可以理解为每个Section的Header或者Footer，用来标记每个section的view
＊  Decoration Views 装饰视图 这是每个section的背景，
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;实现一个简单的UICollectionView&quot;&gt;&lt;a href=&quot;#实现一个简单的UICollectionView&quot; class=&quot;headerlink&quot; title=&quot;实现一个简单的UICollectionView&quot;&gt;&lt;/a&gt;实现一个简单的UICollectionView&lt;/h3&gt;&lt;p&gt;实现一个UICollectionView和实现一个UITableView基本没有什么大区别，它们都同样是datasource和delegate设计模式的：datasource为view提供数据源，告诉view要显示些什么东西以及如何显示它们，delegate提供一些样式的小细节以及用户交互的相应。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ UICollectionViewDataSource

        section的数量  ￼-numberOfSectionsInCollection:
        某个section里有多少个item ￼ -collectionView:numberOfItemsInSection:
        对于某个位置应该显示什么样的cell ￼ -collectionView:cellForItemAtIndexPath:

  实现以上三个委托方法，基本上就可以保证CollectionView工作正常了。 当然，还有提供Supplementary View的方法

     collectionView:viewForSupplementaryElementOfKind:atIndexPath:

   对于Decoration Views，提供方法并不在UICollectionViewDataSource中，而是直接UICollectionViewLayout类中的(因为它仅仅是视图相关，而与数据无关)


＊ UICollectionViewDelegate

    数据无关的view的外形啊，用户交互啊什么的，由UICollectionViewDelegate来负责：

        cell的高亮
        cell的选中状态
        可以支持长按后的菜单

    关于用户交互，UICollectionView也做了改进。每个cell现在有独立的高亮事件和选中事件的delegate，用户点击cell的时候，现在会按照以下流程向delegate进行询问：

        -￼collectionView:shouldHighlightItemAtIndexPath: 是否应该高亮？
        -￼collectionView:didHighlightItemAtIndexPath: 如果1回答为是，那么高亮
        -￼collectionView:shouldSelectItemAtIndexPath: 无论1结果如何，都询问是否可以被选中？
        -collectionView:didUnhighlightItemAtIndexPath: 如果1回答为是，那么现在取消高亮
        -collectionView:didSelectItemAtIndexPath: 如果3回答为是，那么选中cell

    状态控制要比以前灵活一些，对应的高亮和选中状态分别由highlighted和selected两个属性表示。  


＊ 关于Cell

    相对于UITableViewCell来说，UICollectionViewCell没有这么多花头。首先UICollectionViewCell不存在各式各样的默认的style，这主要是由于展示对象的性质决定的，因为UICollectionView所用来展示的对象相比UITableView来说要来得灵活，大部分情况下更偏向于图像而非文字，因此需求将会千奇百怪。因此SDK提供给我们的默认的UICollectionViewCell结构上相对比较简单，由下至上：

        首先是cell本身作为容器view
        然后是一个大小自动适应整个cell的backgroundView，用作cell平时的背景
        再其上是selectedBackgroundView，是cell被选中时的背景
        最后是一个contentView，自定义内容应被加在这个view上
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这次Apple给我们带来的好康是被选中cell的自动变化，所有的cell中的子view，也包括contentView中的子view，在当cell被选中时，会自动去查找view是否有被选中状态下的改变。比如在contentView里加了一个normal和selected指定了不同图片的imageView，那么选中这个cell的同时这张图片也会从normal变成selected，而不需要额外的任何代码。&lt;/p&gt;
&lt;p&gt;文章后面有两个水平比较高的例子 － &lt;a href=&quot;https://onevcat.com/2012/08/advanced-collection-view&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://onevcat.com/2012/08/advanced-collection-view&lt;/a&gt; 和 &lt;a href=&quot;https://objccn.io/issue-12-5/）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-12-5/）&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是UICollectionView&quot;&gt;&lt;a href=&quot;#什么是UICollectionView&quot; class=&quot;headerlink&quot; title=&quot;什么是UICollectionView&quot;&gt;&lt;/a&gt;什么是UICollectionView&lt;/h3&gt;&lt;p&gt;UICollectionView是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView(请一定注意这是UICollectionView的最最简单的形式)。&lt;/p&gt;
&lt;p&gt;最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。标准的UICollectionView包含三个部分，它们都是UIView的子类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊  Cells 用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容 
＊  Supplementary Views 追加视图 如果你对UITableView比较熟悉的话，可以理解为每个Section的Header或者Footer，用来标记每个section的view
＊  Decoration Views 装饰视图 这是每个section的背景，
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发中的几种设计模式介绍</title>
    <link href="http://yoursite.com/2016/12/11/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/12/11/iOS开发中的几种设计模式介绍/</id>
    <published>2016-12-11T13:02:50.000Z</published>
    <updated>2016-12-11T13:12:11.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 开发学习中，经常使用的几种开发模式，现在进行简单的总结和探讨：&lt;/p&gt;
&lt;h4 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h4&gt;&lt;p&gt;应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。&lt;br&gt;优势：解耦合&lt;br&gt;敏捷原则：开放-封闭原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h4&gt;&lt;p&gt;应用场景：一般为对model层，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。&lt;br&gt;优势：解耦合&lt;br&gt;敏捷原则：接口隔离原则，开放-封闭原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。
kvo，键值对改变通知的观察者
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;MVC模式&quot;&gt;&lt;a href=&quot;#MVC模式&quot; class=&quot;headerlink&quot; title=&quot;MVC模式&quot;&gt;&lt;/a&gt;MVC模式&lt;/h4&gt;&lt;p&gt;应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。&lt;br&gt;优势：使系统，层次清晰，职责分明，易于维护&lt;br&gt;敏捷原则：对扩展开放-对修改封闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h4&gt;&lt;p&gt;应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。&lt;br&gt;优势：使用简单，延时求值，易于跨模块&lt;br&gt;敏捷原则：单一职责原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：[UIApplication sharedApplication]。
注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。
object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，
返回的也只是此单例类的唯一静态变量。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h4&gt;&lt;p&gt;应用场景：定义算法族，封装起来，使他们之间可以相互替换。&lt;br&gt;优势：使算法的变化独立于使用算法的用户&lt;br&gt;敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。
注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类
2，变化的行为抽象基类为，所有可变变化的父类
3，用户类的最终实例，通过注入行为实例的方式，设定易变行为
防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h4&gt;&lt;p&gt;应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。&lt;br&gt;优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。&lt;br&gt;敏捷原则：DIP依赖倒置原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换
注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，
增 加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 开发学习中，经常使用的几种开发模式，现在进行简单的总结和探讨：&lt;/p&gt;
&lt;h4 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h4&gt;&lt;p&gt;应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。&lt;br&gt;优势：解耦合&lt;br&gt;敏捷原则：开放-封闭原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIAlertController 弹框</title>
    <link href="http://yoursite.com/2016/11/27/UIAlertController-%E5%BC%B9%E6%A1%86/"/>
    <id>http://yoursite.com/2016/11/27/UIAlertController-弹框/</id>
    <published>2016-11-27T13:15:28.000Z</published>
    <updated>2016-11-27T13:17:53.000Z</updated>
    
    <content type="html">&lt;p&gt;一. 标准的Alert样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//UIAlertController风格：UIAlertControllerStyleAlert
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;主标题&amp;quot; message:@&amp;quot;提示文字&amp;quot;preferredStyle:UIAlertControllerStyleAlert ];

//添加取消到UIAlertController中
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:cancelAction];

//添加确定到UIAlertController中
UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&amp;quot;确定&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:OKAction];

[self presentViewController:alertController animated:YES completion:nil]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;二. 标准的Alert Sheet样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;标准的Action Sheet样式&amp;quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];
//取消:style:UIAlertActionStyleCancel//
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleCancel handler:nil];
[alertController addAction:cancelAction];
//了解更多:style:UIAlertActionStyleDestructive
UIAlertAction *moreAction = [UIAlertAction actionWithTitle:@&amp;quot;了解更多&amp;quot; style:UIAlertActionStyleDestructive handler:nil];
[alertController addAction:moreAction];
//原来如此:style:UIAlertActionStyleDefault
UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&amp;quot;原来如此&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:OKAction];

[self presentViewController:alertController animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;三. 新功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;style:UIAlertActionStyleDefault//对按钮应用标准样式
style:UIAlertActionStyleCancel//对按钮应用取消样式，即取消操作
style:UIAlertActionStyleDestructive//对按钮应用警示性样式，提示用户这样做可能会删除或者改变某些数据


UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;主标题:标题党&amp;quot;message:@&amp;quot;子标题:提示信息&amp;quot; preferredStyle:UIAlertControllerStyleAlert ];
//取消style:UIAlertActionStyleDefault
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:cancelAction];

//style:UIAlertActionStyleDestructive(警告提示)
UIAlertAction *rubbishAction = [UIAlertAction actionWithTitle:@&amp;quot;确定修改&amp;quot; style:UIAlertActionStyleDestructive handler:nil];
[alertController addAction:rubbishAction];

[self presentViewController:alertController animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;四. 弹出文本框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 只有在alert情况下才可以添加文本框
    [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.placeholder = @&amp;quot;用户名&amp;quot;;
        textField.secureTextEntry = YES;
    }];

//    // 取出文本
//    UITextField *text = alertController.textFields.firstObject;
//    UIAlertAction *action = alertController.actions.firstObject;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;一. 标准的Alert样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//UIAlertController风格：UIAlertControllerStyleAlert
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;主标题&amp;quot; message:@&amp;quot;提示文字&amp;quot;preferredStyle:UIAlertControllerStyleAlert ];

//添加取消到UIAlertController中
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:cancelAction];

//添加确定到UIAlertController中
UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&amp;quot;确定&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:OKAction];

[self presentViewController:alertController animated:YES completion:nil]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIWebView 实现长按保存图片功能</title>
    <link href="http://yoursite.com/2016/11/22/UIWebView-%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/11/22/UIWebView-实现长按保存图片功能/</id>
    <published>2016-11-22T12:50:24.000Z</published>
    <updated>2016-11-22T12:57:50.000Z</updated>
    
    <content type="html">&lt;p&gt;拿到需求之后分析了一下，其实主要功能点就是如何才能通过手指按压位置获取到相应的图片资源。&lt;/p&gt;
&lt;p&gt;首先是给UiWebView加一个长按手势 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UILongPressGestureRecognizer* longPressed = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressed:)];
longPressed.delegate = self;
[self.webView addGestureRecognizer:longPressed];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;响应方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)longPressed:(UILongPressGestureRecognizer*)recognizer
{

    if (recognizer.state != UIGestureRecognizerStateBegan) {
        return;
    }

    CGPoint touchPoint = [recognizer locationInView:self.webView];
    NSString *jsForTagName = [NSString stringWithFormat:@&amp;quot;document.elementFromPoint(%f, %f).tagName&amp;quot;, touchPoint.x, touchPoint.y];
    NSString * tagName = [self.webView stringByEvaluatingJavaScriptFromString:jsForTagName];
    if (![tagName isEqualToString:@&amp;quot;img&amp;quot;] &amp;amp;&amp;amp; ![tagName isEqualToString:@&amp;quot;IMG&amp;quot;]) {
        return;
    }
    NSString *imgURL = [NSString stringWithFormat:@&amp;quot;document.elementFromPoint(%f, %f).src&amp;quot;, touchPoint.x, touchPoint.y];
    self.urlToSave = [self.webView stringByEvaluatingJavaScriptFromString:imgURL];

    if (self.urlToSave.length == 0) {
        return;
    }

    [self showImageOptionsWithUrl:self.urlToSave];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;弹窗提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)showImageOptionsWithUrl:(NSString *)imageUrl
{
    UIActionSheet *actionSheet = [[UIActionSheet alloc]
                                  initWithTitle:nil
                                  delegate:self
                                  cancelButtonTitle:@&amp;quot;取消&amp;quot;
                                  destructiveButtonTitle:@&amp;quot;保存图片&amp;quot;
                                  otherButtonTitles: nil];
    actionSheet.actionSheetStyle = UIActionSheetStyleBlackOpaque;
    [actionSheet showInView:self.view];
}


- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == 0) {
        [self saveImageToDiskWithUrl:self.urlToSave];
    }
}

// 执行保存操作
- (void)saveImageToDiskWithUrl:(NSString *)imageUrl
{
    NSURL *url = [NSURL URLWithString:imageUrl];
    NSURLSessionConfiguration * configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self  delegateQueue:[NSOperationQueue new]];
    NSURLRequest *imgRequest = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];

    NSURLSessionDownloadTask  *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        if (error) {
            return ;
        }

        NSData * imageData = [NSData dataWithContentsOfURL:location];
        dispatch_async(dispatch_get_main_queue(), ^{

            UIImage * image = [UIImage imageWithData:imageData];

            UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);
        });
    }];

    [task resume];
}

／／ 监测是否保存成功
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo
{
    if (error) {
        NSLog(@&amp;quot;保存fail&amp;quot;);
        [UMComShowToast fetchFailWithNoticeMessage:@&amp;quot;保存失败&amp;quot;];
        //        [[RAProgressHUD sharedHUD] showErrorWithMessage:@&amp;quot;保存失败&amp;quot;];
    } else {
        NSLog(@&amp;quot;保存成功&amp;quot;);
        //        [[RAProgressHUD sharedHUD] showSuccessWithMessage:@&amp;quot;保存成功&amp;quot;];
        [UMComShowToast fetchFailWithNoticeMessage:@&amp;quot;保存成功&amp;quot;];
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;拿到需求之后分析了一下，其实主要功能点就是如何才能通过手指按压位置获取到相应的图片资源。&lt;/p&gt;
&lt;p&gt;首先是给UiWebView加一个长按手势 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UILongPressGestureRecognizer* longPressed = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressed:)];
longPressed.delegate = self;
[self.webView addGestureRecognizer:longPressed];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YYModel字典转模型的几种详细用法</title>
    <link href="http://yoursite.com/2016/11/14/YYModel%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2016/11/14/YYModel字典转模型的几种详细用法/</id>
    <published>2016-11-14T11:47:06.000Z</published>
    <updated>2016-11-14T11:51:09.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;常用的几个方法&quot;&gt;&lt;a href=&quot;#常用的几个方法&quot; class=&quot;headerlink&quot; title=&quot;常用的几个方法&quot;&gt;&lt;/a&gt;常用的几个方法&lt;/h4&gt;&lt;p&gt;json转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithJSON:(id)json;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSString *)yy_modelToJSONString 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 声明数组、字典或者集合里的元素类型时要重写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass；
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# YYAlbum.h
@property (nonatomic, copy) NSString *name;
@property (nonatomic, strong) NSArray *photos; # Array&amp;lt;YYPhoto&amp;gt;
@property (nonatomic, strong) NSDictionary *likedUsers; # Key:name(NSString) Value:user(YYUser)
@property (nonatomic, strong) NSSet *likedUserIds; # Set&amp;lt;NSNumber&amp;gt;

# YYPhoto.h
@property (nonatomic, copy) NSString *url;
@property (nonatomic, copy) NSString *desc;

# YYAlbum.m
#把数组里面带有对象的类型专门按照这个方法，这个格式写出来
-(nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass{
    return @{
             @&amp;quot;photos&amp;quot;       : YYPhoto.class,
             @&amp;quot;likedUsers&amp;quot;   : YYUser.class,
             @&amp;quot;likedUserIds&amp;quot; : NSNumber.class
             };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典里的key值与模型的属性值不一致要重置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelCustomPropertyMapper;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# YYMessage.h
@property (nonatomic, assign) uint64_t messageId;
@property (nonatomic, strong) NSString *content;
@property (nonatomic, strong) NSDate *time;

# YYMessage.m
/*!
 *  1.该方法是 `字典里的属性Key` 和 `要转化为模型里的属性名` 不一样 而重写的
 *  前：模型的属性   后：字典里的属性
 */

+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelCustomPropertyMapper{

    return @{@&amp;quot;messageId&amp;quot;:@&amp;quot;i&amp;quot;,
             @&amp;quot;content&amp;quot;:@&amp;quot;c&amp;quot;,
             @&amp;quot;time&amp;quot;:@&amp;quot;t&amp;quot;};
}

/*!
 *  2. 下面的两个方法 `字典里值`与`模型的值`类型不一样`需要转换`而重写的方法
 *   NSDate *time     dic[@&amp;quot;t&amp;quot;]是double类型的的秒数
 */

/// Dic -&amp;gt; model
- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic {

    self.time = (NSDate *)[NSDate dateWithTimeIntervalSince1970:[dic[@&amp;quot;t&amp;quot;] doubleValue]/1000];

    return YES;
}

/// model -&amp;gt; Dic
- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic {

    dic[@&amp;quot;t&amp;quot;] = @([self.time timeIntervalSince1970] * 1000).description;

    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面两者是属性值在两个dic与模型之间的转化方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic ；
- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic；
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;常用的几个方法&quot;&gt;&lt;a href=&quot;#常用的几个方法&quot; class=&quot;headerlink&quot; title=&quot;常用的几个方法&quot;&gt;&lt;/a&gt;常用的几个方法&lt;/h4&gt;&lt;p&gt;json转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithJSON:(id)json;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSString *)yy_modelToJSONString 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 声明数组、字典或者集合里的元素类型时要重写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass；
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>layoutSubviews 总结</title>
    <link href="http://yoursite.com/2016/10/27/layoutSubviews-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/10/27/layoutSubviews-总结/</id>
    <published>2016-10-27T11:23:57.000Z</published>
    <updated>2016-10-27T11:28:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;ios-layout机制相关方法&quot;&gt;&lt;a href=&quot;#ios-layout机制相关方法&quot; class=&quot;headerlink&quot; title=&quot;ios layout机制相关方法&quot;&gt;&lt;/a&gt;ios layout机制相关方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (CGSize)sizeThatFits:(CGSize)size
- (void)sizeToFit
——————-
- (void)layoutSubviews
- (void)layoutIfNeeded
- (void)setNeedsLayout
——————–
- (void)setNeedsDisplay
- (void)drawRect
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;layoutSubviews在以下情况下会被调用：&quot;&gt;&lt;a href=&quot;#layoutSubviews在以下情况下会被调用：&quot; class=&quot;headerlink&quot; title=&quot;layoutSubviews在以下情况下会被调用：&quot;&gt;&lt;/a&gt;layoutSubviews在以下情况下会被调用：&lt;/h4&gt;&lt;p&gt;1、init初始化不会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;但是是用initWithFrame 进行初始化时，当rect的值不为CGRectZero时,也会触发&lt;/p&gt;
&lt;p&gt;2、addSubview会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化&lt;/p&gt;
&lt;p&gt;4、滚动一个UIScrollView会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;5、旋转Screen会触发父UIView上的layoutSubviews事件&lt;/p&gt;
&lt;p&gt;6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件&lt;/p&gt;
&lt;h3 id=&quot;刷新子对象布局&quot;&gt;&lt;a href=&quot;#刷新子对象布局&quot; class=&quot;headerlink&quot; title=&quot;刷新子对象布局&quot;&gt;&lt;/a&gt;刷新子对象布局&lt;/h3&gt;&lt;p&gt;-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写&lt;br&gt;-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用&lt;br&gt;-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）&lt;/p&gt;
&lt;p&gt;如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局&lt;/p&gt;
&lt;p&gt;在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]&lt;/p&gt;
&lt;h3 id=&quot;重绘&quot;&gt;&lt;a href=&quot;#重绘&quot; class=&quot;headerlink&quot; title=&quot;重绘&quot;&gt;&lt;/a&gt;重绘&lt;/h3&gt;&lt;p&gt;-drawRect:(CGRect)rect方法：重写此方法，执行重绘任务&lt;br&gt;-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect&lt;br&gt;-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘&lt;/p&gt;
&lt;p&gt;sizeToFit会自动调用sizeThatFits方法；&lt;/p&gt;
&lt;p&gt;sizeToFit不应该在子类中被重写，应该重写sizeThatFits&lt;/p&gt;
&lt;p&gt;sizeThatFits传入的参数是receiver当前的size，返回一个适合的size&lt;/p&gt;
&lt;p&gt;sizeToFit可以被手动直接调用&lt;/p&gt;
&lt;p&gt;sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己&lt;/p&gt;
&lt;p&gt;layoutSubviews对subviews重新布局&lt;/p&gt;
&lt;p&gt;layoutSubviews方法调用先于drawRect&lt;/p&gt;
&lt;p&gt;setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews&lt;/p&gt;
&lt;p&gt;layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的&lt;/p&gt;
&lt;p&gt;layoutIfNeeded遍历的不是superview链，应该是subviews链&lt;/p&gt;
&lt;p&gt;drawRect是对receiver的重绘，能获得context&lt;/p&gt;
&lt;p&gt;setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘 &lt;/p&gt;
&lt;h3 id=&quot;sizeToFit&quot;&gt;&lt;a href=&quot;#sizeToFit&quot; class=&quot;headerlink&quot; title=&quot;sizeToFit&quot;&gt;&lt;/a&gt;sizeToFit&lt;/h3&gt;&lt;p&gt;sizeToFit会自动调用sizeThatFits方法；&lt;br&gt;sizeToFit不应该在子类中被重写，应该重写sizeThatFits&lt;br&gt;sizeThatFits传入的参数是receiver当前的size，返回一个适合的size&lt;br&gt;sizeToFit可以被手动直接调用sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ios-layout机制相关方法&quot;&gt;&lt;a href=&quot;#ios-layout机制相关方法&quot; class=&quot;headerlink&quot; title=&quot;ios layout机制相关方法&quot;&gt;&lt;/a&gt;ios layout机制相关方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (CGSize)sizeThatFits:(CGSize)size
- (void)sizeToFit
——————-
- (void)layoutSubviews
- (void)layoutIfNeeded
- (void)setNeedsLayout
——————–
- (void)setNeedsDisplay
- (void)drawRect
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别知识点总结六</title>
    <link href="http://yoursite.com/2016/10/20/iOS%E7%89%B9%E5%88%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%85%AD/"/>
    <id>http://yoursite.com/2016/10/20/iOS特别知识点总结六/</id>
    <published>2016-10-20T14:04:41.000Z</published>
    <updated>2016-10-20T14:06:04.000Z</updated>
    
    <content type="html">&lt;p&gt;//判断内容是否全部为空格  yes 全部为空格  no 不是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)isEmpty:(NSString *) str {

    if (!str) {
        return true;
    } else {
        //A character set containing only the whitespace characters space (U+0020) and tab (U+0009) and the newline and nextline characters (U+000A–U+000D, U+0085).
        NSCharacterSet *set = [NSCharacterSet whitespaceAndNewlineCharacterSet];

        //Returns a new string made by removing from both ends of the receiver characters contained in a given character set.
        NSString *trimedString = [str stringByTrimmingCharactersInSet:set];

        if ([trimedString length] == 0) {
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UITabBarController&quot;&gt;&lt;a href=&quot;#UITabBarController&quot; class=&quot;headerlink&quot; title=&quot;UITabBarController&quot;&gt;&lt;/a&gt;UITabBarController&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//1.创建Window
 self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
 self.window.backgroundColor = [UIColor whiteColor];

 //a.初始化一个tabBar控制器
 UITabBarController *tb=[[UITabBarController alloc]init];
 //设置控制器为Window的根控制器
 self.window.rootViewController=tb;

 //b.创建子控制器
 UIViewController *c1=[[UIViewController alloc]init];
 c1.view.backgroundColor=[UIColor grayColor];
 c1.view.backgroundColor=[UIColor greenColor];
 c1.tabBarItem.title=@&amp;quot;消息&amp;quot;;
 c1.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_recent_nor&amp;quot;];
 c1.tabBarItem.badgeValue=@&amp;quot;123&amp;quot;;

 UIViewController *c2=[[UIViewController alloc]init];
 c2.view.backgroundColor=[UIColor brownColor];
 c2.tabBarItem.title=@&amp;quot;联系人&amp;quot;;
 c2.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_buddy_nor&amp;quot;];

 UIViewController *c3=[[UIViewController alloc]init];
 c3.tabBarItem.title=@&amp;quot;动态&amp;quot;;
 c3.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_qworld_nor&amp;quot;];

 UIViewController *c4=[[UIViewController alloc]init];
 c4.tabBarItem.title=@&amp;quot;设置&amp;quot;;
 c4.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_me_nor&amp;quot;]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;weak-typeof-self-weakSelf-self&quot;&gt;&lt;a href=&quot;#weak-typeof-self-weakSelf-self&quot; class=&quot;headerlink&quot; title=&quot;_weak typeof(self) weakSelf = self;&quot;&gt;&lt;/a&gt;_weak typeof(self) weakSelf = self;&lt;/h3&gt;&lt;p&gt;内存管理原则&lt;br&gt;1、默认strong，可选weak。strong下不管成员变量还是property，每次使用指针指向一个对象，等于自动调用retain(), 并对旧对象调用release(),所以设为nil等于release。&lt;br&gt;2、只要某个对象被任一strong指针指向，那么它将不会被销毁，否则立即释放，不用等runloop结束。所有strong指针变量不需要在dealloc中手动设为nil，iOS会自动处理，debug可以看到全部被置为nil，最先声明的变量最后调用dealloc释放。&lt;/p&gt;
&lt;p&gt;3、官方建议IBOutlet加上__weak，实际上不用加也会自动释放；&lt;/p&gt;
&lt;p&gt;4、优先使用私有成员变量，除非需要公开属性才用property。&lt;/p&gt;
&lt;p&gt;5、避免循环引用，否则手动设置nil释放。&lt;/p&gt;
&lt;p&gt;6、block方法常用声明：@property (copy) void(^MyBlock)(void); 如果超出当前作用域之后仍然继续使用block，那么最好使用copy关键字，拷贝到堆区，防止栈区变量销毁。&lt;/p&gt;
&lt;p&gt;7、创建block匿名函数之前一般需要对self进行weak化，否则造成循环引用无法释放controller:&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;weak MyController *weakSelf = self 或者 &lt;/strong&gt;weak __typeof(self) weakSelf = self;&lt;br&gt;执行block方法体的时候也可以转换为强引用之后再使用：MyController* strongSelf = weakSelf; if (!strongSelf) { return; }&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//判断内容是否全部为空格  yes 全部为空格  no 不是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)isEmpty:(NSString *) str {

    if (!str) {
        return true;
    } else {
        //A character set containing only the whitespace characters space (U+0020) and tab (U+0009) and the newline and nextline characters (U+000A–U+000D, U+0085).
        NSCharacterSet *set = [NSCharacterSet whitespaceAndNewlineCharacterSet];

        //Returns a new string made by removing from both ends of the receiver characters contained in a given character set.
        NSString *trimedString = [str stringByTrimmingCharactersInSet:set];

        if ([trimedString length] == 0) {
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之顶部状态栏statusBar颜色变化小结</title>
    <link href="http://yoursite.com/2016/10/20/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E9%A1%B6%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8FstatusBar%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/10/20/iOS开发之顶部状态栏statusBar颜色变化小结/</id>
    <published>2016-10-20T14:01:28.000Z</published>
    <updated>2016-10-20T14:03:50.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS开发之顶部状态栏statusBar颜色变化小结&lt;/p&gt;
&lt;p&gt;1.单个视图View没有导航控制器包装的情况下&lt;/p&gt;
&lt;p&gt;(1.只设置启动状态栏颜色改变(白色)，而视图中状态栏不变化(默认黑色)，做如下的设置即可，两种方式不管先设置哪一个，另一个都会相应的变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. General 中的 Status Bar Style   --&amp;gt;  Light

b. plist 中增加 Status Bar Style   --&amp;gt;  UIStatusBarStyleLightContent
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;(2).设置启动状态栏颜色改变(白色)，视图中的状态栏也变成白色(保持上面的设置)，有两种设置方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. 在Info.plist里面添加一行View controller-based status bar appearance ＝ NO 即可

b.在视图控制器中添加代码

  - (UIStatusBarStyle)preferredStatusBarStyle {

    return UIStatusBarStyleLightContent;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3).设置视图中状态栏的颜色为白色，启动程序时的状态栏为默认颜色(黑色)，没有做1.中的任何设置情况下，在控制器.m文件中添加如下代码(即2.-&amp;gt;b.)&lt;/p&gt;
&lt;p&gt;2.视图作为导航控制器的根控制器的情况下&lt;/p&gt;
&lt;p&gt;(1) .设置启动画面的状态栏为白色，视图中的状态栏为默认(黑色)，如1.-&amp;gt;1.中的设置即可，&lt;/p&gt;
&lt;p&gt;(2) .设置启动画面和视图中的状态栏颜色都为白色(保持2.-&amp;gt;1.中的设置)，方式同样有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a.在Info.plist里面添加一行View controller-based status bar appearance ＝ NO 即可


b.此时如果单单在视图控制器.m文件中添加如下代码是不够的，

- (UIStatusBarStyle)preferredStatusBarStyle {
    return UIStatusBarStyleLightContent;
}
同时需要在导航控制器.m文件中添加下面的代码才能达到效果(careful)

- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3).只设置视图控制器状态栏颜色为白色，启动画面的状态栏为默认(黑色)，把Info.plist文件中的 Status bar style = UIStatusBarStyleLightContent设置去掉，保持2.-&amp;gt;2.-&amp;gt;b.中的代码设置即可&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发之顶部状态栏statusBar颜色变化小结&lt;/p&gt;
&lt;p&gt;1.单个视图View没有导航控制器包装的情况下&lt;/p&gt;
&lt;p&gt;(1.只设置启动状态栏颜色改变(白色)，而视图中状态栏不变化(默认黑色)，做如下的设置即可，两种方式不管先设置哪一个，另一个都会相应的变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. General 中的 Status Bar Style   --&amp;gt;  Light

b. plist 中增加 Status Bar Style   --&amp;gt;  UIStatusBarStyleLightContent
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发使用系统的拷贝剪切功能</title>
    <link href="http://yoursite.com/2016/10/19/iOS%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%89%AA%E5%88%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/10/19/iOS开发使用系统的拷贝剪切功能/</id>
    <published>2016-10-19T11:15:58.000Z</published>
    <updated>2016-10-19T11:19:30.000Z</updated>
    
    <content type="html">&lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2）响应事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//并加上几个方法
-(void)longPressCellHandle:(UILongPressGestureRecognizer *)gesture {

    [self becomeFirstResponder];
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    UIMenuItem *copyItem = [[UIMenuItem alloc] initWithTitle:@&amp;quot;复制&amp;quot; action:@selector(menuCopyBtnPressed:)];
    menuController.menuItems = @[copyItem];
    [menuController setTargetRect:gesture.view.frame inView:gesture.view.superview];
    [menuController setMenuVisible:YES animated:YES];
    [UIMenuController sharedMenuController].menuItems=nil;
}

// 将要复制的内容复制到系统的剪贴板
- (void)menuCopyBtnPressed:(UIMenuItem *)menuItem {
    //  通用的粘贴板
    [UIPasteboard generalPasteboard].string = self.messageLab.text;
}

- (BOOL)canBecomeFirstResponder {

    return YES;
}

- (BOOL)canPerformAction:(SEL)action withSender:(id)sender {

    if (action == @selector(menuCopyBtnPressed:)) {
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
