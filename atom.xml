<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-14T13:40:13.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中 @synthesize 和 @dynamic 的区别</title>
    <link href="http://yoursite.com/2016/04/14/iOS%E4%B8%AD-synthesize-%E5%92%8C-dynamic-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/04/14/iOS中-synthesize-和-dynamic-的区别/</id>
    <published>2016-04-14T13:28:35.000Z</published>
    <updated>2016-04-14T13:40:13.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其主要的作用就是用在NSManagerObject对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，core data 框架会在程序运行的时候为此类属性生成getter和setter方法。&lt;/p&gt;
&lt;p&gt;被指定为动态实现的方法的dynamicMethod的参数有如下的要求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;A.第一个、第二个参数必须是id、SEL；
B.第三个参数开始，你可以按照原方法（例如：setHeight:(float)）的参数定义。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再接下来，你需要覆盖NSObject 的类方法resolveInstanceMethod，这个方法会把需要动态实现的方法（setHeight:）的选择器传递进来，我们判断一下是否是需要动态实现的选择器，如果是就把处理权转交给dynamicMethod。&lt;/p&gt;
&lt;h3 id=&quot;如何转交呢？&quot;&gt;&lt;a href=&quot;#如何转交呢？&quot; class=&quot;headerlink&quot; title=&quot;如何转交呢？&quot;&gt;&lt;/a&gt;如何转交呢？&lt;/h3&gt;&lt;p&gt;这里我们就要用到运行时函数class_addMethod(Class,SEL,IMP,char[])。&lt;/p&gt;
&lt;p&gt;运行时函数位于objc/runtime.h，正如名字一样，这里面都是C 语言的函数。按照这些函数的功能的不同，主要分为如下几类：操作类型、操作对象、操作协议等。大多数的函数都可以通过名字看出是什么意思，例如：class_addProtocol 动态的为一个类型在运行时增加协议、objc_getProtocol 把一个字符串转换为协议等。&lt;/p&gt;
&lt;p&gt;言归正传，我们来解释一下这里需要用到的class_addmethod 方法，这个方法有四个参数，Class 表示你要为哪个类型增加方法，SEL 参数表示你要增加的方法的选择器，IMP 表示你要添加的方法的运行时的具体实现的函数指针。其实在这里你能够看出SEL 并不能在运行时找到真正要调用的方法，IMP 才可以真正的找到实现方法的。&lt;/p&gt;
&lt;p&gt;现在我们来正式的看以下第四个参数v@:f 的含义，它描述了IMP 指向的函数的描述信息，按照@encode 指令编译之后的字符说明，第一个字符v 表示返回值为void，剩余的字符为dynamicMethod 函数的参数描述，@表示第一个参数id，:自然就是第二个参数SEL，f 就是第三个参数float。由于前面说过动态方法的实现的前两个参数必须是id、SEL，所以第四个参数中的字符串的第二、三个字符一定是@:。我们看到resolveInstanceMethod 方法的返回值为BOOL，也就是这个方法返回YES 表示找到了动态方法的具体实现，否则就表示没有在运行时找到真实的实现，程序就汇报错。&lt;/p&gt;
&lt;p&gt;经过了上面的处理，Objective-C 的运行时只要发现你调用了@dynamic 标注的属性的setter、getter 方法，就会自动到resolveInstanceMethod 里去寻找真实的实现。这也就是说你在main.m 中调用peson.height 的时候，实际上dynamicMethod 函数被调用了。实际上除了@dynamic 标注的属性之外，如果你调用了类型中不存在的方法，也会被 resolveInstanceMethod 或者resolveClassMethod 截获，但由于你没有处理，所以会报告不能识别的消息的错误。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;譬如：从网络下载一个升级包，不需要退出原有的程序，就可以动态的替换掉旧的功能等类似的需求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;@synthesize&lt;/strong&gt;  实际的意义就是 自动生成属性的setter和getter方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@dynamic&lt;/strong&gt;  就是要告诉编译器，代码中用@dynamic修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译（指定一个函数或者其他类的方法作为动态属性的setter、getter方法的运行时实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数－ 函数调用2</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8D-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A82/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数－-函数调用2/</id>
    <published>2016-04-14T13:21:38.000Z</published>
    <updated>2016-04-14T13:47:29.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;补充：respondsToSelector&quot;&gt;&lt;a href=&quot;#补充：respondsToSelector&quot; class=&quot;headerlink&quot; title=&quot;补充：respondsToSelector&quot;&gt;&lt;/a&gt;补充：respondsToSelector&lt;/h3&gt;&lt;p&gt;   +(BOOL)respondsToSelector:(SEL)aSelector &lt;/p&gt;
&lt;p&gt;这个函数大家再熟悉不过了，用来检查对象是否实现了某函数。&lt;/p&gt;
&lt;p&gt;此函数通常是不需要重载的，但是在动态实现了查找过程后，需要重载此函数让对外接口查找动态实现函数的时候返回YES，保证对外接口的行为统一。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; - (BOOL) respondsToSelector:(SEL)aSelector
    {
       if (@selector(setTitle:) == aSelector ||
       @selector(title) == aSelector ||
       @selector(setAuthor:) == aSelector ||
       @selector(author) == aSelector)
      {
        return YES;
      }

       return [super respondsToSelector: aSelector];
    }

  //全局函数
 1.void dynamicMethodIMP(id self, SEL _cmd)
        {
           // implementation ....
        }

 2.+ (BOOL) resolveInstanceMethod:(SEL)aSEL
       {
        if (aSEL == @selector(resolveThisMethodDynamically))
        {
            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &amp;quot;v@:&amp;quot;);
            return YES;
         }
         return [super resolveInstanceMethod:aSel];
       }

  //将消息转出某对象
3.- (id)forwardingTargetForSelector:(SEL)aSelector
      {
       NSLog(@&amp;quot;MyTestObject _cmd: %@&amp;quot;, NSStringFromSelector(_cmd));

        NoneClass *none = [[NoneClass alloc] init];
        if ([none respondsToSelector: aSelector]) {
          return none;
       }

       return [super forwardingTargetForSelector: aSelector];
      }

4.- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector
    {
      NSString *sel = NSStringFromSelector(selector);
      if ([sel rangeOfString:@&amp;quot;set&amp;quot;].location == 0) {
        //动态造一个 setter函数
        return [NSMethodSignature signatureWithObjCTypes:&amp;quot;v@:@&amp;quot;];
      } else {
        //动态造一个 getter函数
        return [NSMethodSignature signatureWithObjCTypes:&amp;quot;@@:&amp;quot;];
      }
   }

5.- (void)forwardInvocation:(NSInvocation *)invocation
      {
       //拿到函数名
       NSString *key = NSStringFromSelector([invocation selector]);
       if ([key rangeOfString:@&amp;quot;set&amp;quot;].location == 0) {
          //setter函数形如 setXXX: 拆掉 set和冒号 
          key = [[key substringWithRange:NSMakeRange(3, [key length]-4)] lowercaseString];
          NSString *obj;
          //从参数列表中找到值
          [invocation getArgument:&amp;amp;obj atIndex:2];
          [data setObject:obj forKey:key];
        } else {
          //getter函数就相对简单了，直接把函数名做 key就好了。
          NSString *obj = [data objectForKey:key];
          [invocation setReturnValue:&amp;amp;obj];
        }
      }
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;补充：respondsToSelector&quot;&gt;&lt;a href=&quot;#补充：respondsToSelector&quot; class=&quot;headerlink&quot; title=&quot;补充：respondsToSelector&quot;&gt;&lt;/a&gt;补充：respondsToSelector&lt;/h3&gt;&lt;p&gt;   +(BOOL)respondsToSelector:(SEL)aSelector &lt;/p&gt;
&lt;p&gt;这个函数大家再熟悉不过了，用来检查对象是否实现了某函数。&lt;/p&gt;
&lt;p&gt;此函数通常是不需要重载的，但是在动态实现了查找过程后，需要重载此函数让对外接口查找动态实现函数的时候返回YES，保证对外接口的行为统一。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数－ 函数调用</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8D-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数－-函数调用/</id>
    <published>2016-04-14T13:20:13.000Z</published>
    <updated>2016-04-14T13:48:24.000Z</updated>
    
    <content type="html">&lt;p&gt;  Objective-C是一门动态语言，一个函数是由一个selector(SEL)，和一个implement(IML)组成的。Selector相当于门牌号，而Implement才是真正的住户（函数实现）。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  和现实生活一样，门牌可以随便发（@selector(XXX)），但是不一定都找得到住户，如果找不到系统会给程序几次机会来程序正常运行，实在没出路了才会抛出异常。下图是objc_msgSend调用时，查找SEL的IML的过程。咱们以这个流程为例看看其中涉及的很有用的函数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;/img/objc_msgSend.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;resolveInstanceMethod-函数&quot;&gt;&lt;a href=&quot;#resolveInstanceMethod-函数&quot; class=&quot;headerlink&quot; title=&quot;resolveInstanceMethod 函数&quot;&gt;&lt;/a&gt;resolveInstanceMethod 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;+ (BOOL)resolveInstanceMethod:(SEL)name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数在运行时(runtime)，没有找到SEL的IML时就会执行。这个函数是给类利用class_addMethod添加函数的机会。根据文档，如果实现了添加函数代码则返回YES，未实现返回NO。&lt;/p&gt;
&lt;h3 id=&quot;forwardingTargetForSelector-函数&quot;&gt;&lt;a href=&quot;#forwardingTargetForSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;forwardingTargetForSelector 函数&quot;&gt;&lt;/a&gt;forwardingTargetForSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;流程到了这里，系统给了个将这个SEL转给其他对象的机会。返回参数是一个对象，如果这个对象非nil、非self的话，系统会将运行的消息转发给这个对象执行。否则，继续查找其他流程。&lt;/p&gt;
&lt;h3 id=&quot;methodSignatureForSelector-函数&quot;&gt;&lt;a href=&quot;#methodSignatureForSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;methodSignatureForSelector 函数&quot;&gt;&lt;/a&gt;methodSignatureForSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数和后面的forwardInvocation:是最后一个寻找IML的机会。这个函数让重载方有机会抛出一个函数的签名，再由后面的forwardInvocation:去执行。&lt;/p&gt;
&lt;h3 id=&quot;forwardInvocation-函数&quot;&gt;&lt;a href=&quot;#forwardInvocation-函数&quot; class=&quot;headerlink&quot; title=&quot;forwardInvocation 函数&quot;&gt;&lt;/a&gt;forwardInvocation 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;真正执行从methodSignatureForSelector:返回的NSMethodSignature。在这个函数里可以将NSInvocation多次转发到多个对象中，这也是这种方式灵活的地方。（forwardingTargetForSelector只能以Selector的形式转向一个对象）&lt;/p&gt;
&lt;h3 id=&quot;doesNotRecognizeSelector-函数&quot;&gt;&lt;a href=&quot;#doesNotRecognizeSelector-函数&quot; class=&quot;headerlink&quot; title=&quot;doesNotRecognizeSelector 函数&quot;&gt;&lt;/a&gt;doesNotRecognizeSelector 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)doesNotRecognizeSelector:(SEL)aSelector
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为找不到函数实现的最后一步，NSObject实现这个函数只有一个功能，就是抛出异常。&lt;/p&gt;
&lt;p&gt;虽然理论上可以重载这个函数实现保证不抛出异常（不调用super实现），但是苹果文档着重提出“一定不能让这个函数就这么结束掉，必须抛出异常”。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;在一个函数找不到时，Objective-C提供了三种方式去补救：&lt;/p&gt;
&lt;p&gt;1、调用resolveInstanceMethod给个机会让类添加这个实现这个函数&lt;/p&gt;
&lt;p&gt;2、调用forwardingTargetForSelector让别的对象去执行这个函数&lt;/p&gt;
&lt;p&gt;3、调用methodSignatureForSelector（函数符号制造器）和forwardInvocation（函数执行器）灵活的将目标函数以其他形式执行。&lt;/p&gt;
&lt;p&gt;如果都不中，调用doesNotRecognizeSelector抛出异常。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  Objective-C是一门动态语言，一个函数是由一个selector(SEL)，和一个implement(IML)组成的。Selector相当于门牌号，而Implement才是真正的住户（函数实现）。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title> 继承自NSObject的不常用又很有用的函数load 和 initialize</title>
    <link href="http://yoursite.com/2016/04/14/%E7%BB%A7%E6%89%BF%E8%87%AANSObject%E7%9A%84%E4%B8%8D%E5%B8%B8%E7%94%A8%E5%8F%88%E5%BE%88%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0load-%E5%92%8C-initialize/"/>
    <id>http://yoursite.com/2016/04/14/继承自NSObject的不常用又很有用的函数load-和-initialize/</id>
    <published>2016-04-14T13:17:18.000Z</published>
    <updated>2016-04-14T13:43:09.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;初始化阶段-－－-load-函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-load-函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ load 函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ load 函数&lt;/h3&gt;&lt;p&gt; +(void)load&lt;/p&gt;
&lt;p&gt;当类被引用进程序的时候会执行这个函数。&lt;/p&gt;
&lt;p&gt;在一个程序开始运行之前（在main函数开始执行之前）,在库开始被程序加载，load函数就会开始被执行。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们开发的程序都可以认为是一个库，但是库又不会独立存在（我们的程序还会引用其他库，也可能被其他函数引用），所以库的初始化顺序可以如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 初始化我们引用的库
2. 执行我们自己库的Objective-C的load函数
3. 执行C++和C的static初始化变量
4. 初始化引用我们库的其他库
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在我们的编写的库中，会有很多类重写load函数，他们之间的执行顺序是不确定的。&lt;/p&gt;
&lt;p&gt;当父类和子类都实现load函数时，父类的load函数会被先执行。load函数是系统自动加载的，因此不需要调用父类的load函数，否则父类的load函数会多次执行。&lt;/p&gt;
&lt;p&gt;在Category中写load函数是不会替换原始类中的load函数的，原始类和Category中的load函数都会被执行，原始类的load会先被执行，再执行Category中的load函数。当有多个Category都实现了load函数，这几个load函数执行顺序不确定。&lt;/p&gt;
&lt;h3 id=&quot;初始化阶段-－－-Initialize函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-Initialize函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ Initialize函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ Initialize函数&lt;/h3&gt;&lt;p&gt; +(void)initialize&lt;/p&gt;
&lt;p&gt;当类第一次被执行到的时候这个函数会被执行。&lt;/p&gt;
&lt;p&gt;如果类包含继承关系，父类的initialize函数会比子类先执行。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。&lt;/p&gt;
&lt;p&gt;假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。&lt;/p&gt;
&lt;h3 id=&quot;Load-or-Initialize&quot;&gt;&lt;a href=&quot;#Load-or-Initialize&quot; class=&quot;headerlink&quot; title=&quot;Load or Initialize&quot;&gt;&lt;/a&gt;Load or Initialize&lt;/h3&gt;&lt;p&gt;这两个函数没有交集，也没有执行的先后顺序，他们各自遵循着各自的调用原则。因此在写逻辑的时候，不能有逻辑依赖load函数比initialize函数先行调用。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;p&gt;将针对于类修改放在intialize中，将针对Category的修改放在load中。&lt;/p&gt;
&lt;p&gt;但是假如我们是修改系统的类，一般会通过添加Category来添加功能，但是如果修改initialize会导致原生的intialize不会执行，所以&lt;strong&gt;放在load中&lt;/strong&gt;会比较妥当。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;初始化阶段-－－-load-函数&quot;&gt;&lt;a href=&quot;#初始化阶段-－－-load-函数&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段 －－ load 函数&quot;&gt;&lt;/a&gt;初始化阶段 －－ load 函数&lt;/h3&gt;&lt;p&gt; +(void)load&lt;/p&gt;
&lt;p&gt;当类被引用进程序的时候会执行这个函数。&lt;/p&gt;
&lt;p&gt;在一个程序开始运行之前（在main函数开始执行之前）,在库开始被程序加载，load函数就会开始被执行。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>定时器NSTimer</title>
    <link href="http://yoursite.com/2016/04/08/%E5%AE%9A%E6%97%B6%E5%99%A8NSTimer/"/>
    <id>http://yoursite.com/2016/04/08/定时器NSTimer/</id>
    <published>2016-04-08T14:13:12.000Z</published>
    <updated>2016-04-08T14:19:48.000Z</updated>
    
    <content type="html">&lt;p&gt;定时器类具有五种初始化方法，包含四种工厂方法和一个实例化方法。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 invocation:invocation repeats:NO];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer2 = [NSTimer scheduledTimerWithTimeInterval:2.0 invocation:invocation repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer3 = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(myLog) userInfo:@”123” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer4 = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(myLog) userInfo:@”456” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSTimer *timer5 = [[NSTimer alloc] initWithFireDate:date interval:2.0 target:self selector:@selector(myLog) userInfo:@”789” repeats:YES];&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; TimerInterval : 执行之前等待的时间。比如设置成1.0，就代表1秒后执行方法
 target : 需要执行方法的对象。
 selector : 需要执行的方法
 repeats : 是否需要循环
 userInfo : 用户信息

方法中需要调用的对象：

      NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(initW)]];
      [invocation setTarget:self];
      [invocation setSelector:@selector(myLog)];

  需要分别实现 **initW **和 **myLog** 方法。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;将-NSTimer-对象加入Runloop&quot;&gt;&lt;a href=&quot;#将-NSTimer-对象加入Runloop&quot; class=&quot;headerlink&quot; title=&quot;将 NSTimer 对象加入Runloop&quot;&gt;&lt;/a&gt;将 NSTimer 对象加入Runloop&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[NSRunLoop mainRunLoop] addTimer:timer3 forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;释放方法&quot;&gt;&lt;a href=&quot;#释放方法&quot; class=&quot;headerlink&quot; title=&quot;释放方法&quot;&gt;&lt;/a&gt;释放方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[timer invalidate];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;启动方法&quot;&gt;&lt;a href=&quot;#启动方法&quot; class=&quot;headerlink&quot; title=&quot;启动方法&quot;&gt;&lt;/a&gt;启动方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. [timer2 fire];

2. timer4.fireDate = [NSDate distantPast];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;定时器类具有五种初始化方法，包含四种工厂方法和一个实例化方法。
    
    </summary>
    
    
      <category term="［定时器］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>路径类NSURL的使用</title>
    <link href="http://yoursite.com/2016/04/07/%E8%B7%AF%E5%BE%84%E7%B1%BBNSURL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/07/路径类NSURL的使用/</id>
    <published>2016-04-07T13:00:28.000Z</published>
    <updated>2016-04-07T13:01:20.000Z</updated>
    
    <content type="html">&lt;p&gt;NSURL 类作为路径和地址的表示类，在各种场合都发挥很大的作用。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;共有18中初始化方法 （9种实例化方法 + 9种工厂方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init...
URLWith...
fileURLWith...
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;比较方法&quot;&gt;&lt;a href=&quot;#比较方法&quot; class=&quot;headerlink&quot; title=&quot;比较方法&quot;&gt;&lt;/a&gt;比较方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;isEqual:
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;查询一个NSURL&quot;&gt;&lt;a href=&quot;#查询一个NSURL&quot; class=&quot;headerlink&quot; title=&quot;查询一个NSURL&quot;&gt;&lt;/a&gt;查询一个NSURL&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;checkResourceIsReachableAndReturnError:  返回一个文件URL指向的资源是否可达
isFileReferenceURL
isFileURL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h3&gt;&lt;p&gt;NSURLFileScheme  : 文件URL的scheme&lt;br&gt;还有一堆文件资源的key，如 属性修改日期、访问日期、内容修改日期、创建日期、自定义Icon、文件标识符、文件类型、文件安全、是否隐藏扩展名、是否是文件夹等&lt;/p&gt;
&lt;h3 id=&quot;NSURL的属性：&quot;&gt;&lt;a href=&quot;#NSURL的属性：&quot; class=&quot;headerlink&quot; title=&quot;NSURL的属性：&quot;&gt;&lt;/a&gt;NSURL的属性：&lt;/h3&gt;&lt;p&gt;例如：scheme、user、password、host、port、path、pathComponents、pathExtension、lastPathComponent、parameterString、fragment&lt;/p&gt;
&lt;h3 id=&quot;get和set-File-System-Resource-Properties-这部分需要加强理解&quot;&gt;&lt;a href=&quot;#get和set-File-System-Resource-Properties-这部分需要加强理解&quot; class=&quot;headerlink&quot; title=&quot;get和set File System Resource Properties(这部分需要加强理解)&quot;&gt;&lt;/a&gt;get和set File System Resource Properties(这部分需要加强理解)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString *size = Nil;
NSError *error = [[NSError alloc] initWithDomain:@&amp;quot;1&amp;quot; code:1 userInfo:Nil];

NSURL *samplePath = [[NSURL alloc] initWithString:@&amp;quot;file://Users/Users/zxq/Desktop/1.pdf&amp;quot;];

//获取文件的大小
[samplePath getResourceValue:&amp;amp;size forKey:NSURLFileSizeKey error:&amp;amp;error];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLTotalFileSizeKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取文件地址
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLPathKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取最后修改的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   [samplePath getResourceValue:&amp;amp;size forKey:NSURLCreationDateKey error:&amp;amp;error];&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//获取文件名
[samplePath getResourceValue:&amp;amp;size forKey:NSURLNameKey error:&amp;amp;error];
NSLog(@&amp;quot;Error == %@&amp;quot;, error);
NSLog(@&amp;quot;size == %@&amp;quot;, size);


//是否可达
NSLog(@&amp;quot;%d&amp;quot;, [samplePath checkPromisedItemIsReachableAndReturnError:&amp;amp;error]);

NSLog(@&amp;quot;%d&amp;quot;, [samplePath isFileReferenceURL]);
NSLog(@&amp;quot;%d&amp;quot;, [samplePath isFileURL]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;NSURL 类作为路径和地址的表示类，在各种场合都发挥很大的作用。&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h3&gt;&lt;p&gt;共有18中初始化方法 （9种实例化方法 + 9种工厂方法）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;init...
URLWith...
fileURLWith...
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="［NSURL］" scheme="http://yoursite.com/tags/%EF%BC%BBNSURL%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>十个iOS面试问题</title>
    <link href="http://yoursite.com/2016/03/31/%E5%8D%81%E4%B8%AAiOS%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/03/31/十个iOS面试问题/</id>
    <published>2016-03-31T12:01:39.000Z</published>
    <updated>2016-03-31T12:04:57.000Z</updated>
    
    <content type="html">&lt;p&gt;哪一天我能解决这十个问题了，我也算是有小成了，直接上题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你实现过多线程的Core Data么？NSPersistentStoreCoordinator，NSManagedObjectContext和NSManagedObject中的哪些需要在线程中创建或者传递？你是用什么样的策略来实现的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Core开头的系列的内容。是否使用过CoreAnimation和CoreGraphics。UI框架和CA，CG框架的联系是什么？分别用CA和CG做过些什么动画或者图像上的内容。（有需要的话还可以涉及Quartz的一些内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是否使用过CoreText或者CoreImage等？如果使用过，请谈谈你使用CoreText或者CoreImage的体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO，它们的实现上有什么区别吗？如果用protocol和delegate（或者delegate的Array）来实现类似的功能可能吗？如果可能，会有什么潜在的问题？如果不能，为什么？（虽然protocol和delegate这种东西面试已经面烂了…）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你用过NSOperationQueue么？如果用过或者了解的话，你为什么要使用NSOperationQueue，实现了什么？请描述它和GCD的区别和类似的地方（提示：可以从两者的实现机制和适用范围来描述）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;既然提到GCD，那么问一下在使用GCD以及block时要注意些什么？它们两是一回事儿么？block在ARC中和传统的MRC中的行为和用法有没有什么区别，需要注意些什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;您是否做过异步的网络处理和通讯方面的工作？如果有，能具体介绍一些实现策略么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你实现过一个框架或者库以供别人使用么？如果有，请谈一谈构建框架或者库时候的经验；如果没有，请设想和设计框架的public的API，并指出大概需要如何做、需要注意一些什么方面，来使别人容易地使用你的框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;哪一天我能解决这十个问题了，我也算是有小成了，直接上题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？
    
    </summary>
    
    
      <category term="iOS 成长之路" scheme="http://yoursite.com/tags/iOS-%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>随机数的生成</title>
    <link href="http://yoursite.com/2016/03/31/%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2016/03/31/随机数的生成/</id>
    <published>2016-03-31T11:49:15.000Z</published>
    <updated>2016-03-31T11:55:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;如何生成一个-Objective-C-的随机数&quot;&gt;&lt;a href=&quot;#如何生成一个-Objective-C-的随机数&quot; class=&quot;headerlink&quot; title=&quot;如何生成一个 Objective-C 的随机数&quot;&gt;&lt;/a&gt;如何生成一个 Objective-C 的随机数&lt;/h3&gt;&lt;p&gt;   具体而言，产生一个 0 和 N - 1 之间的随机数，使用 arc4random_uniform()，从而避免模偏差(modulo bias)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;0 到 N - 1 之间的随机整数&lt;/p&gt;
&lt;p&gt;  NSUInteger r = arc4random_uniform(N);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;1 到 N 之间的随机整数 &lt;/p&gt;
&lt;p&gt;  NSUInteger r = arc4random_uniform(N) + 1;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;0 到 1 之间的随机浮点数（double）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你要生成一个随机 double 或 float，另一个很好的选择是功能较模糊的 rand48 家族，包括 drand48(3)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;srand48(time(0));
double r = drand48();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 不像 arc4random 函数， rand48 函数在产生随机数之前需要种子的初始值。这个种子函数 srand48(3) 应该只运行一次&lt;/p&gt;
&lt;h4 id=&quot;我如何从一个-NSArray-选择一个随机元素？&quot;&gt;&lt;a href=&quot;#我如何从一个-NSArray-选择一个随机元素？&quot; class=&quot;headerlink&quot; title=&quot;我如何从一个 NSArray 选择一个随机元素？&quot;&gt;&lt;/a&gt;我如何从一个 NSArray 选择一个随机元素？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;if ([array count] &amp;gt; 0) {
  id obj = array[arc4random_uniform([array count])];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;我如何随机排序一个-NSArray？&quot;&gt;&lt;a href=&quot;#我如何随机排序一个-NSArray？&quot; class=&quot;headerlink&quot; title=&quot;我如何随机排序一个 NSArray？&quot;&gt;&lt;/a&gt;我如何随机排序一个 NSArray？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
NSUInteger count = [mutableArray count];

if (count &amp;gt; 1) {
  for (NSUInteger i = count - 1; i &amp;gt; 0; --i) {
      [mutableArray exchangeObjectAtIndex:i withObjectAtIndex:arc4random_uniform((int32_t)(i + 1))];
   }
}
NSArray *randomArray = [NSArray arrayWithArray:mutableArray];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;生成一个随机的小写-NSString&quot;&gt;&lt;a href=&quot;#生成一个随机的小写-NSString&quot; class=&quot;headerlink&quot; title=&quot;生成一个随机的小写 NSString&quot;&gt;&lt;/a&gt;生成一个随机的小写 NSString&lt;/h4&gt;&lt;p&gt;如果你是对一个已知的，连续范围的 Unicode 字符做处理，例如小写字母 (U+0061 — U+007A)，你可以从 char 做一个简单的换算：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *letter = [NSString stringWithFormat:@&amp;quot;%c&amp;quot;, arc4random_uniform(26) + &amp;apos;a&amp;apos;];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;从一个-NSString-选择一个随机字符&quot;&gt;&lt;a href=&quot;#从一个-NSString-选择一个随机字符&quot; class=&quot;headerlink&quot; title=&quot;从一个 NSString 选择一个随机字符&quot;&gt;&lt;/a&gt;从一个 NSString 选择一个随机字符&lt;/h4&gt;&lt;p&gt;另外，从一组你选择的字符中来挑选随机字母的一个简单的方法是简单地创建一个包含所有可能的字母的字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *vowels = @&amp;quot;aeiouy&amp;quot;;
NSString *letter = [vowels substringWithRange:NSMakeRange(arc4random_uniform([vowels length]), 1)];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;为什么要使用-arc4random-3-，而不是-rand-3-或-random-3-？&quot;&gt;&lt;a href=&quot;#为什么要使用-arc4random-3-，而不是-rand-3-或-random-3-？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用 arc4random(3)，而不是 rand(3) 或 random(3)？&quot;&gt;&lt;/a&gt;为什么要使用 arc4random(3)，而不是 rand(3) 或 random(3)？&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;arc4random 不需要初始种子（用 srand 或 srandom），使它更加容易使用。
arc4random 范围可达 0x100000000 (4294967296)，而 rand 和 random 的上限在 RAND_MAX = 0x7fffffff (2147483647)。
rand 经常定期被周期低位的方式，使其更可预测执行。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;什么是-rand-3-random-3-和-arc4random-3-，以及它们从哪里来的？&quot;&gt;&lt;a href=&quot;#什么是-rand-3-random-3-和-arc4random-3-，以及它们从哪里来的？&quot; class=&quot;headerlink&quot; title=&quot;什么是 rand(3), random(3), 和 arc4random(3)，以及它们从哪里来的？&quot;&gt;&lt;/a&gt;什么是 rand(3), random(3), 和 arc4random(3)，以及它们从哪里来的？&lt;/h4&gt;&lt;p&gt;rand 是一个标准的 C 函数。&lt;br&gt;random 是定义为 POSIX 标准的一部分。&lt;br&gt;arc4random 是在 BSD 和派生平台。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何生成一个-Objective-C-的随机数&quot;&gt;&lt;a href=&quot;#如何生成一个-Objective-C-的随机数&quot; class=&quot;headerlink&quot; title=&quot;如何生成一个 Objective-C 的随机数&quot;&gt;&lt;/a&gt;如何生成一个 Objective-C 的随机数&lt;/h3&gt;&lt;p&gt;   具体而言，产生一个 0 和 N - 1 之间的随机数，使用 arc4random_uniform()，从而避免模偏差(modulo bias)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;0 到 N - 1 之间的随机整数&lt;/p&gt;
&lt;p&gt;  NSUInteger r = arc4random_uniform(N);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>nil_Nil_NULL和NSNull</title>
    <link href="http://yoursite.com/2016/03/31/nil-Nil-NULL%E5%92%8CNSNull/"/>
    <id>http://yoursite.com/2016/03/31/nil-Nil-NULL和NSNull/</id>
    <published>2016-03-31T11:46:08.000Z</published>
    <updated>2016-03-31T11:55:41.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;/img/null_nil.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C用0来作为不存在的原始值，而NULL作为指针(这在指针环境中相当于0)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Objective-C在C的表达不存在的基础上增加了nil。nil是一个指向不存在的对象指针。虽然它在语义上与NULL不同，但它们在技术上是相等的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在框架层面，Foundation定义了NSNull，即一个类方法+null，它返回一个单独的NSNull对象。NSNull与nil以及NULL不同，因为它是一个实际的对象，而不是一个零值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外，在Foundation/NSObjCRuntime.h中，Nil被定义为指向零的类指针。这个nil的鲜为人知的大写的表兄并不常常出现，但它至少值得注意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;刚被分配的NSObject的内容被设置为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/null_nil.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="nil" scheme="http://yoursite.com/tags/nil/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C的警告</title>
    <link href="http://yoursite.com/2016/03/31/Objective-C%E7%9A%84%E8%AD%A6%E5%91%8A/"/>
    <id>http://yoursite.com/2016/03/31/Objective-C的警告/</id>
    <published>2016-03-31T11:41:07.000Z</published>
    <updated>2016-03-31T12:05:53.000Z</updated>
    
    <content type="html">&lt;p&gt;Apple LLVM 7.0 - Warning - objective C &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Direct userage of ‘isa’                  直接使用 isa&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Duplicate Method Definitions             重复的方法定义   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implict Atomic Objective - C Properties  隐式的原子属性&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implict Synthesized Properties           隐式的合成属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Incomplete Objective - C Protocols       不完整的实现协议方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Overridding Deprecated Objective - C Methods  压倒一切弃用的oc方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strict Selector Matching       严格的选择器匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Undeclared Selector            未申报的选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unintentional Root Class       无意的根类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;警告的种类&quot;&gt;&lt;a href=&quot;#警告的种类&quot; class=&quot;headerlink&quot; title=&quot;警告的种类&quot;&gt;&lt;/a&gt;警告的种类&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;-Wall 并不是所有警告。这一个警告组开启的是编译器开发者对于“你所写的代码中有问题”这一命题有着很高的自信的那些警告。要是在这一组设定下你的代码出现了警告，那基本上就是你的代码真的存在严重问题了。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;-Wextra 如其所名，-Wextra组提供“额外的”警告。这个组和-Wall组几乎一样有用，但是有些情况下对于代码相对过于严苛。一个很常见的例子是，-Wextra中包含了-Wsign-compare，这个警告标识会开启比较时候对signed和unsigned的类型检查，当比较符两边一边是signed一边是unsigned时，产生警告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-Weverything 这个是真正的所有警告。但是一般开发者不会选择使用这个标识，因为它包含了那些还正在开发中的可能尚存bug的警告提示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;控制警告，局部加入或关闭&quot;&gt;&lt;a href=&quot;#控制警告，局部加入或关闭&quot; class=&quot;headerlink&quot; title=&quot;控制警告，局部加入或关闭&quot;&gt;&lt;/a&gt;控制警告，局部加入或关闭&lt;/h3&gt;&lt;p&gt;Clang提供了我们自己加入警告或者暂时关闭警告的办法。&lt;/p&gt;
&lt;p&gt;强制加入一个警告：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//Generate a warning
#pragma message &amp;quot;Warning 1&amp;quot;

//Another way to generate a warning
#warning &amp;quot;Warning 2&amp;quot;

//Generate an error to fail the build.
#error &amp;quot;Something wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关闭某个警告：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果需要全局关闭的话，直接在Other C Flags里写-Wno-…就行了，比如-Wextra -Wno-sign-compare就是一个常见的组合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果相对某几个文件开启或禁用警告，在Build Phases的Compile Source相应的文件中加入对应的编译标识即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果只是想在某几行关闭某个警告的话，可以通过临时改变诊断编译标记来抑制指定类型的警告，具体如下：&lt;/p&gt;
&lt;p&gt; #pragma clang diagnostic push&lt;br&gt; #pragma clang diagnostic ignored “-Wunused-variable”&lt;br&gt; int a;&lt;br&gt; #pragma clang diagnostic pop&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注： 把某些警告当作错误，-Werror=…即可，同样地，也可以在-Werror被激活时使用-Wno-error=…来使某些警告不成为错误。结合使用这些编译标识可以达到很好的控制。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Apple LLVM 7.0 - Warning - objective C &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Direct userage of ‘isa’                  直接使用 isa&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Duplicate Method Definitions             重复的方法定义   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Implict Atomic Objective - C Properties  隐式的原子属性&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NS_Enum &amp; NS_Options</title>
    <link href="http://yoursite.com/2016/03/31/NS-Enum-NS-Options/"/>
    <id>http://yoursite.com/2016/03/31/NS-Enum-NS-Options/</id>
    <published>2016-03-31T11:37:57.000Z</published>
    <updated>2016-04-14T13:56:19.000Z</updated>
    
    <content type="html">&lt;p&gt;一个专业的 Objective-C 工程师应该在面向对象和面向过程范式间优雅地切换，同时能够掌握&lt;br&gt;二者的优势。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;    typedef NS_ENUM(NSInteger, UITableViewCellStyle) {         &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  UITableViewCellStyleDefault,
  UITableViewCellStyleValue1,
  UITableViewCellStyleValue2,
  UITableViewCellStyleSubtitle
};
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。&lt;br&gt; 这种实现方法提取了之前各种不同实现的优点，甚至有提示编辑器在进行 switch 判断时检查类型匹配的功能。&lt;/p&gt;
&lt;p&gt;enum 也可以被定义为&lt;strong&gt;按位掩码（bitmask）&lt;/strong&gt;。用简单的OR (|)和AND (&amp;amp;)数学运算即可实现对一个整型值的编码。每一个值不是自动被赋予从0开始依次累加1的值，而是手动被赋予一个带有一个bit偏移量的值：类似1 &amp;lt;&amp;lt; 0、 1 &amp;lt;&amp;lt; 1、 1 &amp;lt;&amp;lt; 2等。如果你能够心算出每个数字的二进制表示法，例如：10110 代表 22，每一位都可以被认为是一个单独的布尔值。例如在UIKit中， UIViewAutoresizing 就是一个可以表示任何flexible top、bottom、 left 或 right margins、width、height组合的位掩码。&lt;/p&gt;
&lt;p&gt;不像 NS_ENUM ，&lt;strong&gt;位掩码用 NS_OPTIONS 宏&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。同样的，注意值的区间不要超过所使用类型的最大容纳范围。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一个专业的 Objective-C 工程师应该在面向对象和面向过程范式间优雅地切换，同时能够掌握&lt;br&gt;二者的优势。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;    typedef NS_ENUM(NSInteger, UITableViewCellStyle) {         &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  UITableViewCellStyleDefault,
  UITableViewCellStyleValue1,
  UITableViewCellStyleValue2,
  UITableViewCellStyleSubtitle
};
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>2016年了，要毕业了QAQ</title>
    <link href="http://yoursite.com/2016/03/28/2016%E5%B9%B4%E4%BA%86%EF%BC%8C%E8%A6%81%E6%AF%95%E4%B8%9A%E4%BA%86QAQ/"/>
    <id>http://yoursite.com/2016/03/28/2016年了，要毕业了QAQ/</id>
    <published>2016-03-28T12:28:42.000Z</published>
    <updated>2016-03-28T13:05:49.000Z</updated>
    
    <content type="html">&lt;p&gt;2016年，今年好像又有奥运会了，回想起三年前的那个夏天懵懵懂懂地来到了现在的母校。第一学期过的是那么的开心的，感觉自己的大学好大，里面的女生都好漂亮的，毕竟是师范类院校。在这个大学里面认识了很多人，也尝遍了很多人情事故。记得大学里面很流行的一种风俗，说什么朋友才是陪伴你一生的，其他奖学金，预备党员什么的，学生干部什么的其实都不重要。可是也许我比较另类吧，当了三年的学生干部，也拿了三年的奖学金，所幸也有几个还算好的朋友。&lt;/p&gt;
&lt;p&gt;一年之际在于春，既然如此顺便展望一下我的未来吧！&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2016年，今年应该会成为我成长最快的一年的吧。步入社会，去寻找属于自己的方向。算起来我接触iOS已经有半年多了，洋洋洒洒写下的oc代码也大概有三四万行了。一般的项目也基本不在话下了。最近尝试写了几个小框架，虽然也能算个框架，不过跟yy比起来那真是差的有点太多了。不过我好像是的不知天高地厚的家伙，yy能办到的事也许我一年内办不到，那我一年的努力总应该能达到他的一半多吧。那么我该怎么做呢？如果可以的话，在这一年度里，我的代码量应该达到15万行。然后再学习一下Python这门语言，用它来强化一下我的算法。&lt;/p&gt;
&lt;p&gt;那么就大概安排一下具体的计划：&lt;/p&gt;
&lt;p&gt; 3-4月：将 iOS 可能使用的框架类别理解清楚，还有三四个框架还需要详细了解一下才好。&lt;/p&gt;
&lt;p&gt; 5-7月：大量阅读github 上开源的项目，哈哈，有点题海战术的味道&lt;/p&gt;
&lt;p&gt; 8-10: 这个时候我应该差不多能写出稍微好看一点的框架来吧&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;2016年，今年好像又有奥运会了，回想起三年前的那个夏天懵懵懂懂地来到了现在的母校。第一学期过的是那么的开心的，感觉自己的大学好大，里面的女生都好漂亮的，毕竟是师范类院校。在这个大学里面认识了很多人，也尝遍了很多人情事故。记得大学里面很流行的一种风俗，说什么朋友才是陪伴你一生的，其他奖学金，预备党员什么的，学生干部什么的其实都不重要。可是也许我比较另类吧，当了三年的学生干部，也拿了三年的奖学金，所幸也有几个还算好的朋友。&lt;/p&gt;
&lt;p&gt;一年之际在于春，既然如此顺便展望一下我的未来吧！
    
    </summary>
    
    
      <category term="［你好，请多多指教～］" scheme="http://yoursite.com/tags/%EF%BC%BB%E4%BD%A0%E5%A5%BD%EF%BC%8C%E8%AF%B7%E5%A4%9A%E5%A4%9A%E6%8C%87%E6%95%99%EF%BD%9E%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>StoryBoard 可视化界面布局注意点</title>
    <link href="http://yoursite.com/2016/03/27/StoryBoard-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2%E5%B8%83%E5%B1%80%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2016/03/27/StoryBoard-可视化界面布局注意点/</id>
    <published>2016-03-27T02:37:48.000Z</published>
    <updated>2016-03-27T02:50:18.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;使用-ScrollView-进行自动布局&quot;&gt;&lt;a href=&quot;#使用-ScrollView-进行自动布局&quot; class=&quot;headerlink&quot; title=&quot;使用 ScrollView 进行自动布局&quot;&gt;&lt;/a&gt;使用 ScrollView 进行自动布局&lt;/h3&gt;&lt;p&gt; 解决方案：可以在 ScrollView 上添加一个唯一的子视图，大小和 ScrollView 一样，然后所有原来计划添加到 ScrollView 上的控件，都添加到子视图上面。&lt;br&gt; &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 Controller 自带的 View 里面添加一个 ScrollView，约束距离为（0，0，0，0）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 ScrollView 里面添加子视图 View ，约束 ScrollView 的距离为（0，0，0，0）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在下面设置约束的4个按钮的第二个，如果想要上下滑动，则选择 Horizontal Center in Container, 并打上对勾，（如果想要左右滑动就选择 Vertical Center in Container， 同时实现左右上下则全不选）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后设置 View 的高度 Height（或者宽度 Width），这个高度或者宽度就是运行后 Scroller 的 ContentSize ；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;动态设置高度或者宽度&quot;&gt;&lt;a href=&quot;#动态设置高度或者宽度&quot; class=&quot;headerlink&quot; title=&quot;动态设置高度或者宽度&quot;&gt;&lt;/a&gt;动态设置高度或者宽度&lt;/h4&gt;&lt;p&gt;将 View 的高度或者宽度设置成属性，然后重写 -(void)updateViewConstraints 方法，在调用 super 之后动态的设置 高度 这个约束的 constant 属性。&lt;/p&gt;
&lt;h3 id=&quot;使用xcode-storyboard设置按钮圆角方法&quot;&gt;&lt;a href=&quot;#使用xcode-storyboard设置按钮圆角方法&quot; class=&quot;headerlink&quot; title=&quot;使用xcode storyboard设置按钮圆角方法&quot;&gt;&lt;/a&gt;使用xcode storyboard设置按钮圆角方法&lt;/h3&gt;&lt;p&gt;  在 sb 中点击右侧指示器的第三个下的  “User Defined Runtime Attribute” 添加 layer.cornerRadius 的值。&lt;br&gt;-&amp;gt; 在代码中：self.button.layer.cornerRadius = 10;&lt;/p&gt;
&lt;h3 id=&quot;设置-navigationController-标题的颜色&quot;&gt;&lt;a href=&quot;#设置-navigationController-标题的颜色&quot; class=&quot;headerlink&quot; title=&quot;设置 navigationController 标题的颜色&quot;&gt;&lt;/a&gt;设置 navigationController 标题的颜色&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDictionary *attributes=[NSDictionary dictionaryWithObjectsAndKeys:BASECOLOR, NSForegroundColorAttributeName,nil];
[self.navigationController.navigationBar setTitleTextAttributes:attributes];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;设置-navigationItem-的左按钮-（非自定义）&quot;&gt;&lt;a href=&quot;#设置-navigationItem-的左按钮-（非自定义）&quot; class=&quot;headerlink&quot; title=&quot;设置 navigationItem 的左按钮 （非自定义）&quot;&gt;&lt;/a&gt;设置 navigationItem 的左按钮 （非自定义）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// 设置navigationItem的左按钮
UIBarButtonItem *leftItem = [[UIBarButtonItem alloc] initWithImage:[UIImage imageNamed:@&amp;quot;btn_common_return&amp;quot;] style:UIBarButtonItemStylePlain target:self action:@selector(leftNavBtnAction)];
leftItem.tintColor = BASECOLOR; //图片的颜色需要单独设置，图片相当于一个蒙版
self.navigationItem.leftBarButtonItem = leftItem;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;在-sb-中设置所有的-UINavigationBar-的统一色调&quot;&gt;&lt;a href=&quot;#在-sb-中设置所有的-UINavigationBar-的统一色调&quot; class=&quot;headerlink&quot; title=&quot;在 sb 中设置所有的 UINavigationBar 的统一色调&quot;&gt;&lt;/a&gt;在 sb 中设置所有的 UINavigationBar 的统一色调&lt;/h3&gt;&lt;p&gt;先在 UINavigationController 的页面点击查看属性显示器（右侧栏第四个）设置 Bar Tint 的颜色，就可以将全部的 bar 设置成同一个颜色，然后如果要想bar 的按钮也跟bar 同一颜色的话，还需要将其的 Background 设置成 Clear Color ，这样在子页面的按钮上设置 Clear Color 才会看到跟 bar 上的同一颜色。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果要想设置 UInavigationBar 上的 UIView 控件，需要在 wAny hAny 模式下将 UIView 放在右上角的位置，其他模式将不能正常显示 UIView 的大小与位置。&lt;/em&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用-ScrollView-进行自动布局&quot;&gt;&lt;a href=&quot;#使用-ScrollView-进行自动布局&quot; class=&quot;headerlink&quot; title=&quot;使用 ScrollView 进行自动布局&quot;&gt;&lt;/a&gt;使用 ScrollView 进行自动布局&lt;/h3&gt;&lt;p&gt; 解决方案：可以在 ScrollView 上添加一个唯一的子视图，大小和 ScrollView 一样，然后所有原来计划添加到 ScrollView 上的控件，都添加到子视图上面。&lt;br&gt;
    
    </summary>
    
    
      <category term="sb" scheme="http://yoursite.com/tags/sb/"/>
    
  </entry>
  
  <entry>
    <title>CTStringAttributes 扩展属性</title>
    <link href="http://yoursite.com/2016/03/27/CTStringAttributes-%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/03/27/CTStringAttributes-扩展属性/</id>
    <published>2016-03-27T02:36:45.000Z</published>
    <updated>2016-03-27T02:42:51.000Z</updated>
    
    <content type="html">&lt;p&gt;Core Text 框架是处理文本内容的一个专门框架，在这个框架里面定义和约束了所有的文本字体和字形相关的属性定义。在 CTStringAttributes 这个头文件里面定义了&lt;strong&gt;21&lt;/strong&gt;种扩展属性，分别对字体和字形的属性方面进行了详细的定义。&lt;/p&gt;
 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KCTFontAttributeName ：设置字体属性 （大小和字体）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTForegroundColorFromContextAttributeName ：从上下文中获取前景色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTKernAttributeName ： 字符间距&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTLigatureAttributeName ：控制连体字的信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTForegroundColorAttributeName ： 前景色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTParagraphStyleAttributeName ： 段落样式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KCTStrokeWidthAttributeName ：描边的宽度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTStrokeColorAttributeName ： 描边的颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTUnderlineStyleAttributeName : 下划线样式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTSuperscriptAttributeName ： 临时脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTUnderlineColorAttributeName ：下划线颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTVerticalFormsAttributeName ：控制字形方向&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KCTGlyphInfoAttributeName ： 使用未编码的字形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTCharacterShapeAttributeName ： 控制字形的选择&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTLanguageAttributeName ：指定文本的语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTRunDelegateAttributeName ：控制部分文字的外观&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTBaselineClassAttributeName ：引用重写基线的类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTBaselineInfoAttributeName ： 引用基线信息的属性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;KCTBaselineReferenceInfoAttributeName ：关键参考基线信息字典的参考标准&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTWritingDirectionAttributeName ：指定一个双向覆盖或者嵌入 （设置书写方向）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;KCTRubyAnnotationAttributeName ： 引用一个 CTRubyAnnotation 的关键&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Core Text 框架是处理文本内容的一个专门框架，在这个框架里面定义和约束了所有的文本字体和字形相关的属性定义。在 CTStringAttributes 这个头文件里面定义了&lt;strong&gt;21&lt;/strong&gt;种扩展属性，分别对字体和字形的属性方面进行了详细的定义。&lt;/p&gt;
    
    </summary>
    
    
      <category term="［coreText］" scheme="http://yoursite.com/tags/%EF%BC%BBcoreText%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title> 日期类的使用2</title>
    <link href="http://yoursite.com/2016/03/20/%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A82/"/>
    <id>http://yoursite.com/2016/03/20/日期类的使用2/</id>
    <published>2016-03-20T05:59:29.000Z</published>
    <updated>2016-03-20T06:09:55.000Z</updated>
    
    <content type="html">&lt;p&gt;接上一篇：&lt;a href=&quot;/2016/03/20/日期类的使用NSDate/&quot;&gt;日期类的使用NSDate&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;NSDateFormatter-的使用&quot;&gt;&lt;a href=&quot;#NSDateFormatter-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSDateFormatter 的使用&quot;&gt;&lt;/a&gt;NSDateFormatter 的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];

[dateFormatter setDateFormat:@&amp;quot;&amp;apos;公元前/后:&amp;apos;G  &amp;apos;年份:&amp;apos;u&amp;apos;=&amp;apos;yyyy&amp;apos;=&amp;apos;yy &amp;apos;季度:&amp;apos;q&amp;apos;=&amp;apos;qqq&amp;apos;=&amp;apos;qqqq &amp;apos;月份:&amp;apos;M&amp;apos;=&amp;apos;MMM&amp;apos;=&amp;apos;MMMM &amp;apos;今天是今年第几周:&amp;apos;w &amp;apos;今天是本月第几周:&amp;apos;W  &amp;apos;
今天是今天第几天:&amp;apos;D &amp;apos;今天是本月第几天:&amp;apos;d &amp;apos;星期:&amp;apos;c&amp;apos;=&amp;apos;ccc&amp;apos;=&amp;apos;cccc &amp;apos;上午/下午:&amp;apos;a &amp;apos;小时:&amp;apos;h&amp;apos;=&amp;apos;H &amp;apos;分钟:&amp;apos;m &amp;apos;秒:&amp;apos;s &amp;apos;毫秒:&amp;apos;SSS  &amp;apos;这一天已过多少毫秒:&amp;apos;A  &amp;apos;时区名称:&amp;apos;zzzz&amp;apos;=&amp;apos;vvvv &amp;apos;时区编号:&amp;apos;Z &amp;quot;];

 NSLog(@&amp;quot;%@&amp;quot;, [dateFormatter stringFromDate:[NSDate date]]);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;NSTimeZone-的使用&quot;&gt;&lt;a href=&quot;#NSTimeZone-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSTimeZone 的使用&quot;&gt;&lt;/a&gt;NSTimeZone 的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//系统时区
NSTimeZone *zone = [NSTimeZone systemTimeZone];
NSTimeZone *zone = [NSTimeZone defaultTimeZone];
NSTimeZone *localTime = [NSTimeZone localTimeZone];

NSData *data = [zone data];//转化成 二进制数据

NSString *addStr = [zone abbreviation];//获取时区的简写

NSInteger timeoff = [zone secondsFromGMT];   //获取时区的偏移量

NSDate *timeOffDate = [date dateByAddingTimeInterval:timeoff]; //附加时间

NSArray *zoneArrs = [NSTimeZone knownTimeZoneNames];    //获取时区的对应表
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇：&lt;a href=&quot;/2016/03/20/日期类的使用NSDate/&quot;&gt;日期类的使用NSDate&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;NSDateFormatter-的使用&quot;&gt;&lt;a href=&quot;#NSDateFormatter-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSDateFormatter 的使用&quot;&gt;&lt;/a&gt;NSDateFormatter 的使用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDateFormatter *dateFormatter = [[NSDateFormatter alloc]init];

[dateFormatter setDateFormat:@&amp;quot;&amp;apos;公元前/后:&amp;apos;G  &amp;apos;年份:&amp;apos;u&amp;apos;=&amp;apos;yyyy&amp;apos;=&amp;apos;yy &amp;apos;季度:&amp;apos;q&amp;apos;=&amp;apos;qqq&amp;apos;=&amp;apos;qqqq &amp;apos;月份:&amp;apos;M&amp;apos;=&amp;apos;MMM&amp;apos;=&amp;apos;MMMM &amp;apos;今天是今年第几周:&amp;apos;w &amp;apos;今天是本月第几周:&amp;apos;W  &amp;apos;
今天是今天第几天:&amp;apos;D &amp;apos;今天是本月第几天:&amp;apos;d &amp;apos;星期:&amp;apos;c&amp;apos;=&amp;apos;ccc&amp;apos;=&amp;apos;cccc &amp;apos;上午/下午:&amp;apos;a &amp;apos;小时:&amp;apos;h&amp;apos;=&amp;apos;H &amp;apos;分钟:&amp;apos;m &amp;apos;秒:&amp;apos;s &amp;apos;毫秒:&amp;apos;SSS  &amp;apos;这一天已过多少毫秒:&amp;apos;A  &amp;apos;时区名称:&amp;apos;zzzz&amp;apos;=&amp;apos;vvvv &amp;apos;时区编号:&amp;apos;Z &amp;quot;];

 NSLog(@&amp;quot;%@&amp;quot;, [dateFormatter stringFromDate:[NSDate date]]);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="日期，时间" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%9F%EF%BC%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>日期类的使用NSDate</title>
    <link href="http://yoursite.com/2016/03/20/%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8NSDate/"/>
    <id>http://yoursite.com/2016/03/20/日期类的使用NSDate/</id>
    <published>2016-03-20T05:24:56.000Z</published>
    <updated>2016-03-20T06:08:29.000Z</updated>
    
    <content type="html">&lt;p&gt;日期类在需要记录时间的地方发挥着巨大的作用，也可以实时地获取程序使用的时间。配合 NSLocal ，NSDateFormatter 和 NSTimeZone 这几个类就可以涵盖所有的程序使用的时间日期的数据。&lt;br&gt;&lt;img src=&quot;/img/date.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初始化一个 NSDate 类可以使用工厂方法和实例方法：&lt;/p&gt;
&lt;h4 id=&quot;工厂方法&quot;&gt;&lt;a href=&quot;#工厂方法&quot; class=&quot;headerlink&quot; title=&quot;工厂方法&quot;&gt;&lt;/a&gt;工厂方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDate *time = [NSDate date]; //返回当前时间
NSDate *time = [NSDate dateWithTimeIntervalSinceNow:0.0]; //返回以当前时间为基准，然后过了secs秒的时间
NSDate *time = [NSDate dateWithTimeIntervalSince1970:100.0]; //返回以1970/01/01 GMT为基准，然后过了secs秒的时间
NSDate *time = [NSDate dateWithTimeIntervalSinceReferenceDate:100.0]; //返回以2001/01/01 GMT为基准，然后过了secs秒的时间
NSDate *time = [NSDate dateWithTimeInterval:100.0 sinceDate:time2]; //返回从某个时间之后过了多少秒
NSDate *time = [NSDate distantFuture];  //返回很多年以后的未来的某一天。
NSDate *time = [NSDate distantPast];    //返回很多年以前的某一天
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;实例方法&quot;&gt;&lt;a href=&quot;#实例方法&quot; class=&quot;headerlink&quot; title=&quot;实例方法&quot;&gt;&lt;/a&gt;实例方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSDate *time = [[NSDate alloc] init]; //返回当前时间
NSDate *time = [[NSDate alloc] initWithTimeInterval:1000.0 sinceDate:time2]; //返回从某个时间之后过了多少秒
NSDate *time = [[NSDate alloc] initWithTimeIntervalSince1970:1000000000.0]; //返回以1970/01/01 GMT为基准，然后过了secs秒的时间
NSDate *time = [[NSDate alloc] initWithTimeIntervalSinceNow:100.0]; //返回以当前时间为基准，然后过了secs秒的时间
NSDate *time = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:1000000.0]; //返回以2001/01/01 GMT为基准，然后过了secs秒的时间
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;日期间的比较-获取两个时间的间隔&quot;&gt;&lt;a href=&quot;#日期间的比较-获取两个时间的间隔&quot; class=&quot;headerlink&quot; title=&quot;日期间的比较 /  获取两个时间的间隔&quot;&gt;&lt;/a&gt;日期间的比较 /  获取两个时间的间隔&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;NSLog(@&amp;quot;%d&amp;quot;, [time isEqualToDate:time2]);  //是否相等
NSLog(@&amp;quot;%@&amp;quot;, [time earlierDate:time2]);    //是否早于
NSLog(@&amp;quot;%@&amp;quot;, [time2 laterDate:time]);      //是否低于
NSLog(@&amp;quot;%ld&amp;quot;, [time2 compare:time]);       //排序时调用，返回 -1，0，1

NSLog(@&amp;quot;%f&amp;quot;, [time timeIntervalSinceDate:time2]); //time2之后与time间的间隔
NSLog(@&amp;quot;%f&amp;quot;, [time timeIntervalSince1970]);    //从1970年之后到time的间隔
NSLog(@&amp;quot;%F&amp;quot;, [time timeIntervalSinceNow]);    //从现在到time之间的时间间隔
NSLog(@&amp;quot;%f&amp;quot;, [time timeIntervalSinceReferenceDate]); //从以1970/01/01 GMT为基准到time的时间间隔
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;时间表示成字符串&quot;&gt;&lt;a href=&quot;#时间表示成字符串&quot; class=&quot;headerlink&quot; title=&quot;时间表示成字符串&quot;&gt;&lt;/a&gt;时间表示成字符串&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (NSString *)description; 以YYYY-MM-DD HH:MM:SS ±HHMM的格式表示时间。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSLocale-的用法&quot;&gt;&lt;a href=&quot;#NSLocale-的用法&quot; class=&quot;headerlink&quot; title=&quot;NSLocale 的用法&quot;&gt;&lt;/a&gt;NSLocale 的用法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSLocale *usLocale = [[NSLocale alloc] initWithLocaleIdentifier&amp;quot;en_US&amp;quot;]; // 根据本地标识符创建本地化对象

[NSLocale availableLocaleIdentifiers]; // 获取系统所有本地化标识符数组列表  

[[NSLocale currentLocale] localeIdentifier]; //获取当前系统设置语言的标识符

[NSLocale lineDirectionForLanguage:[[NSLocale currentLocale] objectForKey:NSLocaleLanguageCode]; //获取当前语言的排版方向和字符方向

[NSLocale preferredLanguages]; //获取用户的语言偏好设置列表 

[NSNotificationCenter defaultCenter] addObserver:self selector@selector(localChangedHandler)  name:NSCurrentLocaleDidChangeNotification object:nil];  // 监听用户本地化设置的消息

NSLocale *curLocal = [[NSLocale alloc]initWithLocaleIdentifier&amp;quot;zh-Hans&amp;quot;]; // 以本地化方式获取国际化信息的显示名称


// 设置固定的系统返回 语言数据
NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&amp;quot;zh&amp;quot;];
NSDateFormatter *secondDateFormatter = [[NSDateFormatter alloc] init];
[secondDateFormatter setDateFormat:@&amp;quot;cccc&amp;quot;];  
secondDateFormatter.locale = locale;
NSDate *date = [NSDate date];
NSLog(@&amp;quot;%@&amp;quot;, [secondDateFormatter stringFromDate:date]);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;日期类在需要记录时间的地方发挥着巨大的作用，也可以实时地获取程序使用的时间。配合 NSLocal ，NSDateFormatter 和 NSTimeZone 这几个类就可以涵盖所有的程序使用的时间日期的数据。&lt;br&gt;&lt;img src=&quot;/img/date.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="日期，时间" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%9F%EF%BC%8C%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>NSData 的使用</title>
    <link href="http://yoursite.com/2016/03/17/NSData-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/17/NSData-的使用/</id>
    <published>2016-03-17T14:01:55.000Z</published>
    <updated>2016-03-17T14:14:33.000Z</updated>
    
    <content type="html">&lt;p&gt;应该说在任何网络中，如何使用数据来传递信息，保存和读取信息，并将其变为可以产生价值的东西，而在计算机的世界里面除了0 和 1 ，我们眼中所见的东西在计算机眼里只不过是一堆 0 和 1 数据而已。那么在 iOS 里，又是如何进行数据间的转化的。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;初始化-NSData-类型的对象&quot;&gt;&lt;a href=&quot;#初始化-NSData-类型的对象&quot; class=&quot;headerlink&quot; title=&quot;初始化 NSData 类型的对象&quot;&gt;&lt;/a&gt;初始化 NSData 类型的对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//定义一个char类型的字符串  
const char * string = &amp;quot;Hi there ,this is a C string&amp;quot;; 

//建立缓冲区，把字符串添加进去  
NSData * data = [NSData dataWithBytes:string length:strlen(string)+1]; 

//获取APP根目录的方法
NSHomeDirectory()；

//返回 data 的数据长度
NSLog(@&amp;quot;%ld&amp;quot;, reader.length);


//返回data对象的首指针
NSLog(@&amp;quot;%s&amp;quot;, reader.bytes);


//获取data格式的数据
NSLog(@&amp;quot;%@&amp;quot;, reader.description);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSString-类型的数据与-NSData-类型之间的转化&quot;&gt;&lt;a href=&quot;#NSString-类型的数据与-NSData-类型之间的转化&quot; class=&quot;headerlink&quot; title=&quot;NSString 类型的数据与 NSData 类型之间的转化&quot;&gt;&lt;/a&gt;NSString 类型的数据与 NSData 类型之间的转化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSString * str = @&amp;quot;hello, world!&amp;quot;;
NSData * data = [str dataUsingEncoding:NSUTF8StringEncoding]; //NSString转换成NSData类型
NSString * newStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSData-与-UIImage&quot;&gt;&lt;a href=&quot;#NSData-与-UIImage&quot; class=&quot;headerlink&quot; title=&quot;NSData 与 UIImage&quot;&gt;&lt;/a&gt;NSData 与 UIImage&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//例：从本地文件沙盒中取图片并转换为NSData

NSString *path = [[NSBundle mainBundle] bundlePath];
NSString *name = [NSString stringWithFormat:@&amp;quot;ceshi.png&amp;quot;];
NSString *finalPath = [path stringByAppendingPathComponent:name];
NSData *imageData = [NSData dataWithContentsOfFile: finalPath];
UIImage *aimage = [UIImage imageWithData: imageData];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;base-64-编码解码&quot;&gt;&lt;a href=&quot;#base-64-编码解码&quot; class=&quot;headerlink&quot; title=&quot;base 64 编码解码&quot;&gt;&lt;/a&gt;base 64 编码解码&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;编码：

NSString * stringExample = [NSString stringWithFormat:@&amp;quot;I Love You&amp;quot;];
NSData * data1 = [stringExample dataUsingEncoding:NSUTF8StringEncoding];
NSString * base64String = [data1 base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn]; 

解码：

NSData * dataFromString = [[NSData alloc] initWithBase64EncodedString:base64String options:NSDataBase64DecodingIgnoreUnknownCharacters];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;文件保存和读取&quot;&gt;&lt;a href=&quot;#文件保存和读取&quot; class=&quot;headerlink&quot; title=&quot;文件保存和读取&quot;&gt;&lt;/a&gt;文件保存和读取&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; //定义一个字符串，保存一个路径  
NSString * path = @&amp;quot;/tmp/ver.txt&amp;quot;; 

//把这个保存路径的字符串保存到另一个文件中  encoding是编码  
[path writeToFile:@&amp;quot;/tmp/string.txt&amp;quot; atomically:YES encoding:NSASCIIStringEncoding error:nil];


//创建文件管理器     
NSFileManager * fm = [NSFileManager defaultManager]; 

//创建缓冲区，利用NSFileManager对象来获取文件中的内容，也就是这个文件的属性可修改  
NSData * fileData = [fm contentsAtPath:@&amp;quot;/tmp/ver.txt&amp;quot;];   

//获取上面fileData对象中通过NSFileManager对象获取的文件中的内容，然后再创建一个新的路径，并存储  
[fm createFileAtPath:@&amp;quot;/tmp/test4.txt&amp;quot; contents:fileData attributes:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;可修改的数据存储器-NSMutableData&quot;&gt;&lt;a href=&quot;#可修改的数据存储器-NSMutableData&quot; class=&quot;headerlink&quot; title=&quot;可修改的数据存储器 NSMutableData&quot;&gt;&lt;/a&gt;可修改的数据存储器 NSMutableData&lt;/h3&gt;&lt;p&gt;   创建的方式： &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *path = @&amp;quot;/Users/Allen/Desktop/test.dat&amp;quot;;
NSString *temp = @&amp;quot;Jarod Yv&amp;quot;;
int i = 100;
float f = 98.3333f; 

NSMutableData *writer = [[NSMutableData alloc] init];

[writer appendData:[temp dataUsingEncoding:NSUTF8StringEncoding]];
[writer appendBytes:&amp;amp;i length:sizeof(i)];
[writer appendBytes:&amp;amp;f length:sizeof(f)];

[writer writeToFile:path atomically:YES]; 

读取：     
int ii; 
float ff;
NSData *reader = [NSData dataWithContentsOfFile:path];

NSString *ttemp = [[NSString alloc] initWithData:[reader subdataWithRange:NSMakeRange(0, [temp length])]encoding:NSUTF8StringEncoding];

[reader getBytes:&amp;amp;ii range:NSMakeRange([temp length], sizeof(ii))];
[reader getBytes:&amp;amp;ff range:NSMakeRange([temp length] + sizeof(ii), sizeof(ff))]; 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;应该说在任何网络中，如何使用数据来传递信息，保存和读取信息，并将其变为可以产生价值的东西，而在计算机的世界里面除了0 和 1 ，我们眼中所见的东西在计算机眼里只不过是一堆 0 和 1 数据而已。那么在 iOS 里，又是如何进行数据间的转化的。
    
    </summary>
    
    
      <category term="［数据］" scheme="http://yoursite.com/tags/%EF%BC%BB%E6%95%B0%E6%8D%AE%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation和NSOperationQueue多线程的使用</title>
    <link href="http://yoursite.com/2016/03/17/NSOperation%E5%92%8CNSOperationQueue%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/17/NSOperation和NSOperationQueue多线程的使用/</id>
    <published>2016-03-17T11:37:41.000Z</published>
    <updated>2016-03-17T12:10:41.000Z</updated>
    
    <content type="html">&lt;p&gt; 最近学习了多线程编程 NSOperationQueue ，才比较清楚的明白了&lt;strong&gt;同步／异步&lt;/strong&gt;，&lt;strong&gt;阻塞／非阻塞&lt;/strong&gt;所表达的不同含义：所谓的同步／异步是对你得到消息的方式的描述，而阻塞／非阻塞则是你怎么样处理事情的做法，他们讲述的是不同层面的概念。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  现在来讲述一下可以实现多线程的三种方式中的 NSOperation 类。使用NSOperation和NSOperationQueue实现多线程编程，实现步骤大致是这样的：&lt;/p&gt;
&lt;p&gt;  1&amp;gt; 先将需要执行的操作封装到一个NSOperation对象中&lt;/p&gt;
&lt;p&gt;  2&amp;gt; 然后将NSOperation对象添加到NSOperationQueue中&lt;/p&gt;
&lt;p&gt;  3&amp;gt; 系统会自动将NSOperation中封装的操作放到一条新线程中执行&lt;/p&gt;
&lt;p&gt;  而由于  NSOperation 是一个抽象类，所以它的功能只能有其子类 NSBlockOperation 和 SInvocationOperation 来实现。&lt;/p&gt;
&lt;h4 id=&quot;NSBlockOperation-的使用&quot;&gt;&lt;a href=&quot;#NSBlockOperation-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSBlockOperation 的使用&quot;&gt;&lt;/a&gt;NSBlockOperation 的使用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt; NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){     
    NSLog(@&amp;quot;*执行第1次操作，线程：%@&amp;quot;, [NSThread currentThread]);       
   }];

[operation addExecutionBlock:^() {

   NSLog(@&amp;quot;**又执行了1个新的操作，线程：%@&amp;quot;, [NSThread currentThread]);

   }];

// 开始执行任务    
[operation start];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   注：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。&lt;/p&gt;
&lt;h4 id=&quot;NSInvocationOperation-的使用&quot;&gt;&lt;a href=&quot;#NSInvocationOperation-的使用&quot; class=&quot;headerlink&quot; title=&quot;NSInvocationOperation 的使用&quot;&gt;&lt;/a&gt;NSInvocationOperation 的使用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ration2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(downLoadImage:) object:URL];
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:operation2];

如果是有刷新界面的操作，那么必须将这个操作交给主线程来完成。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义-NSOperation-类&quot;&gt;&lt;a href=&quot;#自定义-NSOperation-类&quot; class=&quot;headerlink&quot; title=&quot;自定义 NSOperation 类&quot;&gt;&lt;/a&gt;自定义 NSOperation 类&lt;/h3&gt;&lt;p&gt;由于 NSOperation 类功能比较少， 一般情况下我们可以自定义一个 NSOperation 类。要定制这样的一个操作，可以遵循以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承 NSOperation 类&lt;/li&gt;
&lt;li&gt;重写“main”方法&lt;/li&gt;
&lt;li&gt;在“main”方法中创建一个“automaticreleasepool“&lt;/li&gt;
&lt;li&gt;将你的代码放在”autoreleasepool“中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  例子：&lt;br&gt;     &lt;em&gt;*&lt;/em&gt; .h 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;
@interface MyLengthyOperation : NSOperation
@property (nonatomic, strong, readonly) NSString *mark;
- (instancetype)initWithMark:(NSString *)mark;
@end 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;em&gt;*&lt;/em&gt; .m 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#import &amp;quot;MyLengthyOperation.h&amp;quot;
@interface MyLengthyOperation ()
@property (nonatomic, strong, readwrite) NSString *mark;
@end
@implementation MyLengthyOperation
- (instancetype)initWithMark:(NSString *)mark {  
   self = [super init];
   if (self) {      
       self.mark = mark;
    }
   return self;
   }
- (void)main {
    @autoreleasepool {
      for (int i = 0; i &amp;lt; 100; i ++) {
         if (self.isCancelled) {
             break;
         }
         NSLog(@&amp;quot;%@ - %f&amp;quot;, self.mark, sqrt(i));
        }
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//  初始化任务 
MyLengthyOperation *operation_1 = [[MyLengthyOperation alloc] initWithMark:@&amp;quot;operation_1&amp;quot;];
MyLengthyOperation *operation_2 = [[MyLengthyOperation alloc] initWithMark:@&amp;quot;operation_2&amp;quot;];

// 设置任务的优先级
[operation_1 setQueuePriority:NSOperationQueuePriorityVeryLow];
[operation_2 setQueuePriority:NSOperationQueuePriorityHigh];

// 添加从属关系
[operation_2 addDependency:operation_1]; （任务2在任务1结束后才会执行）

// 初始化队列
NSOperationQueue *myQueue = [[NSOperationQueue alloc] init];
myQueue.name = @&amp;quot;下载队列&amp;quot;;

// 将一个简单的任务队列添加进队列中 （使用 Block 回调方式）      
    NSURL *aURL = [NSURL URLWithString:URL];
    NSData *data = [NSData dataWithContentsOfURL:aURL];

    [[NSOperationQueue mainQueue] addOperationWithBlock:^{

        UIImage *image = [[UIImage alloc] initWithData:data];
        [self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES];
    }];
}];

// 设置任务队列的最大并发数
 myQueue.maxConcurrentOperationCount = 4;

// 添加进任务队列中执行
[myQueue addOperation:operation_1];
[myQueue addOperation:operation_2];

// 取消所有操作
[myQueue cancelAllOperations];

// 执行延时的操作（将执行代码放置在 block 中）
- (void)execute:(dispatch_block_t)block afterDelay:(int64_t)delta {

   dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delta), dispatch_get_main_queue(), block);
 }

// 挂起操作
[myQueue setSuspended:YES];

// 取消任务
[operation_1 cancel];

//  任务完成后的回调可以表示任务已经结束
 [operation_1 setCompletionBlock:^{
      NSLog(@&amp;quot;任务1结束&amp;quot;);
  }];
 [operation_2 setCompletionBlock:^{
      NSLog(@&amp;quot;任务2结束&amp;quot;);
 }];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt; 最近学习了多线程编程 NSOperationQueue ，才比较清楚的明白了&lt;strong&gt;同步／异步&lt;/strong&gt;，&lt;strong&gt;阻塞／非阻塞&lt;/strong&gt;所表达的不同含义：所谓的同步／异步是对你得到消息的方式的描述，而阻塞／非阻塞则是你怎么样处理事情的做法，他们讲述的是不同层面的概念。
    
    </summary>
    
    
      <category term="［博客］" scheme="http://yoursite.com/tags/%EF%BC%BB%E5%8D%9A%E5%AE%A2%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>NSURLConnection 基本使用</title>
    <link href="http://yoursite.com/2016/03/15/NSURLConnection-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/03/15/NSURLConnection-基本使用/</id>
    <published>2016-03-15T13:38:59.000Z</published>
    <updated>2016-03-31T12:09:29.000Z</updated>
    
    <content type="html">&lt;p&gt;现如今大部分的网络请求都是使用 NSURLConnection 这个类来完成，那么了解这个类对网络数据请求来说就至关重要的。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;NSURLConnection-的常用类&quot;&gt;&lt;a href=&quot;#NSURLConnection-的常用类&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection 的常用类&quot;&gt;&lt;/a&gt;NSURLConnection 的常用类&lt;/h3&gt;&lt;p&gt;· NSURL ：请求地址&lt;/p&gt;
&lt;p&gt;· NSURLRequest ：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体….&lt;/p&gt;
&lt;p&gt;· NSMutableRequest ：NSURLRequest 的子类&lt;/p&gt;
&lt;p&gt;· NSURLConnection：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据&lt;/p&gt;
&lt;h3 id=&quot;NSURLConnection的使用&quot;&gt;&lt;a href=&quot;#NSURLConnection的使用&quot; class=&quot;headerlink&quot; title=&quot;NSURLConnection的使用&quot;&gt;&lt;/a&gt;NSURLConnection的使用&lt;/h3&gt;&lt;p&gt;使用 NSURLConnection 这个类的步骤主要有三个：&lt;/p&gt;
&lt;p&gt;1）创建一个NSURL对象，设置请求路径（设置请求路径）&lt;/p&gt;
&lt;p&gt;2）传入NSURL创建一个NSURLRequest对象，设置请求头和请求体（创建请求对象）&lt;/p&gt;
&lt;p&gt;3）使用NSURLConnection发送NSURLRequest（发送请求）&lt;/p&gt;
&lt;p&gt;在请求数据的过程中根据连接服务器的方式分为&lt;strong&gt;同步请求&lt;/strong&gt;和&lt;strong&gt;异步请求&lt;/strong&gt;这两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;NSData *data=[NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil];&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;异步请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;－ 使用 block 回调&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSOperationQueue *queue=[NSOperationQueue mainQueue];
[NSURLConnection sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) { }];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;－ 代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSURLConnection *conn=[NSURLConnection connectionWithRequest:request delegate:self];
[conn start];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在NSURLConnectionDataDelegate代理方法里面执行事件。&lt;/p&gt;
&lt;h3 id=&quot;NSMutableURLRequest-的妙用&quot;&gt;&lt;a href=&quot;#NSMutableURLRequest-的妙用&quot; class=&quot;headerlink&quot; title=&quot;NSMutableURLRequest 的妙用&quot;&gt;&lt;/a&gt;NSMutableURLRequest 的妙用&lt;/h3&gt;&lt;p&gt;NSMutableURLRequest是NSURLRequest的子类，常用方法有&lt;/p&gt;
&lt;p&gt;－ 设置请求超时等待时间（超过这个时间就算超时，请求失败）- (void)setTimeoutInterval:(NSTimeInterval)seconds;&lt;br&gt;－ 设置请求方法（比如GET和POST）- (void)setHTTPMethod:(NSString &lt;em&gt;)method;&lt;br&gt;－ 设置请求体 - (void)setHTTPBody:(NSData &lt;/em&gt;)data;&lt;br&gt;－ 设置请求头 - (void)setValue:(NSString &lt;em&gt;)value forHTTPHeaderField:(NSString &lt;/em&gt;)field;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;现如今大部分的网络请求都是使用 NSURLConnection 这个类来完成，那么了解这个类对网络数据请求来说就至关重要的。&lt;br&gt;
    
    </summary>
    
    
      <category term="［数据请求］" scheme="http://yoursite.com/tags/%EF%BC%BB%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%EF%BC%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS 之网络数据请求</title>
    <link href="http://yoursite.com/2016/03/15/iOS-%E4%B9%8B%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2016/03/15/iOS-之网络数据请求/</id>
    <published>2016-03-15T13:25:35.000Z</published>
    <updated>2016-03-15T13:36:49.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 网络请求主要使用了 HTTP 和 HTTPS 协议。现在主要记录 HTTP 的网络请求方式。那么在讨论网络数据请求之前就必须先了解清楚：HTTP 请求报文和 HTTP 响应报文。 &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;HTTP-请求报文&quot;&gt;&lt;a href=&quot;#HTTP-请求报文&quot; class=&quot;headerlink&quot; title=&quot;HTTP 请求报文&quot;&gt;&lt;/a&gt;HTTP 请求报文&lt;/h3&gt;&lt;p&gt;一个HTTP请求报文由请求行（request line）,请求头部（head）,空行（blank line）和请求数据（request-body）4个部分组成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＜request-line＞
＜headers＞
＜blank line＞
[＜request-body＞
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;请求行&quot;&gt;&lt;a href=&quot;#请求行&quot; class=&quot;headerlink&quot; title=&quot;请求行&quot;&gt;&lt;/a&gt;请求行&lt;/h4&gt;&lt;p&gt;由请求方法字段，URL字段和HTTP协议版本字段 3个字段组成，用空格分隔&lt;/p&gt;
&lt;p&gt;HTTP 协议的请求方法有：GET，POST，HEAD，PUT，DELETE，OPTIONS，TRACE，CONNECT&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;GET ：最常见的一种请求方式，方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;POST ：将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。请求行中不包含数据字符串，这些数据保存在”请求内容”部分，各数据之间也是使用”&amp;amp;”符号隔开。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HEAD：像GET，只不过服务端接受到HEAD请求后只返回响应行，而不会发送响应内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;请求头部&quot;&gt;&lt;a href=&quot;#请求头部&quot; class=&quot;headerlink&quot; title=&quot;请求头部&quot;&gt;&lt;/a&gt;请求头部&lt;/h4&gt;&lt;p&gt;请求头部由键/值对组成，每行一对，键和值用英文冒号“:”分隔&lt;/p&gt;
&lt;p&gt;请求头部通知服务器有关于客户端请求的信息，典型的请求头有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User-Agent：产生请求的客户端类型。

Accept：客户端可识别的内容类型列表。

Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。

Referer：参考者

Accept-Language: 客户端可识别的语言

Accept-Encoding: 客户端可识别的编码方式

Connection: 链接方式

Cookie:

Content-Length: 数据的长度

Content-Type: 数据的类型

Date: 时间 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;空行&quot;&gt;&lt;a href=&quot;#空行&quot; class=&quot;headerlink&quot; title=&quot;空行&quot;&gt;&lt;/a&gt;空行&lt;/h4&gt;&lt;p&gt;最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。&lt;/p&gt;
&lt;h4 id=&quot;请求数据&quot;&gt;&lt;a href=&quot;#请求数据&quot; class=&quot;headerlink&quot; title=&quot;请求数据&quot;&gt;&lt;/a&gt;请求数据&lt;/h4&gt;&lt;p&gt;请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。&lt;/p&gt;
&lt;h3 id=&quot;TTP-响应报文&quot;&gt;&lt;a href=&quot;#TTP-响应报文&quot; class=&quot;headerlink&quot; title=&quot;TTP 响应报文&quot;&gt;&lt;/a&gt;TTP 响应报文&lt;/h3&gt;&lt;p&gt;HTTP响应也由四个部分组成，分别是：状态行、响应头、空格、响应数据&lt;/p&gt;
&lt;p&gt;如下所示，HTTP响应的格式与请求的格式十分类似：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＜status-line＞
＜headers＞
＜blank line＞
[＜response-body＞]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;状态行（status line）通过提供一个状态码来说明所请求的资源情况。&lt;/p&gt;
&lt;p&gt;状态行格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP-Version Status-Code Reason-Phrase CRLF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code 表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。&lt;/p&gt;
&lt;p&gt;  • 1xx：指示信息–表示请求已接收，继续处理。&lt;br&gt;  • 2xx：成功–表示请求已被成功接收、理解、接受。&lt;br&gt;  • 3xx：重定向–要完成请求必须进行更进一步的操作。&lt;br&gt;  • 4xx：客户端错误–请求有语法错误或请求无法实现。&lt;br&gt;  • 5xx：服务器端错误–服务器未能实现合法的请求。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 网络请求主要使用了 HTTP 和 HTTPS 协议。现在主要记录 HTTP 的网络请求方式。那么在讨论网络数据请求之前就必须先了解清楚：HTTP 请求报文和 HTTP 响应报文。
    
    </summary>
    
    
      <category term="［http 报文］" scheme="http://yoursite.com/tags/%EF%BC%BBhttp-%E6%8A%A5%E6%96%87%EF%BC%BD/"/>
    
  </entry>
  
</feed>
