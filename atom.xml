<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-18T11:47:40.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UICollectionView - 使用二</title>
    <link href="http://yoursite.com/2016/12/18/UICollectionView-%E4%BD%BF%E7%94%A8%E4%BA%8C/"/>
    <id>http://yoursite.com/2016/12/18/UICollectionView-使用二/</id>
    <published>2016-12-18T11:43:22.000Z</published>
    <updated>2016-12-18T11:47:40.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;UICollectionViewLayout&quot;&gt;&lt;a href=&quot;#UICollectionViewLayout&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewLayout&quot;&gt;&lt;/a&gt;UICollectionViewLayout&lt;/h3&gt;&lt;p&gt;终于到UICollectionView的精髓了…这也是UICollectionView和UITableView最大的不同。&lt;br&gt;UICollectionViewLayout可以说是UICollectionView的大脑和中枢，它负责了将各个cell、Supplementary View和Decoration Views进行组织，为它们设定各自的属性，包括但不限于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    位置
    尺寸
    透明度
    层级关系
    形状
    等等等等…

Layout决定了UICollectionView是如何显示在界面上的。
在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UICollectionViewFlowLayout&quot;&gt;&lt;a href=&quot;#UICollectionViewFlowLayout&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewFlowLayout&quot;&gt;&lt;/a&gt;UICollectionViewFlowLayout&lt;/h3&gt;&lt;p&gt;Apple为我们提供了一个最简单可能也是最常用的默认layout对象，￼￼￼UICollectionViewFlowLayout。&lt;br&gt;Flow Layout简单说是一个直线对齐的layout，最常见的Grid View形式即为一种Flow Layout配置。上面的照片架界面就是一个典型的Flow Layout。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 首先一个重要的属性是itemSize，它定义了每一个item的大小。通过设定itemSize可以全局地改变所有cell的尺寸，如果想要对某个cell制定尺寸，可以使用
     -collectionView:layout:sizeForItemAtIndexPath:方法。

间隔 可以指定item之间的间隔和每一行之间的间隔，和size类似，有全局属性，也可以对每一个item和每一个section做出设定：

    @property (CGSize) minimumInteritemSpacing
    @property (CGSize) minimumLineSpacing
    -collectionView:layout:minimumInteritemSpacingForSectionAtIndex:
    -collectionView:layout:minimumLineSpacingForSectionAtIndex:

滚动方向 由属性scrollDirection确定scroll view的方向，将影响Flow Layout的基本方向和由header及footer确定的section之间的宽度

    UICollectionViewScrollDirectionVertical
    UICollectionViewScrollDirectionHorizontal

Header和Footer尺寸 同样地分为全局和部分。需要注意根据滚动方向不同，header和footer的高和宽中只有一个会起作用。
垂直滚动时section间宽度为该尺寸的高，而水平滚动时为宽度起作用。

    @property (CGSize) headerReferenceSize
    @property (CGSize) footerReferenceSize
    -collectionView:layout:referenceSizeForHeaderInSection:
    -collectionView:layout:referenceSizeForFooterInSection:
缩进

    @property UIEdgeInsets sectionInset;
    -collectionView:layout:insetForSectionAtIndex:

总结
    一个UICollectionView的实现包括两个必要部分：UICollectionViewDataSource和UICollectionViewLayout，和一个交互部分：
    UICollectionViewDelegate。而Apple给出的UICollectionViewFlowLayout已经是一个很强力的layout方案了。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;UICollectionViewLayoutAttributes&quot;&gt;&lt;a href=&quot;#UICollectionViewLayoutAttributes&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewLayoutAttributes&quot;&gt;&lt;/a&gt;UICollectionViewLayoutAttributes&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; UICollectionViewLayoutAttributes是一个非常重要的类，先来看看property列表：

     @property (nonatomic) CGRect frame
     @property (nonatomic) CGPoint center
     @property (nonatomic) CGSize size
     @property (nonatomic) CATransform3D transform3D
     @property (nonatomic) CGFloat alpha
     @property (nonatomic) NSInteger zIndex
     @property (nonatomic, getter=isHidden) BOOL hidden

可以看到，UICollectionViewLayoutAttributes的实例中包含了诸如边框，中心点，大小，形状，透明度，层次关系和是否隐藏等信息。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义的UICollectionViewLayout&quot;&gt;&lt;a href=&quot;#自定义的UICollectionViewLayout&quot; class=&quot;headerlink&quot; title=&quot;自定义的UICollectionViewLayout&quot;&gt;&lt;/a&gt;自定义的UICollectionViewLayout&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;UICollectionViewLayout的功能为向UICollectionView提供布局信息，不仅包括cell的布局信息，也包括追加视图和装饰视图的布局信息。
实现一个自定义layout的常规做法是继承UICollectionViewLayout类，然后重载下列方法：


  - (CGSize)collectionViewContentSize    返回collectionView的内容的尺寸

  -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect

    返回rect中的所有的元素的布局属性
    返回的是包含 UICollectionViewLayoutAttributes的NSArray
    UICollectionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，
    通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollectionViewLayoutAttributes：

        layoutAttributesForItemAtIndexPath:
        layoutAttributesForSupplementaryViewOfKind:withIndexPath:
        layoutAttributesForDecorationViewOfKind:withIndexPath:

 -(UICollectionViewLayoutAttributes _)layoutAttributesForItemAtIndexPath:(NSIndexPath _)indexPath

     返回对应于indexPath的位置的cell的布局属性

 -(UICollectionViewLayoutAttributes _)layoutAttributesForSupplementaryViewOfKind:(NSString _)kind atIndexPath:(NSIndexPath *)indexPath

     回对应于indexPath的位置的追加视图的布局属性，如果没有追加视图可不重载

 -(UICollectionViewLayoutAttributes * )layoutAttributesForDecorationViewOfKind:(NSString_)decorationViewKind atIndexPath:(NSIndexPath _)indexPath

     返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载

 -(BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds

    当边界发生改变时，是否应该刷新布局。如果YES则在边界变化（一般是scroll到其他地方）时，将重新计算需要的布局信息。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;另外需要了解的是&lt;/strong&gt;，在初始化一个UICollectionViewLayout实例后，会有一系列准备方法被自动调用，以保证layout实例的正确。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;首先，-(void)prepareLayout将被调用，默认下该方法什么没做，但是在自己的子类实现中，一般在该方法中设定一些必要的layout的结构和初始需要的参数等。

之后，-(CGSize) collectionViewContentSize将被调用，以确定collection应该占据的尺寸。注意这里的尺寸不是指可视部分的尺寸，
而应该是所有内容所占的尺寸。collectionView的本质是一个scrollView，因此需要这个尺寸来配置滚动行为。

接下来-(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect被调用，这个没什么值得多说的。初始的layout的外观将由该方法返回的UICollectionViewLayoutAttributes来决定。

另外，在需要更新layout时，需要给当前layout发送 -invalidateLayout，该消息会立即返回，并且预约在下一个loop的时候刷新当前layout，这一点和UIView的setNeedsLayout方法十分类似。
在-invalidateLayout后的下一个collectionView的刷新loop中，又会从prepareLayout开始，依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;UICollectionViewLayout&quot;&gt;&lt;a href=&quot;#UICollectionViewLayout&quot; class=&quot;headerlink&quot; title=&quot;UICollectionViewLayout&quot;&gt;&lt;/a&gt;UICollectionViewLayout&lt;/h3&gt;&lt;p&gt;终于到UICollectionView的精髓了…这也是UICollectionView和UITableView最大的不同。&lt;br&gt;UICollectionViewLayout可以说是UICollectionView的大脑和中枢，它负责了将各个cell、Supplementary View和Decoration Views进行组织，为它们设定各自的属性，包括但不限于：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    位置
    尺寸
    透明度
    层级关系
    形状
    等等等等…

Layout决定了UICollectionView是如何显示在界面上的。
在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UICollectionView - 使用一</title>
    <link href="http://yoursite.com/2016/12/18/UICollectionView-%E4%BD%BF%E7%94%A8%E4%B8%80/"/>
    <id>http://yoursite.com/2016/12/18/UICollectionView-使用一/</id>
    <published>2016-12-18T11:39:38.000Z</published>
    <updated>2016-12-18T11:41:50.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;什么是UICollectionView&quot;&gt;&lt;a href=&quot;#什么是UICollectionView&quot; class=&quot;headerlink&quot; title=&quot;什么是UICollectionView&quot;&gt;&lt;/a&gt;什么是UICollectionView&lt;/h3&gt;&lt;p&gt;UICollectionView是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView(请一定注意这是UICollectionView的最最简单的形式)。&lt;/p&gt;
&lt;p&gt;最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。标准的UICollectionView包含三个部分，它们都是UIView的子类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊  Cells 用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容 
＊  Supplementary Views 追加视图 如果你对UITableView比较熟悉的话，可以理解为每个Section的Header或者Footer，用来标记每个section的view
＊  Decoration Views 装饰视图 这是每个section的背景，
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;实现一个简单的UICollectionView&quot;&gt;&lt;a href=&quot;#实现一个简单的UICollectionView&quot; class=&quot;headerlink&quot; title=&quot;实现一个简单的UICollectionView&quot;&gt;&lt;/a&gt;实现一个简单的UICollectionView&lt;/h3&gt;&lt;p&gt;实现一个UICollectionView和实现一个UITableView基本没有什么大区别，它们都同样是datasource和delegate设计模式的：datasource为view提供数据源，告诉view要显示些什么东西以及如何显示它们，delegate提供一些样式的小细节以及用户交互的相应。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊ UICollectionViewDataSource

        section的数量  ￼-numberOfSectionsInCollection:
        某个section里有多少个item ￼ -collectionView:numberOfItemsInSection:
        对于某个位置应该显示什么样的cell ￼ -collectionView:cellForItemAtIndexPath:

  实现以上三个委托方法，基本上就可以保证CollectionView工作正常了。 当然，还有提供Supplementary View的方法

     collectionView:viewForSupplementaryElementOfKind:atIndexPath:

   对于Decoration Views，提供方法并不在UICollectionViewDataSource中，而是直接UICollectionViewLayout类中的(因为它仅仅是视图相关，而与数据无关)


＊ UICollectionViewDelegate

    数据无关的view的外形啊，用户交互啊什么的，由UICollectionViewDelegate来负责：

        cell的高亮
        cell的选中状态
        可以支持长按后的菜单

    关于用户交互，UICollectionView也做了改进。每个cell现在有独立的高亮事件和选中事件的delegate，用户点击cell的时候，现在会按照以下流程向delegate进行询问：

        -￼collectionView:shouldHighlightItemAtIndexPath: 是否应该高亮？
        -￼collectionView:didHighlightItemAtIndexPath: 如果1回答为是，那么高亮
        -￼collectionView:shouldSelectItemAtIndexPath: 无论1结果如何，都询问是否可以被选中？
        -collectionView:didUnhighlightItemAtIndexPath: 如果1回答为是，那么现在取消高亮
        -collectionView:didSelectItemAtIndexPath: 如果3回答为是，那么选中cell

    状态控制要比以前灵活一些，对应的高亮和选中状态分别由highlighted和selected两个属性表示。  


＊ 关于Cell

    相对于UITableViewCell来说，UICollectionViewCell没有这么多花头。首先UICollectionViewCell不存在各式各样的默认的style，这主要是由于展示对象的性质决定的，因为UICollectionView所用来展示的对象相比UITableView来说要来得灵活，大部分情况下更偏向于图像而非文字，因此需求将会千奇百怪。因此SDK提供给我们的默认的UICollectionViewCell结构上相对比较简单，由下至上：

        首先是cell本身作为容器view
        然后是一个大小自动适应整个cell的backgroundView，用作cell平时的背景
        再其上是selectedBackgroundView，是cell被选中时的背景
        最后是一个contentView，自定义内容应被加在这个view上
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这次Apple给我们带来的好康是被选中cell的自动变化，所有的cell中的子view，也包括contentView中的子view，在当cell被选中时，会自动去查找view是否有被选中状态下的改变。比如在contentView里加了一个normal和selected指定了不同图片的imageView，那么选中这个cell的同时这张图片也会从normal变成selected，而不需要额外的任何代码。&lt;/p&gt;
&lt;p&gt;文章后面有两个水平比较高的例子 － &lt;a href=&quot;https://onevcat.com/2012/08/advanced-collection-view&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://onevcat.com/2012/08/advanced-collection-view&lt;/a&gt; 和 &lt;a href=&quot;https://objccn.io/issue-12-5/）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://objccn.io/issue-12-5/）&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是UICollectionView&quot;&gt;&lt;a href=&quot;#什么是UICollectionView&quot; class=&quot;headerlink&quot; title=&quot;什么是UICollectionView&quot;&gt;&lt;/a&gt;什么是UICollectionView&lt;/h3&gt;&lt;p&gt;UICollectionView是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView(请一定注意这是UICollectionView的最最简单的形式)。&lt;/p&gt;
&lt;p&gt;最简单的UICollectionView就是一个GridView，可以以多列的方式将数据进行展示。标准的UICollectionView包含三个部分，它们都是UIView的子类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＊  Cells 用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容 
＊  Supplementary Views 追加视图 如果你对UITableView比较熟悉的话，可以理解为每个Section的Header或者Footer，用来标记每个section的view
＊  Decoration Views 装饰视图 这是每个section的背景，
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发中的几种设计模式介绍</title>
    <link href="http://yoursite.com/2016/12/11/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2016/12/11/iOS开发中的几种设计模式介绍/</id>
    <published>2016-12-11T13:02:50.000Z</published>
    <updated>2016-12-11T13:12:11.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS 开发学习中，经常使用的几种开发模式，现在进行简单的总结和探讨：&lt;/p&gt;
&lt;h4 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h4&gt;&lt;p&gt;应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。&lt;br&gt;优势：解耦合&lt;br&gt;敏捷原则：开放-封闭原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h4&gt;&lt;p&gt;应用场景：一般为对model层，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。&lt;br&gt;优势：解耦合&lt;br&gt;敏捷原则：接口隔离原则，开放-封闭原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。
kvo，键值对改变通知的观察者
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;MVC模式&quot;&gt;&lt;a href=&quot;#MVC模式&quot; class=&quot;headerlink&quot; title=&quot;MVC模式&quot;&gt;&lt;/a&gt;MVC模式&lt;/h4&gt;&lt;p&gt;应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。&lt;br&gt;优势：使系统，层次清晰，职责分明，易于维护&lt;br&gt;敏捷原则：对扩展开放-对修改封闭&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h4&gt;&lt;p&gt;应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。&lt;br&gt;优势：使用简单，延时求值，易于跨模块&lt;br&gt;敏捷原则：单一职责原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：[UIApplication sharedApplication]。
注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。
object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，
返回的也只是此单例类的唯一静态变量。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h4&gt;&lt;p&gt;应用场景：定义算法族，封装起来，使他们之间可以相互替换。&lt;br&gt;优势：使算法的变化独立于使用算法的用户&lt;br&gt;敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。
注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类
2，变化的行为抽象基类为，所有可变变化的父类
3，用户类的最终实例，通过注入行为实例的方式，设定易变行为
防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h4&gt;&lt;p&gt;应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。&lt;br&gt;优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。&lt;br&gt;敏捷原则：DIP依赖倒置原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换
注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，
增 加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 开发学习中，经常使用的几种开发模式，现在进行简单的总结和探讨：&lt;/p&gt;
&lt;h4 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h4&gt;&lt;p&gt;应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。&lt;br&gt;优势：解耦合&lt;br&gt;敏捷原则：开放-封闭原则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIAlertController 弹框</title>
    <link href="http://yoursite.com/2016/11/27/UIAlertController-%E5%BC%B9%E6%A1%86/"/>
    <id>http://yoursite.com/2016/11/27/UIAlertController-弹框/</id>
    <published>2016-11-27T13:15:28.000Z</published>
    <updated>2016-11-27T13:17:53.000Z</updated>
    
    <content type="html">&lt;p&gt;一. 标准的Alert样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//UIAlertController风格：UIAlertControllerStyleAlert
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;主标题&amp;quot; message:@&amp;quot;提示文字&amp;quot;preferredStyle:UIAlertControllerStyleAlert ];

//添加取消到UIAlertController中
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:cancelAction];

//添加确定到UIAlertController中
UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&amp;quot;确定&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:OKAction];

[self presentViewController:alertController animated:YES completion:nil]
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;二. 标准的Alert Sheet样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;标准的Action Sheet样式&amp;quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];
//取消:style:UIAlertActionStyleCancel//
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleCancel handler:nil];
[alertController addAction:cancelAction];
//了解更多:style:UIAlertActionStyleDestructive
UIAlertAction *moreAction = [UIAlertAction actionWithTitle:@&amp;quot;了解更多&amp;quot; style:UIAlertActionStyleDestructive handler:nil];
[alertController addAction:moreAction];
//原来如此:style:UIAlertActionStyleDefault
UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&amp;quot;原来如此&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:OKAction];

[self presentViewController:alertController animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;三. 新功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;style:UIAlertActionStyleDefault//对按钮应用标准样式
style:UIAlertActionStyleCancel//对按钮应用取消样式，即取消操作
style:UIAlertActionStyleDestructive//对按钮应用警示性样式，提示用户这样做可能会删除或者改变某些数据


UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;主标题:标题党&amp;quot;message:@&amp;quot;子标题:提示信息&amp;quot; preferredStyle:UIAlertControllerStyleAlert ];
//取消style:UIAlertActionStyleDefault
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:cancelAction];

//style:UIAlertActionStyleDestructive(警告提示)
UIAlertAction *rubbishAction = [UIAlertAction actionWithTitle:@&amp;quot;确定修改&amp;quot; style:UIAlertActionStyleDestructive handler:nil];
[alertController addAction:rubbishAction];

[self presentViewController:alertController animated:YES completion:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;四. 弹出文本框&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 只有在alert情况下才可以添加文本框
    [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) {
        textField.placeholder = @&amp;quot;用户名&amp;quot;;
        textField.secureTextEntry = YES;
    }];

//    // 取出文本
//    UITextField *text = alertController.textFields.firstObject;
//    UIAlertAction *action = alertController.actions.firstObject;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;一. 标准的Alert样式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//UIAlertController风格：UIAlertControllerStyleAlert
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&amp;quot;主标题&amp;quot; message:@&amp;quot;提示文字&amp;quot;preferredStyle:UIAlertControllerStyleAlert ];

//添加取消到UIAlertController中
UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&amp;quot;取消&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:cancelAction];

//添加确定到UIAlertController中
UIAlertAction *OKAction = [UIAlertAction actionWithTitle:@&amp;quot;确定&amp;quot; style:UIAlertActionStyleDefault handler:nil];
[alertController addAction:OKAction];

[self presentViewController:alertController animated:YES completion:nil]
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UIWebView 实现长按保存图片功能</title>
    <link href="http://yoursite.com/2016/11/22/UIWebView-%E5%AE%9E%E7%8E%B0%E9%95%BF%E6%8C%89%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/11/22/UIWebView-实现长按保存图片功能/</id>
    <published>2016-11-22T12:50:24.000Z</published>
    <updated>2016-11-22T12:57:50.000Z</updated>
    
    <content type="html">&lt;p&gt;拿到需求之后分析了一下，其实主要功能点就是如何才能通过手指按压位置获取到相应的图片资源。&lt;/p&gt;
&lt;p&gt;首先是给UiWebView加一个长按手势 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UILongPressGestureRecognizer* longPressed = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressed:)];
longPressed.delegate = self;
[self.webView addGestureRecognizer:longPressed];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;响应方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)longPressed:(UILongPressGestureRecognizer*)recognizer
{

    if (recognizer.state != UIGestureRecognizerStateBegan) {
        return;
    }

    CGPoint touchPoint = [recognizer locationInView:self.webView];
    NSString *jsForTagName = [NSString stringWithFormat:@&amp;quot;document.elementFromPoint(%f, %f).tagName&amp;quot;, touchPoint.x, touchPoint.y];
    NSString * tagName = [self.webView stringByEvaluatingJavaScriptFromString:jsForTagName];
    if (![tagName isEqualToString:@&amp;quot;img&amp;quot;] &amp;amp;&amp;amp; ![tagName isEqualToString:@&amp;quot;IMG&amp;quot;]) {
        return;
    }
    NSString *imgURL = [NSString stringWithFormat:@&amp;quot;document.elementFromPoint(%f, %f).src&amp;quot;, touchPoint.x, touchPoint.y];
    self.urlToSave = [self.webView stringByEvaluatingJavaScriptFromString:imgURL];

    if (self.urlToSave.length == 0) {
        return;
    }

    [self showImageOptionsWithUrl:self.urlToSave];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;弹窗提示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)showImageOptionsWithUrl:(NSString *)imageUrl
{
    UIActionSheet *actionSheet = [[UIActionSheet alloc]
                                  initWithTitle:nil
                                  delegate:self
                                  cancelButtonTitle:@&amp;quot;取消&amp;quot;
                                  destructiveButtonTitle:@&amp;quot;保存图片&amp;quot;
                                  otherButtonTitles: nil];
    actionSheet.actionSheetStyle = UIActionSheetStyleBlackOpaque;
    [actionSheet showInView:self.view];
}


- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex
{
    if (buttonIndex == 0) {
        [self saveImageToDiskWithUrl:self.urlToSave];
    }
}

// 执行保存操作
- (void)saveImageToDiskWithUrl:(NSString *)imageUrl
{
    NSURL *url = [NSURL URLWithString:imageUrl];
    NSURLSessionConfiguration * configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self  delegateQueue:[NSOperationQueue new]];
    NSURLRequest *imgRequest = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:30.0];

    NSURLSessionDownloadTask  *task = [session downloadTaskWithRequest:imgRequest completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        if (error) {
            return ;
        }

        NSData * imageData = [NSData dataWithContentsOfURL:location];
        dispatch_async(dispatch_get_main_queue(), ^{

            UIImage * image = [UIImage imageWithData:imageData];

            UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), NULL);
        });
    }];

    [task resume];
}

／／ 监测是否保存成功
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo
{
    if (error) {
        NSLog(@&amp;quot;保存fail&amp;quot;);
        [UMComShowToast fetchFailWithNoticeMessage:@&amp;quot;保存失败&amp;quot;];
        //        [[RAProgressHUD sharedHUD] showErrorWithMessage:@&amp;quot;保存失败&amp;quot;];
    } else {
        NSLog(@&amp;quot;保存成功&amp;quot;);
        //        [[RAProgressHUD sharedHUD] showSuccessWithMessage:@&amp;quot;保存成功&amp;quot;];
        [UMComShowToast fetchFailWithNoticeMessage:@&amp;quot;保存成功&amp;quot;];
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;拿到需求之后分析了一下，其实主要功能点就是如何才能通过手指按压位置获取到相应的图片资源。&lt;/p&gt;
&lt;p&gt;首先是给UiWebView加一个长按手势 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;UILongPressGestureRecognizer* longPressed = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressed:)];
longPressed.delegate = self;
[self.webView addGestureRecognizer:longPressed];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>YYModel字典转模型的几种详细用法</title>
    <link href="http://yoursite.com/2016/11/14/YYModel%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E8%AF%A6%E7%BB%86%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2016/11/14/YYModel字典转模型的几种详细用法/</id>
    <published>2016-11-14T11:47:06.000Z</published>
    <updated>2016-11-14T11:51:09.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;常用的几个方法&quot;&gt;&lt;a href=&quot;#常用的几个方法&quot; class=&quot;headerlink&quot; title=&quot;常用的几个方法&quot;&gt;&lt;/a&gt;常用的几个方法&lt;/h4&gt;&lt;p&gt;json转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithJSON:(id)json;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSString *)yy_modelToJSONString 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 声明数组、字典或者集合里的元素类型时要重写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass；
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# YYAlbum.h
@property (nonatomic, copy) NSString *name;
@property (nonatomic, strong) NSArray *photos; # Array&amp;lt;YYPhoto&amp;gt;
@property (nonatomic, strong) NSDictionary *likedUsers; # Key:name(NSString) Value:user(YYUser)
@property (nonatomic, strong) NSSet *likedUserIds; # Set&amp;lt;NSNumber&amp;gt;

# YYPhoto.h
@property (nonatomic, copy) NSString *url;
@property (nonatomic, copy) NSString *desc;

# YYAlbum.m
#把数组里面带有对象的类型专门按照这个方法，这个格式写出来
-(nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass{
    return @{
             @&amp;quot;photos&amp;quot;       : YYPhoto.class,
             @&amp;quot;likedUsers&amp;quot;   : YYUser.class,
             @&amp;quot;likedUserIds&amp;quot; : NSNumber.class
             };
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典里的key值与模型的属性值不一致要重置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelCustomPropertyMapper;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# YYMessage.h
@property (nonatomic, assign) uint64_t messageId;
@property (nonatomic, strong) NSString *content;
@property (nonatomic, strong) NSDate *time;

# YYMessage.m
/*!
 *  1.该方法是 `字典里的属性Key` 和 `要转化为模型里的属性名` 不一样 而重写的
 *  前：模型的属性   后：字典里的属性
 */

+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelCustomPropertyMapper{

    return @{@&amp;quot;messageId&amp;quot;:@&amp;quot;i&amp;quot;,
             @&amp;quot;content&amp;quot;:@&amp;quot;c&amp;quot;,
             @&amp;quot;time&amp;quot;:@&amp;quot;t&amp;quot;};
}

/*!
 *  2. 下面的两个方法 `字典里值`与`模型的值`类型不一样`需要转换`而重写的方法
 *   NSDate *time     dic[@&amp;quot;t&amp;quot;]是double类型的的秒数
 */

/// Dic -&amp;gt; model
- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic {

    self.time = (NSDate *)[NSDate dateWithTimeIntervalSince1970:[dic[@&amp;quot;t&amp;quot;] doubleValue]/1000];

    return YES;
}

/// model -&amp;gt; Dic
- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic {

    dic[@&amp;quot;t&amp;quot;] = @([self.time timeIntervalSince1970] * 1000).description;

    return YES;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面两者是属性值在两个dic与模型之间的转化方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)modelCustomTransformFromDictionary:(NSDictionary *)dic ；
- (BOOL)modelCustomTransformToDictionary:(NSMutableDictionary *)dic；
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;常用的几个方法&quot;&gt;&lt;a href=&quot;#常用的几个方法&quot; class=&quot;headerlink&quot; title=&quot;常用的几个方法&quot;&gt;&lt;/a&gt;常用的几个方法&lt;/h4&gt;&lt;p&gt;json转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithJSON:(id)json;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模型转字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSString *)yy_modelToJSONString 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字典转模型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 声明数组、字典或者集合里的元素类型时要重写&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+ (nullable NSDictionary&amp;lt;NSString *, id&amp;gt; *)modelContainerPropertyGenericClass；
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>layoutSubviews 总结</title>
    <link href="http://yoursite.com/2016/10/27/layoutSubviews-%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/10/27/layoutSubviews-总结/</id>
    <published>2016-10-27T11:23:57.000Z</published>
    <updated>2016-10-27T11:28:05.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;ios-layout机制相关方法&quot;&gt;&lt;a href=&quot;#ios-layout机制相关方法&quot; class=&quot;headerlink&quot; title=&quot;ios layout机制相关方法&quot;&gt;&lt;/a&gt;ios layout机制相关方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (CGSize)sizeThatFits:(CGSize)size
- (void)sizeToFit
——————-
- (void)layoutSubviews
- (void)layoutIfNeeded
- (void)setNeedsLayout
——————–
- (void)setNeedsDisplay
- (void)drawRect
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;layoutSubviews在以下情况下会被调用：&quot;&gt;&lt;a href=&quot;#layoutSubviews在以下情况下会被调用：&quot; class=&quot;headerlink&quot; title=&quot;layoutSubviews在以下情况下会被调用：&quot;&gt;&lt;/a&gt;layoutSubviews在以下情况下会被调用：&lt;/h4&gt;&lt;p&gt;1、init初始化不会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;但是是用initWithFrame 进行初始化时，当rect的值不为CGRectZero时,也会触发&lt;/p&gt;
&lt;p&gt;2、addSubview会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化&lt;/p&gt;
&lt;p&gt;4、滚动一个UIScrollView会触发layoutSubviews&lt;/p&gt;
&lt;p&gt;5、旋转Screen会触发父UIView上的layoutSubviews事件&lt;/p&gt;
&lt;p&gt;6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件&lt;/p&gt;
&lt;h3 id=&quot;刷新子对象布局&quot;&gt;&lt;a href=&quot;#刷新子对象布局&quot; class=&quot;headerlink&quot; title=&quot;刷新子对象布局&quot;&gt;&lt;/a&gt;刷新子对象布局&lt;/h3&gt;&lt;p&gt;-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写&lt;br&gt;-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用&lt;br&gt;-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）&lt;/p&gt;
&lt;p&gt;如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局&lt;/p&gt;
&lt;p&gt;在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]&lt;/p&gt;
&lt;h3 id=&quot;重绘&quot;&gt;&lt;a href=&quot;#重绘&quot; class=&quot;headerlink&quot; title=&quot;重绘&quot;&gt;&lt;/a&gt;重绘&lt;/h3&gt;&lt;p&gt;-drawRect:(CGRect)rect方法：重写此方法，执行重绘任务&lt;br&gt;-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect&lt;br&gt;-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘&lt;/p&gt;
&lt;p&gt;sizeToFit会自动调用sizeThatFits方法；&lt;/p&gt;
&lt;p&gt;sizeToFit不应该在子类中被重写，应该重写sizeThatFits&lt;/p&gt;
&lt;p&gt;sizeThatFits传入的参数是receiver当前的size，返回一个适合的size&lt;/p&gt;
&lt;p&gt;sizeToFit可以被手动直接调用&lt;/p&gt;
&lt;p&gt;sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己&lt;/p&gt;
&lt;p&gt;layoutSubviews对subviews重新布局&lt;/p&gt;
&lt;p&gt;layoutSubviews方法调用先于drawRect&lt;/p&gt;
&lt;p&gt;setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews&lt;/p&gt;
&lt;p&gt;layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的&lt;/p&gt;
&lt;p&gt;layoutIfNeeded遍历的不是superview链，应该是subviews链&lt;/p&gt;
&lt;p&gt;drawRect是对receiver的重绘，能获得context&lt;/p&gt;
&lt;p&gt;setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘 &lt;/p&gt;
&lt;h3 id=&quot;sizeToFit&quot;&gt;&lt;a href=&quot;#sizeToFit&quot; class=&quot;headerlink&quot; title=&quot;sizeToFit&quot;&gt;&lt;/a&gt;sizeToFit&lt;/h3&gt;&lt;p&gt;sizeToFit会自动调用sizeThatFits方法；&lt;br&gt;sizeToFit不应该在子类中被重写，应该重写sizeThatFits&lt;br&gt;sizeThatFits传入的参数是receiver当前的size，返回一个适合的size&lt;br&gt;sizeToFit可以被手动直接调用sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ios-layout机制相关方法&quot;&gt;&lt;a href=&quot;#ios-layout机制相关方法&quot; class=&quot;headerlink&quot; title=&quot;ios layout机制相关方法&quot;&gt;&lt;/a&gt;ios layout机制相关方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (CGSize)sizeThatFits:(CGSize)size
- (void)sizeToFit
——————-
- (void)layoutSubviews
- (void)layoutIfNeeded
- (void)setNeedsLayout
——————–
- (void)setNeedsDisplay
- (void)drawRect
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别知识点总结六</title>
    <link href="http://yoursite.com/2016/10/20/iOS%E7%89%B9%E5%88%AB%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E5%85%AD/"/>
    <id>http://yoursite.com/2016/10/20/iOS特别知识点总结六/</id>
    <published>2016-10-20T14:04:41.000Z</published>
    <updated>2016-10-20T14:06:04.000Z</updated>
    
    <content type="html">&lt;p&gt;//判断内容是否全部为空格  yes 全部为空格  no 不是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)isEmpty:(NSString *) str {

    if (!str) {
        return true;
    } else {
        //A character set containing only the whitespace characters space (U+0020) and tab (U+0009) and the newline and nextline characters (U+000A–U+000D, U+0085).
        NSCharacterSet *set = [NSCharacterSet whitespaceAndNewlineCharacterSet];

        //Returns a new string made by removing from both ends of the receiver characters contained in a given character set.
        NSString *trimedString = [str stringByTrimmingCharactersInSet:set];

        if ([trimedString length] == 0) {
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UITabBarController&quot;&gt;&lt;a href=&quot;#UITabBarController&quot; class=&quot;headerlink&quot; title=&quot;UITabBarController&quot;&gt;&lt;/a&gt;UITabBarController&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//1.创建Window
 self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
 self.window.backgroundColor = [UIColor whiteColor];

 //a.初始化一个tabBar控制器
 UITabBarController *tb=[[UITabBarController alloc]init];
 //设置控制器为Window的根控制器
 self.window.rootViewController=tb;

 //b.创建子控制器
 UIViewController *c1=[[UIViewController alloc]init];
 c1.view.backgroundColor=[UIColor grayColor];
 c1.view.backgroundColor=[UIColor greenColor];
 c1.tabBarItem.title=@&amp;quot;消息&amp;quot;;
 c1.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_recent_nor&amp;quot;];
 c1.tabBarItem.badgeValue=@&amp;quot;123&amp;quot;;

 UIViewController *c2=[[UIViewController alloc]init];
 c2.view.backgroundColor=[UIColor brownColor];
 c2.tabBarItem.title=@&amp;quot;联系人&amp;quot;;
 c2.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_buddy_nor&amp;quot;];

 UIViewController *c3=[[UIViewController alloc]init];
 c3.tabBarItem.title=@&amp;quot;动态&amp;quot;;
 c3.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_qworld_nor&amp;quot;];

 UIViewController *c4=[[UIViewController alloc]init];
 c4.tabBarItem.title=@&amp;quot;设置&amp;quot;;
 c4.tabBarItem.image=[UIImage imageNamed:@&amp;quot;tab_me_nor&amp;quot;]; 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;weak-typeof-self-weakSelf-self&quot;&gt;&lt;a href=&quot;#weak-typeof-self-weakSelf-self&quot; class=&quot;headerlink&quot; title=&quot;_weak typeof(self) weakSelf = self;&quot;&gt;&lt;/a&gt;_weak typeof(self) weakSelf = self;&lt;/h3&gt;&lt;p&gt;内存管理原则&lt;br&gt;1、默认strong，可选weak。strong下不管成员变量还是property，每次使用指针指向一个对象，等于自动调用retain(), 并对旧对象调用release(),所以设为nil等于release。&lt;br&gt;2、只要某个对象被任一strong指针指向，那么它将不会被销毁，否则立即释放，不用等runloop结束。所有strong指针变量不需要在dealloc中手动设为nil，iOS会自动处理，debug可以看到全部被置为nil，最先声明的变量最后调用dealloc释放。&lt;/p&gt;
&lt;p&gt;3、官方建议IBOutlet加上__weak，实际上不用加也会自动释放；&lt;/p&gt;
&lt;p&gt;4、优先使用私有成员变量，除非需要公开属性才用property。&lt;/p&gt;
&lt;p&gt;5、避免循环引用，否则手动设置nil释放。&lt;/p&gt;
&lt;p&gt;6、block方法常用声明：@property (copy) void(^MyBlock)(void); 如果超出当前作用域之后仍然继续使用block，那么最好使用copy关键字，拷贝到堆区，防止栈区变量销毁。&lt;/p&gt;
&lt;p&gt;7、创建block匿名函数之前一般需要对self进行weak化，否则造成循环引用无法释放controller:&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;weak MyController *weakSelf = self 或者 &lt;/strong&gt;weak __typeof(self) weakSelf = self;&lt;br&gt;执行block方法体的时候也可以转换为强引用之后再使用：MyController* strongSelf = weakSelf; if (!strongSelf) { return; }&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//判断内容是否全部为空格  yes 全部为空格  no 不是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (BOOL)isEmpty:(NSString *) str {

    if (!str) {
        return true;
    } else {
        //A character set containing only the whitespace characters space (U+0020) and tab (U+0009) and the newline and nextline characters (U+000A–U+000D, U+0085).
        NSCharacterSet *set = [NSCharacterSet whitespaceAndNewlineCharacterSet];

        //Returns a new string made by removing from both ends of the receiver characters contained in a given character set.
        NSString *trimedString = [str stringByTrimmingCharactersInSet:set];

        if ([trimedString length] == 0) {
            return true;
        } else {
            return false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之顶部状态栏statusBar颜色变化小结</title>
    <link href="http://yoursite.com/2016/10/20/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E9%A1%B6%E9%83%A8%E7%8A%B6%E6%80%81%E6%A0%8FstatusBar%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/10/20/iOS开发之顶部状态栏statusBar颜色变化小结/</id>
    <published>2016-10-20T14:01:28.000Z</published>
    <updated>2016-10-20T14:03:50.000Z</updated>
    
    <content type="html">&lt;p&gt;iOS开发之顶部状态栏statusBar颜色变化小结&lt;/p&gt;
&lt;p&gt;1.单个视图View没有导航控制器包装的情况下&lt;/p&gt;
&lt;p&gt;(1.只设置启动状态栏颜色改变(白色)，而视图中状态栏不变化(默认黑色)，做如下的设置即可，两种方式不管先设置哪一个，另一个都会相应的变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. General 中的 Status Bar Style   --&amp;gt;  Light

b. plist 中增加 Status Bar Style   --&amp;gt;  UIStatusBarStyleLightContent
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;(2).设置启动状态栏颜色改变(白色)，视图中的状态栏也变成白色(保持上面的设置)，有两种设置方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. 在Info.plist里面添加一行View controller-based status bar appearance ＝ NO 即可

b.在视图控制器中添加代码

  - (UIStatusBarStyle)preferredStatusBarStyle {

    return UIStatusBarStyleLightContent;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3).设置视图中状态栏的颜色为白色，启动程序时的状态栏为默认颜色(黑色)，没有做1.中的任何设置情况下，在控制器.m文件中添加如下代码(即2.-&amp;gt;b.)&lt;/p&gt;
&lt;p&gt;2.视图作为导航控制器的根控制器的情况下&lt;/p&gt;
&lt;p&gt;(1) .设置启动画面的状态栏为白色，视图中的状态栏为默认(黑色)，如1.-&amp;gt;1.中的设置即可，&lt;/p&gt;
&lt;p&gt;(2) .设置启动画面和视图中的状态栏颜色都为白色(保持2.-&amp;gt;1.中的设置)，方式同样有两种：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a.在Info.plist里面添加一行View controller-based status bar appearance ＝ NO 即可


b.此时如果单单在视图控制器.m文件中添加如下代码是不够的，

- (UIStatusBarStyle)preferredStatusBarStyle {
    return UIStatusBarStyleLightContent;
}
同时需要在导航控制器.m文件中添加下面的代码才能达到效果(careful)

- (UIViewController *)childViewControllerForStatusBarStyle{
    return self.topViewController;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(3).只设置视图控制器状态栏颜色为白色，启动画面的状态栏为默认(黑色)，把Info.plist文件中的 Status bar style = UIStatusBarStyleLightContent设置去掉，保持2.-&amp;gt;2.-&amp;gt;b.中的代码设置即可&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;iOS开发之顶部状态栏statusBar颜色变化小结&lt;/p&gt;
&lt;p&gt;1.单个视图View没有导航控制器包装的情况下&lt;/p&gt;
&lt;p&gt;(1.只设置启动状态栏颜色改变(白色)，而视图中状态栏不变化(默认黑色)，做如下的设置即可，两种方式不管先设置哪一个，另一个都会相应的变化&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a. General 中的 Status Bar Style   --&amp;gt;  Light

b. plist 中增加 Status Bar Style   --&amp;gt;  UIStatusBarStyleLightContent
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发使用系统的拷贝剪切功能</title>
    <link href="http://yoursite.com/2016/10/19/iOS%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%89%AA%E5%88%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/10/19/iOS开发使用系统的拷贝剪切功能/</id>
    <published>2016-10-19T11:15:58.000Z</published>
    <updated>2016-10-19T11:19:30.000Z</updated>
    
    <content type="html">&lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2）响应事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//并加上几个方法
-(void)longPressCellHandle:(UILongPressGestureRecognizer *)gesture {

    [self becomeFirstResponder];
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    UIMenuItem *copyItem = [[UIMenuItem alloc] initWithTitle:@&amp;quot;复制&amp;quot; action:@selector(menuCopyBtnPressed:)];
    menuController.menuItems = @[copyItem];
    [menuController setTargetRect:gesture.view.frame inView:gesture.view.superview];
    [menuController setMenuVisible:YES animated:YES];
    [UIMenuController sharedMenuController].menuItems=nil;
}

// 将要复制的内容复制到系统的剪贴板
- (void)menuCopyBtnPressed:(UIMenuItem *)menuItem {
    //  通用的粘贴板
    [UIPasteboard generalPasteboard].string = self.messageLab.text;
}

- (BOOL)canBecomeFirstResponder {

    return YES;
}

- (BOOL)canPerformAction:(SEL)action withSender:(id)sender {

    if (action == @selector(menuCopyBtnPressed:)) {
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之旅之懒加载</title>
    <link href="http://yoursite.com/2016/10/18/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2016/10/18/iOS开发之旅之懒加载/</id>
    <published>2016-10-18T14:54:55.000Z</published>
    <updated>2016-10-18T14:56:00.000Z</updated>
    
    <content type="html">&lt;p&gt;懒加载定义：延时加载，即当对象需要用到的时候再去加载。其实就是所谓的重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。&lt;/p&gt;
&lt;p&gt;需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)shopData {

    if (!_shopData) {
        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];
    }
    return _shopData;
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;懒加载的优点&lt;/p&gt;
&lt;p&gt;1）不需将对象的实例化写到viewDidLoad，可以简化代码，增强代码的可读性&lt;br&gt;2）对象的实例化在 getter 方法中，各司其职，降低耦合性&lt;br&gt;3）对系统的内存占用率会减小&lt;/p&gt;
&lt;p&gt;总结：懒加载即用到时方去加载对象&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;懒加载定义：延时加载，即当对象需要用到的时候再去加载。其实就是所谓的重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。&lt;/p&gt;
&lt;p&gt;需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)shopData {

    if (!_shopData) {
        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];
    }
    return _shopData;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>initWithFrame方法的理解</title>
    <link href="http://yoursite.com/2016/09/28/initWithFrame%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/09/28/initWithFrame方法的理解/</id>
    <published>2016-09-28T11:33:37.000Z</published>
    <updated>2016-09-28T11:36:38.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;initWithFrame方法是什么？&quot;&gt;&lt;a href=&quot;#initWithFrame方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;initWithFrame方法是什么？&quot;&gt;&lt;/a&gt;initWithFrame方法是什么？&lt;/h4&gt;&lt;p&gt;initWithFrame方法用来初始化并返回一个新的视图对象,根据指定的CGRect（尺寸）。&lt;/p&gt;
&lt;h4 id=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;a href=&quot;#什么时候用initWithFrame方法？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;/a&gt;什么时候用initWithFrame方法？&lt;/h4&gt;&lt;p&gt;简单的说，我们用编程方式申明，创建UIView对象时，使用initWithFrame方法。&lt;br&gt;在此，我们必须搞清楚，两种方式来进行初始化UIView。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-使用-Interface-Builder-方式&quot;&gt;&lt;a href=&quot;#1-使用-Interface-Builder-方式&quot; class=&quot;headerlink&quot; title=&quot;1) 使用 Interface Builder 方式&quot;&gt;&lt;/a&gt;1) 使用 Interface Builder 方式&lt;/h4&gt;&lt;p&gt; 这种方式，就是使用nib文件。通常我们说的“拖控件” 的方式。&lt;/p&gt;
&lt;p&gt;实际编程中，我们如果用Interface Builder 方式创建了UIView对象。（也就是，用拖控件的方式）&lt;br&gt;那么，initWithFrame方法方法是不会被调用的。因为nib文件已经知道如何初始化该View。（因为，我们在拖该view的时候，就定义好了长、宽、背景等属性）。&lt;br&gt;这时候，会调用initWithCoder方法，我们可以用initWithCoder方法来重新定义我们在nib中已经设置的各项属性。&lt;/p&gt;
&lt;h4 id=&quot;2-使用编程方式&quot;&gt;&lt;a href=&quot;#2-使用编程方式&quot; class=&quot;headerlink&quot; title=&quot;2) 使用编程方式&quot;&gt;&lt;/a&gt;2) 使用编程方式&lt;/h4&gt;&lt;p&gt;实际编程中，我们使用编程方式下，来创建一个UIView或者创建UIView的子类。这时候，将调用initWithFrame方法，来实例化UIView。&lt;br&gt;特别注意，如果在子类中重载initWithFrame方法，必须先调用父类的initWithFrame方法。在对自定义的UIView子类进行初始化操作。&lt;br&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)initWithFrame:(CGRect)frame{
    self = [super initWithFrame:frame];// 先调用父类的initWithFrame方法
    if (self) {

        // 再自定义该类（UIView子类）的初始化操作。
        _scrollView = [[UIScrollView alloc] initWithFrame:self.bounds];
        [_scrollView setFrame:CGRectMake(0, 0, 320, 480)];
        _scrollView.contentSize = CGSizeMake(320*3, 480);

        [self addSubview:_scrollView];
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;那么，用Interface-Builder-方式创建的nib文件是什么？&quot;&gt;&lt;a href=&quot;#那么，用Interface-Builder-方式创建的nib文件是什么？&quot; class=&quot;headerlink&quot; title=&quot;那么，用Interface Builder 方式创建的nib文件是什么？&quot;&gt;&lt;/a&gt;那么，用Interface Builder 方式创建的nib文件是什么？&lt;/h4&gt;&lt;p&gt;对于应用程序，资源是一种数据文件，伴随可程序执行程序的一种数据文件。（可以理解为可执行程序的，一种不可缺少的组陈部分）。&lt;br&gt;资源文件，是一种可移动的，由适合的工具编写的一种特殊的代码。&lt;br&gt;如：plish文件，txt文件，图像，视频等文件。都可以被xCode识别和引用。&lt;/p&gt;
&lt;p&gt;一个应用程序可以包含多种形式的资源文件。&lt;/p&gt;
&lt;p&gt;当然，nib文件也不例外，仅仅是一种资源文件。&lt;br&gt;通过Interface Builder 方式，可以创建nib文件，存储应用程序的UI对象。供应用程序来读取。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;initWithFrame方法是什么？&quot;&gt;&lt;a href=&quot;#initWithFrame方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;initWithFrame方法是什么？&quot;&gt;&lt;/a&gt;initWithFrame方法是什么？&lt;/h4&gt;&lt;p&gt;initWithFrame方法用来初始化并返回一个新的视图对象,根据指定的CGRect（尺寸）。&lt;/p&gt;
&lt;h4 id=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;a href=&quot;#什么时候用initWithFrame方法？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;/a&gt;什么时候用initWithFrame方法？&lt;/h4&gt;&lt;p&gt;简单的说，我们用编程方式申明，创建UIView对象时，使用initWithFrame方法。&lt;br&gt;在此，我们必须搞清楚，两种方式来进行初始化UIView。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> NSString 字符串处理</title>
    <link href="http://yoursite.com/2016/09/22/NSString-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/09/22/NSString-字符串处理/</id>
    <published>2016-09-22T14:39:16.000Z</published>
    <updated>2016-09-22T14:40:10.000Z</updated>
    
    <content type="html">&lt;p&gt;iphone NSString 字符串处理：截取字符串、匹配字符串、分隔字符串    &lt;/p&gt;
&lt;p&gt;1.截取字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
string = [string substringToIndex:7];//截取掉下标7之后的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
[string substringFromIndex:2];//截取掉下标2之前的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.匹配字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSRange range = [stringrangeOfString:@&amp;quot;f&amp;quot;];//匹配得到的下标
NSLog(@&amp;quot;rang:%@&amp;quot;,NSStringFromRange(range));
string = [string substringWithRange:range];//截取范围类的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.分隔字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSArray *array = [string componentsSeparatedByString:@&amp;quot;A&amp;quot;]; //从字符A中分隔成2个元素的数组
NSLog(@&amp;quot;array:%@&amp;quot;,array); //结果是adfsfsfs和dfsdf
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;iphone NSString 字符串处理：截取字符串、匹配字符串、分隔字符串    &lt;/p&gt;
&lt;p&gt;1.截取字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
string = [string substringToIndex:7];//截取掉下标7之后的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
[string substringFromIndex:2];//截取掉下标2之前的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UISlide属性</title>
    <link href="http://yoursite.com/2016/09/22/UISlide%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/22/UISlide属性/</id>
    <published>2016-09-22T14:39:02.000Z</published>
    <updated>2016-09-22T14:43:35.000Z</updated>
    
    <content type="html">&lt;p&gt;1.minimumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最小位置的值，默认为0.0

_slider.minimumValue = 10.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.maximumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最大位置的值，默认为1.0

_slider.maximumValue = 100.0;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;3.continuous &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果设置YES，在拖动滑块的任何时候，滑块的值都会改变。默认设置为YES

[_slider setContinuous:NO]; // 在滑块滑动结束时才获取滑块的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.minimumValueImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最小值处设置的图片，默认为nil

_slider.minimumValueImage = [UIImage imageNamed:@&amp;quot;003.png&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.maximumValueImage&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最大值处设置的图片,默认为nil

_slider.maximumValueImage = [UIImage imageNamed:@&amp;quot;002.png&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.minimumTrackTintColor :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小于滑块当前值滑块条的颜色，默认为蓝色

_slider.minimumTrackTintColor = [UIColor redColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.maximumTrackTintColor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大于滑块当前值滑块条的颜色，默认为白色

_slider.maximumTrackTintColor = [UIColor greenColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.thumbTintColor :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当前滑块的颜色，默认为白色

_slider.thumbTintColor = [UIColor yellowColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9.currentMaximumTrackImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最大值处设置的图片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;10.currentMinimumTrackImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最小值处设置的图片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;11.currentThumbImage&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当前滑块的图片
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;1.minimumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最小位置的值，默认为0.0

_slider.minimumValue = 10.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.maximumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最大位置的值，默认为1.0

_slider.maximumValue = 100.0;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用 AFNetworking 监听网络状态</title>
    <link href="http://yoursite.com/2016/09/22/%E5%88%A9%E7%94%A8-AFNetworking-%E7%9B%91%E5%90%AC%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2016/09/22/利用-AFNetworking-监听网络状态/</id>
    <published>2016-09-22T14:33:42.000Z</published>
    <updated>2016-09-22T14:37:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-创建网络监听者管理者对象&quot;&gt;&lt;a href=&quot;#1-创建网络监听者管理者对象&quot; class=&quot;headerlink&quot; title=&quot;1.创建网络监听者管理者对象&quot;&gt;&lt;/a&gt;1.创建网络监听者管理者对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-设置监听&quot;&gt;&lt;a href=&quot;#2-设置监听&quot; class=&quot;headerlink&quot; title=&quot;2.设置监听&quot;&gt;&lt;/a&gt;2.设置监听&lt;/h3&gt;&lt;p&gt;1)网络状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//显然是枚举值
typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,//未识别的网络
    AFNetworkReachabilityStatusNotReachable     = 0,//不可达的网络
    AFNetworkReachabilityStatusReachableViaWWAN = 1,//2G,3G,4G...
    AFNetworkReachabilityStatusReachableViaWiFi = 2,//wifi网络
    }
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2)设置网络监听&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        case AFNetworkReachabilityStatusUnknown:
            NSLog(@&amp;quot;未识别的网络&amp;quot;);
            break;

        case AFNetworkReachabilityStatusNotReachable:
            NSLog(@&amp;quot;不可达的网络(未连接)&amp;quot;);
            break;

        case AFNetworkReachabilityStatusReachableViaWWAN:
            NSLog(@&amp;quot;2G,3G,4G...的网络&amp;quot;);
            break;

        case AFNetworkReachabilityStatusReachableViaWiFi:
            NSLog(@&amp;quot;wifi的网络&amp;quot;);
            break;
        default:
            break;
    }
}];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-开始监听&quot;&gt;&lt;a href=&quot;#3-开始监听&quot; class=&quot;headerlink&quot; title=&quot;3.开始监听&quot;&gt;&lt;/a&gt;3.开始监听&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[manager startMonitoring];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建网络监听者管理者对象&quot;&gt;&lt;a href=&quot;#1-创建网络监听者管理者对象&quot; class=&quot;headerlink&quot; title=&quot;1.创建网络监听者管理者对象&quot;&gt;&lt;/a&gt;1.创建网络监听者管理者对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-设置监听&quot;&gt;&lt;a href=&quot;#2-设置监听&quot; class=&quot;headerlink&quot; title=&quot;2.设置监听&quot;&gt;&lt;/a&gt;2.设置监听&lt;/h3&gt;&lt;p&gt;1)网络状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//显然是枚举值
typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,//未识别的网络
    AFNetworkReachabilityStatusNotReachable     = 0,//不可达的网络
    AFNetworkReachabilityStatusReachableViaWWAN = 1,//2G,3G,4G...
    AFNetworkReachabilityStatusReachableViaWiFi = 2,//wifi网络
    }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>仿射变换(CGAffineTransform)使用小结</title>
    <link href="http://yoursite.com/2016/09/22/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2-CGAffineTransform-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/22/仿射变换-CGAffineTransform-使用小结/</id>
    <published>2016-09-22T14:28:02.000Z</published>
    <updated>2016-09-22T14:32:43.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;一、理论基础&lt;/h3&gt;&lt;p&gt;在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换(运用一次函数进行的变换)接上一个平移组成。&lt;/p&gt;
&lt;p&gt;CGAffineTransform简单分析（&lt;a href=&quot;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、射变换的种类&quot;&gt;&lt;a href=&quot;#二、射变换的种类&quot; class=&quot;headerlink&quot; title=&quot;二、射变换的种类&quot;&gt;&lt;/a&gt;二、射变换的种类&lt;/h3&gt;&lt;p&gt;1.自定义变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMake(1.0, 0, 0, 1.0, 20, 20);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.平移&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; x &amp;gt; 0 右边  x &amp;lt; 0 左边
 y &amp;gt; 0 下边  y &amp;lt; 0 上边 
 _demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeTranslation(100, -50);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.缩放      x 轴缩放 ， y 轴缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeScale(2, 0.5);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.旋转     angle &amp;gt; 0 顺时针 ， angle &amp;lt; 0逆时针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
   _demoView.transform = CGAffineTransformMakeRotation(20);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.旋转 ＋ 平移 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeRotation(20);
}];
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformTranslate(_demoView.transform, 150, 150);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.旋转 ＋ 缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeRotation(20);
    //        NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformIsIdentity(_demoView.transform));
}];
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformScale(_demoView.transform, 0.5, 2);
    //        NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformIsIdentity(_demoView.transform));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.相反 （逆旋转，逆移动等）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformInvert(CGAffineTransformMakeRotation(20));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.合并多个变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformConcat(CGAffineTransformMakeRotation(20), CGAffineTransformScale(_demoView.transform, 0.5, 2));
    NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformEqualToTransform(CGAffineTransformMakeRotation(20), CGAffineTransformScale(_demoView.transform, 0.5, 2)));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三、补充&quot;&gt;&lt;a href=&quot;#三、补充&quot; class=&quot;headerlink&quot; title=&quot;三、补充&quot;&gt;&lt;/a&gt;三、补充&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;CGAffineTransformIdentity ： 单位矩阵变换，一般用于仿射变换的初始化或者还原。
CGAffineTransformEqualToTransform(CGAffineTransform t1, CGAffineTransform t2) ： 判断两个变换矩阵是否相等
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2) ： 得到两个矩阵相加后得到的最终矩阵
CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform t) ： 某点通过矩阵变换之后的点
CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform t) ： 某个size通过矩阵变换之后的size
CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform t) ： 某个Rect通过矩阵变换之后的区域
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;一、理论基础&lt;/h3&gt;&lt;p&gt;在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换(运用一次函数进行的变换)接上一个平移组成。&lt;/p&gt;
&lt;p&gt;CGAffineTransform简单分析（&lt;a href=&quot;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&quot;&gt;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、射变换的种类&quot;&gt;&lt;a href=&quot;#二、射变换的种类&quot; class=&quot;headerlink&quot; title=&quot;二、射变换的种类&quot;&gt;&lt;/a&gt;二、射变换的种类&lt;/h3&gt;&lt;p&gt;1.自定义变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMake(1.0, 0, 0, 1.0, 20, 20);
}];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>property在声明中可以指定的属性</title>
    <link href="http://yoursite.com/2016/09/11/property%E5%9C%A8%E5%A3%B0%E6%98%8E%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/11/property在声明中可以指定的属性/</id>
    <published>2016-09-11T14:18:58.000Z</published>
    <updated>2016-09-11T14:34:54.000Z</updated>
    
    <content type="html">&lt;p&gt;assign, retain, strong, weak, unsafe_unretained, copy &lt;/p&gt;
&lt;p&gt;这些都是一个property在声明中可以指定的属性，且都与内存管理有关。下面会从Non-ARC和ARC两种情况讨论一下这些属性的意义。&lt;/p&gt;
&lt;h3 id=&quot;Non-ARC&quot;&gt;&lt;a href=&quot;#Non-ARC&quot; class=&quot;headerlink&quot; title=&quot;Non-ARC&quot;&gt;&lt;/a&gt;Non-ARC&lt;/h3&gt;&lt;p&gt;从官方文档的描述上看，Non-ARC的内存管理模式下，编译器会为带有不同属性的property自动生成对应的accessor方法。并且苹果十分建议在可能的情况下通过accessor方法来操纵property，而不是操纵它对应的实例变量。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;assign&quot;&gt;&lt;a href=&quot;#assign&quot; class=&quot;headerlink&quot; title=&quot;assign&quot;&gt;&lt;/a&gt;assign&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在Non-ARC内存管理模式下，assign是一个property的默认属性，无论这个property代表一个简单数据类型，还是一个指向对象的指针
也就是说：

@property (nonatomic) NSNumber *count;
等价于：

@property (nonatomic, assign) NSNumber *count;

assign主要应用于代表简单数据类型的property，比如int，float等。
如果这个用assign属性修饰的property代表一个指向对象的指针，那么当这个指针指向某个对象时，这个对象的引用计数不应该被改变。
也就是说，用assign属性修饰的property，不应该持有一个对象。
因为这个property不持有对象，所以它所指向的对象很可能已经在别处被释放了。这时它就有可能成为一枚悬垂指针，访问它指向的内存地址时，可能会发生意想不到的状况。


retain

retain不能修饰用来代表简单数据类型的property，否则编译器会报错：

@property (nonatomic, retain) int num;//编译器报错：Property with &amp;apos;retain (or strong)&amp;apos; attribute must be of object type
如果一个property被retain修饰，这代表着这个property应该持有它所指向的对象。
官方文档中展示了一个被retain修饰的property：

@property (nonatomic, retain) NSNumber *count;

编译器可能为它实现的accessor方法：

- (NSNumber *)count {
    return _count;
}
- (void)setCount:(NSNumber *)newCount {
    [newCount retain];
    [_count release];
    // Make the new assignment.
    _count = newCount;
}

注意，考虑到newCount和_count可能指向同一个对象，所以在setter方法中，必须首先调用retain，以防这个对象被释放。


 copy

copy也不能修饰用来代表简单数据类型的property，否则编译器会报错：

    @property (nonatomic, copy) int num;//编译器报错：Property with &amp;apos;copy&amp;apos; attribute must be of object type

如果一个property被copy修饰，那么赋值到这个property的对象，应该是原有对象的一份拷贝。
只有实现了NSCopying协议，并且实现了其中的copyWithZone:方法的对象才能被拷贝。
但是并不是所有的拷贝都产生了新的对象，有些类在实现copyWithZone:方法时，有着它们自己的考虑。比如NSString：

    @property (nonatomic, copy) NSString *myString;
    NSString *string = [[NSString alloc] initWithString:@&amp;quot;Hello&amp;quot;];
    self.myString = string;
    NSLog(@&amp;quot;%d&amp;quot;, string == _myString);//输出1

在这里，property的指针和原先的指针指向的是同一个地址。

unsafe_unretained

人认为unsafe_unretained与assign是等价的。


strong

个人认为strong与retain是等价的。
官方文档中有这样的示例代码：

// The following declaration is a synonym for: @property(retain) MyClass *myObject;
@property(strong) MyClass *myObject;

表示了strong和retain是同义词。


weak

Non-ARC内存管理模式下无法使用weak来修饰一个property，编译器会报错。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ARC有效时，对象类型的变量将有所有权修饰符来修饰。一共有以下四种所有权修饰符：

__strong 修饰符
__weak 修饰符
__unsafe_unretained 修饰符
__autoreleasing 修饰符

四种修饰符的具体意思，就不在这里解释了(´･_･`)

编译器在为一个property合成实例变量时，也会使用所有权修饰符来修饰这个实例变量。根据property属性的不同，用来修饰实例变量的所有权修饰符也不尽相同。


strong

在ARC内存管理模式下，strong是一个代表对象类型的property的默认属性，并且它不能修饰用来代表简单数据类型的property。
编译器在合成实例变量时，将使用__strong修饰符。
如果另外自定义了用其他修饰符修饰的实例变量，编译器会报错。可以用这个方法来验证property的各个属性对应的实例变量的所有权修饰符。

@interface ViewController ()
{
    __weak NSObject *_obj;//编译器报错：Existing instance variable &amp;apos;_obj&amp;apos; for strong property &amp;apos;obj&amp;apos; may not be weak
}

@property (nonatomic, strong) NSObject *obj;

@end


weak

weak也不能修饰用来代表简单数据类型的property。
编译器将为weak修饰的property生成带__weak所有权修饰符的实例变量。

copy

copy也不能修饰用来代表简单数据类型的property。
编译器将为copy修饰的property生成带__strong所有权修饰符的实例变量。
编译器自动合成的setter方法会调用对象的copyWithZone:方法。虽然第三方程序员可以自定义setter方法，但是为了程序的可读性，
也应该在其中执行拷贝的逻辑。

retain

和Non-ARC的理由一样，个人认为retain和strong是等价的。

unsafe_unretained

编译器将为unsafe_unretained修饰的property生成带__unsafe_unretained所有权修饰符的实例变量。
与weak和strong不同的是，unsafe_unretained也可以修饰代表简单数据类型的property。

assign

个人认为assign和unsafe_unretained等价。
assign在ARC内存管理模式下，仍然是代表简单数据类型的property的默认属性。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;assign, retain, strong, weak, unsafe_unretained, copy &lt;/p&gt;
&lt;p&gt;这些都是一个property在声明中可以指定的属性，且都与内存管理有关。下面会从Non-ARC和ARC两种情况讨论一下这些属性的意义。&lt;/p&gt;
&lt;h3 id=&quot;Non-ARC&quot;&gt;&lt;a href=&quot;#Non-ARC&quot; class=&quot;headerlink&quot; title=&quot;Non-ARC&quot;&gt;&lt;/a&gt;Non-ARC&lt;/h3&gt;&lt;p&gt;从官方文档的描述上看，Non-ARC的内存管理模式下，编译器会为带有不同属性的property自动生成对应的accessor方法。并且苹果十分建议在可能的情况下通过accessor方法来操纵property，而不是操纵它对应的实例变量。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代理设计模式</title>
    <link href="http://yoursite.com/2016/08/28/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/28/代理设计模式/</id>
    <published>2016-08-28T11:56:17.000Z</published>
    <updated>2016-08-28T12:00:01.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;代理delegate就是委托另一个对象来帮忙完成一件事情&lt;/p&gt;
&lt;p&gt;为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如 View 对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是 Controller 的责任，所以此时 View 就应该将这个功能委托给 Controller 去实现，当然你作为码农强行让 View 处理数据逻辑的任务，也不是不行，只是这就违背了 MVC 设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;场景描述如下：TableView 上面有多个 CustomTableViewCell，cell上面显示的是文字信息和一个详情Button，点击button以后push到一个新的页面。为什么说这个场景用到了代理delegate？因为button是在自定义的CustomTableViewCell上面，而cell没有能力实现push的功能，因为push到新页面的代码是这样的，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.navigationController pushViewController...];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以这时候 CustomTableViewCell 就要委托它所在的 Controller 去做这件事情了。&lt;/p&gt;
&lt;h3 id=&quot;代码使用&quot;&gt;&lt;a href=&quot;#代码使用&quot; class=&quot;headerlink&quot; title=&quot;代码使用&quot;&gt;&lt;/a&gt;代码使用&lt;/h3&gt;&lt;p&gt;1.在任意的一个头文件里面编写委托的协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@protocol CustomCellDelegate &amp;lt;NSObject&amp;gt;

 - (void)pushToNewPage;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.在想要发出这份委托的头文件添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface CustomTableViewCell : UITableViewCell

@property(nonatomic, assign) id&amp;lt;CustomCellDelegate&amp;gt; delegate;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.在委托者的 .m 文件的某个需要调用协议方法的方法中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)btnClicked:(UIButton *)btn {

    if (self.delegate &amp;amp;&amp;amp; [self.delegaterespondsToSelector:@selector(pushToNewPage)]) {

      [self.delegate pushToNewPage];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.在受到委托申请的类的头部中添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ViewController ()&amp;lt;CustomCellDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.在然后是委托申请的类中实现CustomCellDelegate协议中的pushToNewPage方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)pushToNewPage {

    DetailViewController*detailVC = [[DetailViewController alloc] init];
    [self.navigationController pushViewController:detailVC animated:YES];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.最后设置CumtomTableViewCell对象cell的delegate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//下面代码很关键
cell.delegate = self;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结：委托的协议可以写在任何的头文件中，代理设计模式的六个步骤缺一不可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;代理delegate就是委托另一个对象来帮忙完成一件事情&lt;/p&gt;
&lt;p&gt;为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如 View 对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是 Controller 的责任，所以此时 View 就应该将这个功能委托给 Controller 去实现，当然你作为码农强行让 View 处理数据逻辑的任务，也不是不行，只是这就违背了 MVC 设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios技能点总结和存取方法</title>
    <link href="http://yoursite.com/2016/08/28/ios%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/28/ios技能点总结和存取方法/</id>
    <published>2016-08-28T11:45:40.000Z</published>
    <updated>2016-08-28T11:52:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;a href=&quot;#存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot; class=&quot;headerlink&quot; title=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;/a&gt;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&lt;/h3&gt;&lt;p&gt;在Cocoa的术语中，一个检索对象属性值的方法提及为getter方法，或者”getter;”，一个改变对象属性值的方法提及为setter方法，或者“setter.”这些方法通常成对建立，提供获得或者设置对象属性值的API。&lt;/p&gt;
&lt;p&gt;我们应该使用存储方法而不是直接存储状态数据因为他们提供了一个抽象的层。下面是存储方法所提供的两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们不需要重写我们的代码如果一个描述或者存储属性的方法改变。&lt;/li&gt;
&lt;li&gt;存储方法常常实现重要行为是无论何时一个值被检索或者设置都会被重现。例如，设置方法频繁的实现内存管理代码并且通知其他对象当一个值被改变的时候。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h3&gt;&lt;p&gt;给出一个属性的类型type和称呼name，我们应该通过下面的格式，典型的实现存储方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(type)name;
-(void)setName:(type)newName;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有个例外是属性为Boolean值。getter方法名字应该是isName。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(BOOL)isHidden;
-(void)setHidden:(BOOL)newHidden;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种命名惯例很重要因为在Cocoa中的很多其他的功能都依赖它，特别的key-value coding。Cocoa不使用getName因为以get开始的方法表明方法返回引用类型的值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) 报错：__NSCFString containsString:]: unrecognized selector sent to instance 0x7f876b79e160&lt;/p&gt;
&lt;p&gt; 原因：因为该属性提前释放了。&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) 报错：This application is modifying the autolayout engine from a background thread&lt;/p&gt;
&lt;p&gt;原因：把需要更新UI的放在的主线程就好了。（通过打印 [NSThreadcurrentThread],就可以知道当前不是在主线程;&lt;/p&gt;
&lt;p&gt; NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:@”value1”, @”key1”, @”value2”, @”key2”, nil];&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) Dealloc 时取 weak self 时崩溃  （&lt;a href=&quot;http://blog.csdn.net/kaihaodir/article/details/51586616）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kaihaodir/article/details/51586616）&lt;/a&gt;&lt;br&gt;    先上引起崩溃的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc
{
    __weak __typeof(self)weak_self = self;
    NSLog(@&amp;quot;%@&amp;quot;, weak_self);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明不允许在 dealloc 的时候取 weak self.&lt;/p&gt;
&lt;h3 id=&quot;获取当前年份和月份和天数&quot;&gt;&lt;a href=&quot;#获取当前年份和月份和天数&quot; class=&quot;headerlink&quot; title=&quot;获取当前年份和月份和天数&quot;&gt;&lt;/a&gt;获取当前年份和月份和天数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSCalendar *calendar = [NSCalendar currentCalendar];
unsigned unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit |  NSDayCalendarUnit;
NSDateComponents *components = [calendar components:unitFlags fromDate:[NSDate date]];
NSInteger iCurYear = [components year];  //当前的年份
NSInteger iCurMonth = [components month];  //当前的月份
NSInteger iCurDay = [components day];  // 当前的号数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;根据传入的年份和月份获得该月份的天数&quot;&gt;&lt;a href=&quot;#根据传入的年份和月份获得该月份的天数&quot; class=&quot;headerlink&quot; title=&quot;根据传入的年份和月份获得该月份的天数&quot;&gt;&lt;/a&gt;根据传入的年份和月份获得该月份的天数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**  
 * 根据传入的年份和月份获得该月份的天数  
 *   
 * @param year  
 *            年份-正整数  
 * @param month  
 *            月份-正整数  
 * @return 返回天数  
 */    
public int getDayNumber(int year, int month) {    
    int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };    
    if (2 == month &amp;amp;&amp;amp; 0 == (year % 4) &amp;amp;&amp;amp; (0 != (year % 100) || 0 == (year % 400))) {    
        days[1] = 29;    
    }    
    return (days[month - 1]);    
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;a href=&quot;#存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot; class=&quot;headerlink&quot; title=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;/a&gt;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&lt;/h3&gt;&lt;p&gt;在Cocoa的术语中，一个检索对象属性值的方法提及为getter方法，或者”getter;”，一个改变对象属性值的方法提及为setter方法，或者“setter.”这些方法通常成对建立，提供获得或者设置对象属性值的API。&lt;/p&gt;
&lt;p&gt;我们应该使用存储方法而不是直接存储状态数据因为他们提供了一个抽象的层。下面是存储方法所提供的两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们不需要重写我们的代码如果一个描述或者存储属性的方法改变。&lt;/li&gt;
&lt;li&gt;存储方法常常实现重要行为是无论何时一个值被检索或者设置都会被重现。例如，设置方法频繁的实现内存管理代码并且通知其他对象当一个值被改变的时候。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block的使用</title>
    <link href="http://yoursite.com/2016/08/28/block%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/08/28/block的使用/</id>
    <published>2016-08-28T11:40:33.000Z</published>
    <updated>2016-08-28T11:42:30.000Z</updated>
    
    <content type="html">&lt;p&gt;Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了.&lt;/p&gt;
&lt;h3 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;h4 id=&quot;As-a-local-variable&quot;&gt;&lt;a href=&quot;#As-a-local-variable&quot; class=&quot;headerlink&quot; title=&quot;As a local variable:&quot;&gt;&lt;/a&gt;As a local variable:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;As-a-property&quot;&gt;&lt;a href=&quot;#As-a-property&quot; class=&quot;headerlink&quot; title=&quot;As a property:&quot;&gt;&lt;/a&gt;As a property:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-a-method-parameter&quot;&gt;&lt;a href=&quot;#As-a-method-parameter&quot; class=&quot;headerlink&quot; title=&quot;As a method parameter:&quot;&gt;&lt;/a&gt;As a method parameter:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-an-argument-to-a-method-call&quot;&gt;&lt;a href=&quot;#As-an-argument-to-a-method-call&quot; class=&quot;headerlink&quot; title=&quot;As an argument to a method call:&quot;&gt;&lt;/a&gt;As an argument to a method call:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-a-typedef&quot;&gt;&lt;a href=&quot;#As-a-typedef&quot; class=&quot;headerlink&quot; title=&quot;As a typedef:&quot;&gt;&lt;/a&gt;As a typedef:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;typedef returnType (^TypeName)(parameterTypes);
TypeName blockName = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
@interface ViewController ()

@property (nonatomic, assign) void (^block)(NSString *);

@end

typedef void (^block)(NSString *);
typedef NSString *(^block2)(NSString *);

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    int (^num)(int) = ^(int a) {

        return a * 6;
    };
    NSLog(@&amp;quot;%d&amp;quot;, num(5));

    block b = ^(NSString *string) {

        NSLog(@&amp;quot;%@&amp;quot;, string);
    };
    b(@&amp;quot;4677646974&amp;quot;);

    block2 b2 = ^(NSString *string) {
        NSLog(@&amp;quot;%@&amp;quot;, string);
        return string;
    };
    NSLog(@&amp;quot;%@&amp;quot;, b2(@&amp;quot;456&amp;quot;));

    [self methodsBlock:^(NSString *block3) {

        NSLog(@&amp;quot;%@&amp;quot;, block3);
    }];

    [self methodsBlock2:^NSString *(NSString *block4) {

        NSLog(@&amp;quot;%@&amp;quot;, block4);
        return @&amp;quot;1&amp;quot;;
    }];
    NSLog(@&amp;quot;%@&amp;quot;, [self methodsBlock3:^NSString *(NSString *block5) {
        NSLog(@&amp;quot;%@&amp;quot;, block5);
        return @&amp;quot;2&amp;quot;;
    }]);

    int (^num2)(int, int, int, int, int, int, int) = ^(int a, int b, int c, int d, int e, int f, int g) {

        return a * b * c * d * e * f * g;
    };
    NSLog(@&amp;quot;num2 = %d&amp;quot;, num2(10, 2, 5, 1, 45, 4, 4));


}

- (void)methodsBlock:(void(^)(NSString *))block3 {

    block3(@&amp;quot;block3&amp;quot;);
}


- (void)methodsBlock2:(NSString *(^)(NSString *))block4 {

    block4(@&amp;quot;block4&amp;quot;);
    NSLog(@&amp;quot;%@&amp;quot;, block4(@&amp;quot;block4&amp;quot;));
}


- (NSString *)methodsBlock3:(NSString *(^ __nullable)(NSString *))block5 {

    block5(@&amp;quot;block5&amp;quot;);
    NSLog(@&amp;quot;block5 = %@&amp;quot;, block5(@&amp;quot;block5&amp;quot;));
    return @&amp;quot;block5&amp;quot;;
}
@end
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了.&lt;/p&gt;
&lt;h3 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;h4 id=&quot;As-a-local-variable&quot;&gt;&lt;a href=&quot;#As-a-local-variable&quot; class=&quot;headerlink&quot; title=&quot;As a local variable:&quot;&gt;&lt;/a&gt;As a local variable:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
