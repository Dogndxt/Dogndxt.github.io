<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>第欧根尼的小桶</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-19T11:19:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>第欧根尼的小桶</name>
    <email>abc2504111083@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发使用系统的拷贝剪切功能</title>
    <link href="http://yoursite.com/2016/10/19/iOS%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%89%AA%E5%88%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2016/10/19/iOS开发使用系统的拷贝剪切功能/</id>
    <published>2016-10-19T11:15:58.000Z</published>
    <updated>2016-10-19T11:19:30.000Z</updated>
    
    <content type="html">&lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2）响应事件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//并加上几个方法
-(void)longPressCellHandle:(UILongPressGestureRecognizer *)gesture {

    [self becomeFirstResponder];
    UIMenuController *menuController = [UIMenuController sharedMenuController];
    UIMenuItem *copyItem = [[UIMenuItem alloc] initWithTitle:@&amp;quot;复制&amp;quot; action:@selector(menuCopyBtnPressed:)];
    menuController.menuItems = @[copyItem];
    [menuController setTargetRect:gesture.view.frame inView:gesture.view.superview];
    [menuController setMenuVisible:YES animated:YES];
    [UIMenuController sharedMenuController].menuItems=nil;
}

// 将要复制的内容复制到系统的剪贴板
- (void)menuCopyBtnPressed:(UIMenuItem *)menuItem {
    //  通用的粘贴板
    [UIPasteboard generalPasteboard].string = self.messageLab.text;
}

- (BOOL)canBecomeFirstResponder {

    return YES;
}

- (BOOL)canPerformAction:(SEL)action withSender:(id)sender {

    if (action == @selector(menuCopyBtnPressed:)) {
        return YES;
    }
    return NO;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;自定义(这里主要是改掉系统拷贝的名字为复制) &lt;a href=&quot;http://www.jianshu.com/p/557530bcd417&quot;&gt;http://www.jianshu.com/p/557530bcd417&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1)添加手势&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//在自定义cell中的init方法加入
UILongPressGestureRecognizer *longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPressCellHandle:)];
self.longGesture = longPressGesture;
[self addGestureRecognizer:longPressGesture];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS开发之旅之懒加载</title>
    <link href="http://yoursite.com/2016/10/18/iOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85%E4%B9%8B%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2016/10/18/iOS开发之旅之懒加载/</id>
    <published>2016-10-18T14:54:55.000Z</published>
    <updated>2016-10-18T14:56:00.000Z</updated>
    
    <content type="html">&lt;p&gt;懒加载定义：延时加载，即当对象需要用到的时候再去加载。其实就是所谓的重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。&lt;/p&gt;
&lt;p&gt;需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)shopData {

    if (!_shopData) {
        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];
    }
    return _shopData;
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;懒加载的优点&lt;/p&gt;
&lt;p&gt;1）不需将对象的实例化写到viewDidLoad，可以简化代码，增强代码的可读性&lt;br&gt;2）对象的实例化在 getter 方法中，各司其职，降低耦合性&lt;br&gt;3）对系统的内存占用率会减小&lt;/p&gt;
&lt;p&gt;总结：懒加载即用到时方去加载对象&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;懒加载定义：延时加载，即当对象需要用到的时候再去加载。其实就是所谓的重写对象的get方法,当系统或者开发者调用对象的get方法时，再去加载对象。&lt;/p&gt;
&lt;p&gt;需要注意：重写get方法时，先判断对象当前是否为空，为空的话再去实例化对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (NSArray *)shopData {

    if (!_shopData) {
        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];
    }
    return _shopData;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>initWithFrame方法的理解</title>
    <link href="http://yoursite.com/2016/09/28/initWithFrame%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2016/09/28/initWithFrame方法的理解/</id>
    <published>2016-09-28T11:33:37.000Z</published>
    <updated>2016-09-28T11:36:38.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;initWithFrame方法是什么？&quot;&gt;&lt;a href=&quot;#initWithFrame方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;initWithFrame方法是什么？&quot;&gt;&lt;/a&gt;initWithFrame方法是什么？&lt;/h4&gt;&lt;p&gt;initWithFrame方法用来初始化并返回一个新的视图对象,根据指定的CGRect（尺寸）。&lt;/p&gt;
&lt;h4 id=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;a href=&quot;#什么时候用initWithFrame方法？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;/a&gt;什么时候用initWithFrame方法？&lt;/h4&gt;&lt;p&gt;简单的说，我们用编程方式申明，创建UIView对象时，使用initWithFrame方法。&lt;br&gt;在此，我们必须搞清楚，两种方式来进行初始化UIView。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-使用-Interface-Builder-方式&quot;&gt;&lt;a href=&quot;#1-使用-Interface-Builder-方式&quot; class=&quot;headerlink&quot; title=&quot;1) 使用 Interface Builder 方式&quot;&gt;&lt;/a&gt;1) 使用 Interface Builder 方式&lt;/h4&gt;&lt;p&gt; 这种方式，就是使用nib文件。通常我们说的“拖控件” 的方式。&lt;/p&gt;
&lt;p&gt;实际编程中，我们如果用Interface Builder 方式创建了UIView对象。（也就是，用拖控件的方式）&lt;br&gt;那么，initWithFrame方法方法是不会被调用的。因为nib文件已经知道如何初始化该View。（因为，我们在拖该view的时候，就定义好了长、宽、背景等属性）。&lt;br&gt;这时候，会调用initWithCoder方法，我们可以用initWithCoder方法来重新定义我们在nib中已经设置的各项属性。&lt;/p&gt;
&lt;h4 id=&quot;2-使用编程方式&quot;&gt;&lt;a href=&quot;#2-使用编程方式&quot; class=&quot;headerlink&quot; title=&quot;2) 使用编程方式&quot;&gt;&lt;/a&gt;2) 使用编程方式&lt;/h4&gt;&lt;p&gt;实际编程中，我们使用编程方式下，来创建一个UIView或者创建UIView的子类。这时候，将调用initWithFrame方法，来实例化UIView。&lt;br&gt;特别注意，如果在子类中重载initWithFrame方法，必须先调用父类的initWithFrame方法。在对自定义的UIView子类进行初始化操作。&lt;br&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (id)initWithFrame:(CGRect)frame{
    self = [super initWithFrame:frame];// 先调用父类的initWithFrame方法
    if (self) {

        // 再自定义该类（UIView子类）的初始化操作。
        _scrollView = [[UIScrollView alloc] initWithFrame:self.bounds];
        [_scrollView setFrame:CGRectMake(0, 0, 320, 480)];
        _scrollView.contentSize = CGSizeMake(320*3, 480);

        [self addSubview:_scrollView];
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;那么，用Interface-Builder-方式创建的nib文件是什么？&quot;&gt;&lt;a href=&quot;#那么，用Interface-Builder-方式创建的nib文件是什么？&quot; class=&quot;headerlink&quot; title=&quot;那么，用Interface Builder 方式创建的nib文件是什么？&quot;&gt;&lt;/a&gt;那么，用Interface Builder 方式创建的nib文件是什么？&lt;/h4&gt;&lt;p&gt;对于应用程序，资源是一种数据文件，伴随可程序执行程序的一种数据文件。（可以理解为可执行程序的，一种不可缺少的组陈部分）。&lt;br&gt;资源文件，是一种可移动的，由适合的工具编写的一种特殊的代码。&lt;br&gt;如：plish文件，txt文件，图像，视频等文件。都可以被xCode识别和引用。&lt;/p&gt;
&lt;p&gt;一个应用程序可以包含多种形式的资源文件。&lt;/p&gt;
&lt;p&gt;当然，nib文件也不例外，仅仅是一种资源文件。&lt;br&gt;通过Interface Builder 方式，可以创建nib文件，存储应用程序的UI对象。供应用程序来读取。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;initWithFrame方法是什么？&quot;&gt;&lt;a href=&quot;#initWithFrame方法是什么？&quot; class=&quot;headerlink&quot; title=&quot;initWithFrame方法是什么？&quot;&gt;&lt;/a&gt;initWithFrame方法是什么？&lt;/h4&gt;&lt;p&gt;initWithFrame方法用来初始化并返回一个新的视图对象,根据指定的CGRect（尺寸）。&lt;/p&gt;
&lt;h4 id=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;a href=&quot;#什么时候用initWithFrame方法？&quot; class=&quot;headerlink&quot; title=&quot;什么时候用initWithFrame方法？&quot;&gt;&lt;/a&gt;什么时候用initWithFrame方法？&lt;/h4&gt;&lt;p&gt;简单的说，我们用编程方式申明，创建UIView对象时，使用initWithFrame方法。&lt;br&gt;在此，我们必须搞清楚，两种方式来进行初始化UIView。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> NSString 字符串处理</title>
    <link href="http://yoursite.com/2016/09/22/NSString-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/09/22/NSString-字符串处理/</id>
    <published>2016-09-22T14:39:16.000Z</published>
    <updated>2016-09-22T14:40:10.000Z</updated>
    
    <content type="html">&lt;p&gt;iphone NSString 字符串处理：截取字符串、匹配字符串、分隔字符串    &lt;/p&gt;
&lt;p&gt;1.截取字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
string = [string substringToIndex:7];//截取掉下标7之后的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
[string substringFromIndex:2];//截取掉下标2之前的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.匹配字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSRange range = [stringrangeOfString:@&amp;quot;f&amp;quot;];//匹配得到的下标
NSLog(@&amp;quot;rang:%@&amp;quot;,NSStringFromRange(range));
string = [string substringWithRange:range];//截取范围类的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.分隔字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString *string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
NSArray *array = [string componentsSeparatedByString:@&amp;quot;A&amp;quot;]; //从字符A中分隔成2个元素的数组
NSLog(@&amp;quot;array:%@&amp;quot;,array); //结果是adfsfsfs和dfsdf
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;iphone NSString 字符串处理：截取字符串、匹配字符串、分隔字符串    &lt;/p&gt;
&lt;p&gt;1.截取字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSString*string = @&amp;quot;sdfsfsfsAdfsdf&amp;quot;;
string = [string substringToIndex:7];//截取掉下标7之后的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
[string substringFromIndex:2];//截取掉下标2之前的字符串
NSLog(@&amp;quot;截取的值为：%@&amp;quot;,string);
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>UISlide属性</title>
    <link href="http://yoursite.com/2016/09/22/UISlide%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/22/UISlide属性/</id>
    <published>2016-09-22T14:39:02.000Z</published>
    <updated>2016-09-22T14:43:35.000Z</updated>
    
    <content type="html">&lt;p&gt;1.minimumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最小位置的值，默认为0.0

_slider.minimumValue = 10.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.maximumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最大位置的值，默认为1.0

_slider.maximumValue = 100.0;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;3.continuous &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如果设置YES，在拖动滑块的任何时候，滑块的值都会改变。默认设置为YES

[_slider setContinuous:NO]; // 在滑块滑动结束时才获取滑块的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.minimumValueImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最小值处设置的图片，默认为nil

_slider.minimumValueImage = [UIImage imageNamed:@&amp;quot;003.png&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.maximumValueImage&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最大值处设置的图片,默认为nil

_slider.maximumValueImage = [UIImage imageNamed:@&amp;quot;002.png&amp;quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.minimumTrackTintColor :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;小于滑块当前值滑块条的颜色，默认为蓝色

_slider.minimumTrackTintColor = [UIColor redColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.maximumTrackTintColor:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大于滑块当前值滑块条的颜色，默认为白色

_slider.maximumTrackTintColor = [UIColor greenColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.thumbTintColor :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当前滑块的颜色，默认为白色

_slider.thumbTintColor = [UIColor yellowColor];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9.currentMaximumTrackImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最大值处设置的图片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;10.currentMinimumTrackImage &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;滑块条最小值处设置的图片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;11.currentThumbImage&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当前滑块的图片
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;1.minimumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最小位置的值，默认为0.0

_slider.minimumValue = 10.0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.maximumValue &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;当值可以改变时，滑块可以滑动到最大位置的值，默认为1.0

_slider.maximumValue = 100.0;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用 AFNetworking 监听网络状态</title>
    <link href="http://yoursite.com/2016/09/22/%E5%88%A9%E7%94%A8-AFNetworking-%E7%9B%91%E5%90%AC%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2016/09/22/利用-AFNetworking-监听网络状态/</id>
    <published>2016-09-22T14:33:42.000Z</published>
    <updated>2016-09-22T14:37:46.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;1-创建网络监听者管理者对象&quot;&gt;&lt;a href=&quot;#1-创建网络监听者管理者对象&quot; class=&quot;headerlink&quot; title=&quot;1.创建网络监听者管理者对象&quot;&gt;&lt;/a&gt;1.创建网络监听者管理者对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-设置监听&quot;&gt;&lt;a href=&quot;#2-设置监听&quot; class=&quot;headerlink&quot; title=&quot;2.设置监听&quot;&gt;&lt;/a&gt;2.设置监听&lt;/h3&gt;&lt;p&gt;1)网络状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//显然是枚举值
typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,//未识别的网络
    AFNetworkReachabilityStatusNotReachable     = 0,//不可达的网络
    AFNetworkReachabilityStatusReachableViaWWAN = 1,//2G,3G,4G...
    AFNetworkReachabilityStatusReachableViaWiFi = 2,//wifi网络
    }
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2)设置网络监听&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
    switch (status) {
        case AFNetworkReachabilityStatusUnknown:
            NSLog(@&amp;quot;未识别的网络&amp;quot;);
            break;

        case AFNetworkReachabilityStatusNotReachable:
            NSLog(@&amp;quot;不可达的网络(未连接)&amp;quot;);
            break;

        case AFNetworkReachabilityStatusReachableViaWWAN:
            NSLog(@&amp;quot;2G,3G,4G...的网络&amp;quot;);
            break;

        case AFNetworkReachabilityStatusReachableViaWiFi:
            NSLog(@&amp;quot;wifi的网络&amp;quot;);
            break;
        default:
            break;
    }
}];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;3-开始监听&quot;&gt;&lt;a href=&quot;#3-开始监听&quot; class=&quot;headerlink&quot; title=&quot;3.开始监听&quot;&gt;&lt;/a&gt;3.开始监听&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[manager startMonitoring];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-创建网络监听者管理者对象&quot;&gt;&lt;a href=&quot;#1-创建网络监听者管理者对象&quot; class=&quot;headerlink&quot; title=&quot;1.创建网络监听者管理者对象&quot;&gt;&lt;/a&gt;1.创建网络监听者管理者对象&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;2-设置监听&quot;&gt;&lt;a href=&quot;#2-设置监听&quot; class=&quot;headerlink&quot; title=&quot;2.设置监听&quot;&gt;&lt;/a&gt;2.设置监听&lt;/h3&gt;&lt;p&gt;1)网络状态&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//显然是枚举值
typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) {
    AFNetworkReachabilityStatusUnknown          = -1,//未识别的网络
    AFNetworkReachabilityStatusNotReachable     = 0,//不可达的网络
    AFNetworkReachabilityStatusReachableViaWWAN = 1,//2G,3G,4G...
    AFNetworkReachabilityStatusReachableViaWiFi = 2,//wifi网络
    }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>仿射变换(CGAffineTransform)使用小结</title>
    <link href="http://yoursite.com/2016/09/22/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2-CGAffineTransform-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2016/09/22/仿射变换-CGAffineTransform-使用小结/</id>
    <published>2016-09-22T14:28:02.000Z</published>
    <updated>2016-09-22T14:32:43.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;一、理论基础&lt;/h3&gt;&lt;p&gt;在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换(运用一次函数进行的变换)接上一个平移组成。&lt;/p&gt;
&lt;p&gt;CGAffineTransform简单分析（&lt;a href=&quot;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、射变换的种类&quot;&gt;&lt;a href=&quot;#二、射变换的种类&quot; class=&quot;headerlink&quot; title=&quot;二、射变换的种类&quot;&gt;&lt;/a&gt;二、射变换的种类&lt;/h3&gt;&lt;p&gt;1.自定义变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMake(1.0, 0, 0, 1.0, 20, 20);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;2.平移&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; x &amp;gt; 0 右边  x &amp;lt; 0 左边
 y &amp;gt; 0 下边  y &amp;lt; 0 上边 
 _demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeTranslation(100, -50);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.缩放      x 轴缩放 ， y 轴缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeScale(2, 0.5);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.旋转     angle &amp;gt; 0 顺时针 ， angle &amp;lt; 0逆时针&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
   _demoView.transform = CGAffineTransformMakeRotation(20);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.旋转 ＋ 平移 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeRotation(20);
}];
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformTranslate(_demoView.transform, 150, 150);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.旋转 ＋ 缩放&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMakeRotation(20);
    //        NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformIsIdentity(_demoView.transform));
}];
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformScale(_demoView.transform, 0.5, 2);
    //        NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformIsIdentity(_demoView.transform));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7.相反 （逆旋转，逆移动等）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformInvert(CGAffineTransformMakeRotation(20));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.合并多个变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformConcat(CGAffineTransformMakeRotation(20), CGAffineTransformScale(_demoView.transform, 0.5, 2));
    NSLog(@&amp;quot;%d&amp;quot;, CGAffineTransformEqualToTransform(CGAffineTransformMakeRotation(20), CGAffineTransformScale(_demoView.transform, 0.5, 2)));
}];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;三、补充&quot;&gt;&lt;a href=&quot;#三、补充&quot; class=&quot;headerlink&quot; title=&quot;三、补充&quot;&gt;&lt;/a&gt;三、补充&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;CGAffineTransformIdentity ： 单位矩阵变换，一般用于仿射变换的初始化或者还原。
CGAffineTransformEqualToTransform(CGAffineTransform t1, CGAffineTransform t2) ： 判断两个变换矩阵是否相等
CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2) ： 得到两个矩阵相加后得到的最终矩阵
CGPoint CGPointApplyAffineTransform(CGPoint point, CGAffineTransform t) ： 某点通过矩阵变换之后的点
CGSize CGSizeApplyAffineTransform(CGSize size, CGAffineTransform t) ： 某个size通过矩阵变换之后的size
CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform t) ： 某个Rect通过矩阵变换之后的区域
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、理论基础&quot;&gt;&lt;a href=&quot;#一、理论基础&quot; class=&quot;headerlink&quot; title=&quot;一、理论基础&quot;&gt;&lt;/a&gt;一、理论基础&lt;/h3&gt;&lt;p&gt;在几何上定义为两个向量空间之间的一个仿射变换或者仿射映射由一个线性变换(运用一次函数进行的变换)接上一个平移组成。&lt;/p&gt;
&lt;p&gt;CGAffineTransform简单分析（&lt;a href=&quot;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&quot;&gt;http://xummer26.com/blog/CGAffineTransform-simple-analysis.html）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二、射变换的种类&quot;&gt;&lt;a href=&quot;#二、射变换的种类&quot; class=&quot;headerlink&quot; title=&quot;二、射变换的种类&quot;&gt;&lt;/a&gt;二、射变换的种类&lt;/h3&gt;&lt;p&gt;1.自定义变换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;_demoView.transform = CGAffineTransformIdentity;
[UIView animateWithDuration:1.5f animations:^{
    _demoView.transform = CGAffineTransformMake(1.0, 0, 0, 1.0, 20, 20);
}];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>property在声明中可以指定的属性</title>
    <link href="http://yoursite.com/2016/09/11/property%E5%9C%A8%E5%A3%B0%E6%98%8E%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2016/09/11/property在声明中可以指定的属性/</id>
    <published>2016-09-11T14:18:58.000Z</published>
    <updated>2016-09-11T14:34:54.000Z</updated>
    
    <content type="html">&lt;p&gt;assign, retain, strong, weak, unsafe_unretained, copy &lt;/p&gt;
&lt;p&gt;这些都是一个property在声明中可以指定的属性，且都与内存管理有关。下面会从Non-ARC和ARC两种情况讨论一下这些属性的意义。&lt;/p&gt;
&lt;h3 id=&quot;Non-ARC&quot;&gt;&lt;a href=&quot;#Non-ARC&quot; class=&quot;headerlink&quot; title=&quot;Non-ARC&quot;&gt;&lt;/a&gt;Non-ARC&lt;/h3&gt;&lt;p&gt;从官方文档的描述上看，Non-ARC的内存管理模式下，编译器会为带有不同属性的property自动生成对应的accessor方法。并且苹果十分建议在可能的情况下通过accessor方法来操纵property，而不是操纵它对应的实例变量。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;assign&quot;&gt;&lt;a href=&quot;#assign&quot; class=&quot;headerlink&quot; title=&quot;assign&quot;&gt;&lt;/a&gt;assign&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;在Non-ARC内存管理模式下，assign是一个property的默认属性，无论这个property代表一个简单数据类型，还是一个指向对象的指针
也就是说：

@property (nonatomic) NSNumber *count;
等价于：

@property (nonatomic, assign) NSNumber *count;

assign主要应用于代表简单数据类型的property，比如int，float等。
如果这个用assign属性修饰的property代表一个指向对象的指针，那么当这个指针指向某个对象时，这个对象的引用计数不应该被改变。
也就是说，用assign属性修饰的property，不应该持有一个对象。
因为这个property不持有对象，所以它所指向的对象很可能已经在别处被释放了。这时它就有可能成为一枚悬垂指针，访问它指向的内存地址时，可能会发生意想不到的状况。


retain

retain不能修饰用来代表简单数据类型的property，否则编译器会报错：

@property (nonatomic, retain) int num;//编译器报错：Property with &amp;apos;retain (or strong)&amp;apos; attribute must be of object type
如果一个property被retain修饰，这代表着这个property应该持有它所指向的对象。
官方文档中展示了一个被retain修饰的property：

@property (nonatomic, retain) NSNumber *count;

编译器可能为它实现的accessor方法：

- (NSNumber *)count {
    return _count;
}
- (void)setCount:(NSNumber *)newCount {
    [newCount retain];
    [_count release];
    // Make the new assignment.
    _count = newCount;
}

注意，考虑到newCount和_count可能指向同一个对象，所以在setter方法中，必须首先调用retain，以防这个对象被释放。


 copy

copy也不能修饰用来代表简单数据类型的property，否则编译器会报错：

    @property (nonatomic, copy) int num;//编译器报错：Property with &amp;apos;copy&amp;apos; attribute must be of object type

如果一个property被copy修饰，那么赋值到这个property的对象，应该是原有对象的一份拷贝。
只有实现了NSCopying协议，并且实现了其中的copyWithZone:方法的对象才能被拷贝。
但是并不是所有的拷贝都产生了新的对象，有些类在实现copyWithZone:方法时，有着它们自己的考虑。比如NSString：

    @property (nonatomic, copy) NSString *myString;
    NSString *string = [[NSString alloc] initWithString:@&amp;quot;Hello&amp;quot;];
    self.myString = string;
    NSLog(@&amp;quot;%d&amp;quot;, string == _myString);//输出1

在这里，property的指针和原先的指针指向的是同一个地址。

unsafe_unretained

人认为unsafe_unretained与assign是等价的。


strong

个人认为strong与retain是等价的。
官方文档中有这样的示例代码：

// The following declaration is a synonym for: @property(retain) MyClass *myObject;
@property(strong) MyClass *myObject;

表示了strong和retain是同义词。


weak

Non-ARC内存管理模式下无法使用weak来修饰一个property，编译器会报错。
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ARC&quot;&gt;&lt;a href=&quot;#ARC&quot; class=&quot;headerlink&quot; title=&quot;ARC&quot;&gt;&lt;/a&gt;ARC&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;ARC有效时，对象类型的变量将有所有权修饰符来修饰。一共有以下四种所有权修饰符：

__strong 修饰符
__weak 修饰符
__unsafe_unretained 修饰符
__autoreleasing 修饰符

四种修饰符的具体意思，就不在这里解释了(´･_･`)

编译器在为一个property合成实例变量时，也会使用所有权修饰符来修饰这个实例变量。根据property属性的不同，用来修饰实例变量的所有权修饰符也不尽相同。


strong

在ARC内存管理模式下，strong是一个代表对象类型的property的默认属性，并且它不能修饰用来代表简单数据类型的property。
编译器在合成实例变量时，将使用__strong修饰符。
如果另外自定义了用其他修饰符修饰的实例变量，编译器会报错。可以用这个方法来验证property的各个属性对应的实例变量的所有权修饰符。

@interface ViewController ()
{
    __weak NSObject *_obj;//编译器报错：Existing instance variable &amp;apos;_obj&amp;apos; for strong property &amp;apos;obj&amp;apos; may not be weak
}

@property (nonatomic, strong) NSObject *obj;

@end


weak

weak也不能修饰用来代表简单数据类型的property。
编译器将为weak修饰的property生成带__weak所有权修饰符的实例变量。

copy

copy也不能修饰用来代表简单数据类型的property。
编译器将为copy修饰的property生成带__strong所有权修饰符的实例变量。
编译器自动合成的setter方法会调用对象的copyWithZone:方法。虽然第三方程序员可以自定义setter方法，但是为了程序的可读性，
也应该在其中执行拷贝的逻辑。

retain

和Non-ARC的理由一样，个人认为retain和strong是等价的。

unsafe_unretained

编译器将为unsafe_unretained修饰的property生成带__unsafe_unretained所有权修饰符的实例变量。
与weak和strong不同的是，unsafe_unretained也可以修饰代表简单数据类型的property。

assign

个人认为assign和unsafe_unretained等价。
assign在ARC内存管理模式下，仍然是代表简单数据类型的property的默认属性。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;assign, retain, strong, weak, unsafe_unretained, copy &lt;/p&gt;
&lt;p&gt;这些都是一个property在声明中可以指定的属性，且都与内存管理有关。下面会从Non-ARC和ARC两种情况讨论一下这些属性的意义。&lt;/p&gt;
&lt;h3 id=&quot;Non-ARC&quot;&gt;&lt;a href=&quot;#Non-ARC&quot; class=&quot;headerlink&quot; title=&quot;Non-ARC&quot;&gt;&lt;/a&gt;Non-ARC&lt;/h3&gt;&lt;p&gt;从官方文档的描述上看，Non-ARC的内存管理模式下，编译器会为带有不同属性的property自动生成对应的accessor方法。并且苹果十分建议在可能的情况下通过accessor方法来操纵property，而不是操纵它对应的实例变量。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>代理设计模式</title>
    <link href="http://yoursite.com/2016/08/28/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/08/28/代理设计模式/</id>
    <published>2016-08-28T11:56:17.000Z</published>
    <updated>2016-08-28T12:00:01.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;代理delegate就是委托另一个对象来帮忙完成一件事情&lt;/p&gt;
&lt;p&gt;为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如 View 对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是 Controller 的责任，所以此时 View 就应该将这个功能委托给 Controller 去实现，当然你作为码农强行让 View 处理数据逻辑的任务，也不是不行，只是这就违背了 MVC 设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h3&gt;&lt;p&gt;场景描述如下：TableView 上面有多个 CustomTableViewCell，cell上面显示的是文字信息和一个详情Button，点击button以后push到一个新的页面。为什么说这个场景用到了代理delegate？因为button是在自定义的CustomTableViewCell上面，而cell没有能力实现push的功能，因为push到新页面的代码是这样的，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[self.navigationController pushViewController...];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以这时候 CustomTableViewCell 就要委托它所在的 Controller 去做这件事情了。&lt;/p&gt;
&lt;h3 id=&quot;代码使用&quot;&gt;&lt;a href=&quot;#代码使用&quot; class=&quot;headerlink&quot; title=&quot;代码使用&quot;&gt;&lt;/a&gt;代码使用&lt;/h3&gt;&lt;p&gt;1.在任意的一个头文件里面编写委托的协议&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@protocol CustomCellDelegate &amp;lt;NSObject&amp;gt;

 - (void)pushToNewPage;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.在想要发出这份委托的头文件添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface CustomTableViewCell : UITableViewCell

@property(nonatomic, assign) id&amp;lt;CustomCellDelegate&amp;gt; delegate;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.在委托者的 .m 文件的某个需要调用协议方法的方法中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)btnClicked:(UIButton *)btn {

    if (self.delegate &amp;amp;&amp;amp; [self.delegaterespondsToSelector:@selector(pushToNewPage)]) {

      [self.delegate pushToNewPage];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.在受到委托申请的类的头部中添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@interface ViewController ()&amp;lt;CustomCellDelegate&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.在然后是委托申请的类中实现CustomCellDelegate协议中的pushToNewPage方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)pushToNewPage {

    DetailViewController*detailVC = [[DetailViewController alloc] init];
    [self.navigationController pushViewController:detailVC animated:YES];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.最后设置CumtomTableViewCell对象cell的delegate&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//下面代码很关键
cell.delegate = self;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总结：委托的协议可以写在任何的头文件中，代理设计模式的六个步骤缺一不可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代理设计模式&quot;&gt;&lt;a href=&quot;#代理设计模式&quot; class=&quot;headerlink&quot; title=&quot;代理设计模式&quot;&gt;&lt;/a&gt;代理设计模式&lt;/h3&gt;&lt;p&gt;代理delegate就是委托另一个对象来帮忙完成一件事情&lt;/p&gt;
&lt;p&gt;为什么要委托别人来做呢，这其实是MVC设计模式中的模块分工问题，例如 View 对象它只负责显示界面，而不需要进行数据的管理，数据的管理和逻辑是 Controller 的责任，所以此时 View 就应该将这个功能委托给 Controller 去实现，当然你作为码农强行让 View 处理数据逻辑的任务，也不是不行，只是这就违背了 MVC 设计模式，项目小还好，随着功能的扩展，我们就会发现越写越难写；还有一种情况，就是这件事情做不到，只能委托给其他对象来做了.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ios技能点总结和存取方法</title>
    <link href="http://yoursite.com/2016/08/28/ios%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%93%E5%92%8C%E5%AD%98%E5%8F%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/28/ios技能点总结和存取方法/</id>
    <published>2016-08-28T11:45:40.000Z</published>
    <updated>2016-08-28T11:52:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;a href=&quot;#存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot; class=&quot;headerlink&quot; title=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;/a&gt;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&lt;/h3&gt;&lt;p&gt;在Cocoa的术语中，一个检索对象属性值的方法提及为getter方法，或者”getter;”，一个改变对象属性值的方法提及为setter方法，或者“setter.”这些方法通常成对建立，提供获得或者设置对象属性值的API。&lt;/p&gt;
&lt;p&gt;我们应该使用存储方法而不是直接存储状态数据因为他们提供了一个抽象的层。下面是存储方法所提供的两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们不需要重写我们的代码如果一个描述或者存储属性的方法改变。&lt;/li&gt;
&lt;li&gt;存储方法常常实现重要行为是无论何时一个值被检索或者设置都会被重现。例如，设置方法频繁的实现内存管理代码并且通知其他对象当一个值被改变的时候。&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h3&gt;&lt;p&gt;给出一个属性的类型type和称呼name，我们应该通过下面的格式，典型的实现存储方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(type)name;
-(void)setName:(type)newName;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有个例外是属性为Boolean值。getter方法名字应该是isName。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(BOOL)isHidden;
-(void)setHidden:(BOOL)newHidden;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种命名惯例很重要因为在Cocoa中的很多其他的功能都依赖它，特别的key-value coding。Cocoa不使用getName因为以get开始的方法表明方法返回引用类型的值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) 报错：__NSCFString containsString:]: unrecognized selector sent to instance 0x7f876b79e160&lt;/p&gt;
&lt;p&gt; 原因：因为该属性提前释放了。&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) 报错：This application is modifying the autolayout engine from a background thread&lt;/p&gt;
&lt;p&gt;原因：把需要更新UI的放在的主线程就好了。（通过打印 [NSThreadcurrentThread],就可以知道当前不是在主线程;&lt;/p&gt;
&lt;p&gt; NSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys:@”value1”, @”key1”, @”value2”, @”key2”, nil];&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;w&lt;/em&gt;) Dealloc 时取 weak self 时崩溃  （&lt;a href=&quot;http://blog.csdn.net/kaihaodir/article/details/51586616）&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/kaihaodir/article/details/51586616）&lt;/a&gt;&lt;br&gt;    先上引起崩溃的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc
{
    __weak __typeof(self)weak_self = self;
    NSLog(@&amp;quot;%@&amp;quot;, weak_self);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明不允许在 dealloc 的时候取 weak self.&lt;/p&gt;
&lt;h3 id=&quot;获取当前年份和月份和天数&quot;&gt;&lt;a href=&quot;#获取当前年份和月份和天数&quot; class=&quot;headerlink&quot; title=&quot;获取当前年份和月份和天数&quot;&gt;&lt;/a&gt;获取当前年份和月份和天数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSCalendar *calendar = [NSCalendar currentCalendar];
unsigned unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit |  NSDayCalendarUnit;
NSDateComponents *components = [calendar components:unitFlags fromDate:[NSDate date]];
NSInteger iCurYear = [components year];  //当前的年份
NSInteger iCurMonth = [components month];  //当前的月份
NSInteger iCurDay = [components day];  // 当前的号数
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;根据传入的年份和月份获得该月份的天数&quot;&gt;&lt;a href=&quot;#根据传入的年份和月份获得该月份的天数&quot; class=&quot;headerlink&quot; title=&quot;根据传入的年份和月份获得该月份的天数&quot;&gt;&lt;/a&gt;根据传入的年份和月份获得该月份的天数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;/**  
 * 根据传入的年份和月份获得该月份的天数  
 *   
 * @param year  
 *            年份-正整数  
 * @param month  
 *            月份-正整数  
 * @return 返回天数  
 */    
public int getDayNumber(int year, int month) {    
    int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };    
    if (2 == month &amp;amp;&amp;amp; 0 == (year % 4) &amp;amp;&amp;amp; (0 != (year % 100) || 0 == (year % 400))) {    
        days[1] = 29;    
    }    
    return (days[month - 1]);    
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;a href=&quot;#存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot; class=&quot;headerlink&quot; title=&quot;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&quot;&gt;&lt;/a&gt;存储方法是一个可以获得或者设置一个对象的属性值的实例方法&lt;/h3&gt;&lt;p&gt;在Cocoa的术语中，一个检索对象属性值的方法提及为getter方法，或者”getter;”，一个改变对象属性值的方法提及为setter方法，或者“setter.”这些方法通常成对建立，提供获得或者设置对象属性值的API。&lt;/p&gt;
&lt;p&gt;我们应该使用存储方法而不是直接存储状态数据因为他们提供了一个抽象的层。下面是存储方法所提供的两个好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们不需要重写我们的代码如果一个描述或者存储属性的方法改变。&lt;/li&gt;
&lt;li&gt;存储方法常常实现重要行为是无论何时一个值被检索或者设置都会被重现。例如，设置方法频繁的实现内存管理代码并且通知其他对象当一个值被改变的时候。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>block的使用</title>
    <link href="http://yoursite.com/2016/08/28/block%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/08/28/block的使用/</id>
    <published>2016-08-28T11:40:33.000Z</published>
    <updated>2016-08-28T11:42:30.000Z</updated>
    
    <content type="html">&lt;p&gt;Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了.&lt;/p&gt;
&lt;h3 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;h4 id=&quot;As-a-local-variable&quot;&gt;&lt;a href=&quot;#As-a-local-variable&quot; class=&quot;headerlink&quot; title=&quot;As a local variable:&quot;&gt;&lt;/a&gt;As a local variable:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;As-a-property&quot;&gt;&lt;a href=&quot;#As-a-property&quot; class=&quot;headerlink&quot; title=&quot;As a property:&quot;&gt;&lt;/a&gt;As a property:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-a-method-parameter&quot;&gt;&lt;a href=&quot;#As-a-method-parameter&quot; class=&quot;headerlink&quot; title=&quot;As a method parameter:&quot;&gt;&lt;/a&gt;As a method parameter:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-an-argument-to-a-method-call&quot;&gt;&lt;a href=&quot;#As-an-argument-to-a-method-call&quot; class=&quot;headerlink&quot; title=&quot;As an argument to a method call:&quot;&gt;&lt;/a&gt;As an argument to a method call:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;[someObject someMethodThatTakesABlock:^returnType (parameters) {...}];
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;As-a-typedef&quot;&gt;&lt;a href=&quot;#As-a-typedef&quot; class=&quot;headerlink&quot; title=&quot;As a typedef:&quot;&gt;&lt;/a&gt;As a typedef:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;typedef returnType (^TypeName)(parameterTypes);
TypeName blockName = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;代码示例&quot;&gt;&lt;a href=&quot;#代码示例&quot; class=&quot;headerlink&quot; title=&quot;代码示例&quot;&gt;&lt;/a&gt;代码示例&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#import &amp;quot;ViewController.h&amp;quot;
@interface ViewController ()

@property (nonatomic, assign) void (^block)(NSString *);

@end

typedef void (^block)(NSString *);
typedef NSString *(^block2)(NSString *);

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    int (^num)(int) = ^(int a) {

        return a * 6;
    };
    NSLog(@&amp;quot;%d&amp;quot;, num(5));

    block b = ^(NSString *string) {

        NSLog(@&amp;quot;%@&amp;quot;, string);
    };
    b(@&amp;quot;4677646974&amp;quot;);

    block2 b2 = ^(NSString *string) {
        NSLog(@&amp;quot;%@&amp;quot;, string);
        return string;
    };
    NSLog(@&amp;quot;%@&amp;quot;, b2(@&amp;quot;456&amp;quot;));

    [self methodsBlock:^(NSString *block3) {

        NSLog(@&amp;quot;%@&amp;quot;, block3);
    }];

    [self methodsBlock2:^NSString *(NSString *block4) {

        NSLog(@&amp;quot;%@&amp;quot;, block4);
        return @&amp;quot;1&amp;quot;;
    }];
    NSLog(@&amp;quot;%@&amp;quot;, [self methodsBlock3:^NSString *(NSString *block5) {
        NSLog(@&amp;quot;%@&amp;quot;, block5);
        return @&amp;quot;2&amp;quot;;
    }]);

    int (^num2)(int, int, int, int, int, int, int) = ^(int a, int b, int c, int d, int e, int f, int g) {

        return a * b * c * d * e * f * g;
    };
    NSLog(@&amp;quot;num2 = %d&amp;quot;, num2(10, 2, 5, 1, 45, 4, 4));


}

- (void)methodsBlock:(void(^)(NSString *))block3 {

    block3(@&amp;quot;block3&amp;quot;);
}


- (void)methodsBlock2:(NSString *(^)(NSString *))block4 {

    block4(@&amp;quot;block4&amp;quot;);
    NSLog(@&amp;quot;%@&amp;quot;, block4(@&amp;quot;block4&amp;quot;));
}


- (NSString *)methodsBlock3:(NSString *(^ __nullable)(NSString *))block5 {

    block5(@&amp;quot;block5&amp;quot;);
    NSLog(@&amp;quot;block5 = %@&amp;quot;, block5(@&amp;quot;block5&amp;quot;));
    return @&amp;quot;block5&amp;quot;;
}
@end
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Block是一个C语言的特性，它就是C语言的函数指针，在使用中最多的就是进行函数回调或者事件传递，比如发送数据到服务器，等待服务器反馈是成功还是失败，此时block就派上用场了.&lt;/p&gt;
&lt;h3 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;h4 id=&quot;As-a-local-variable&quot;&gt;&lt;a href=&quot;#As-a-local-variable&quot; class=&quot;headerlink&quot; title=&quot;As a local variable:&quot;&gt;&lt;/a&gt;As a local variable:&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;returnType (^blockName)(parameterTypes) = ^returnType(parameters) {...};
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> 系统定位</title>
    <link href="http://yoursite.com/2016/08/28/%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%BD%8D/"/>
    <id>http://yoursite.com/2016/08/28/系统定位/</id>
    <published>2016-08-28T11:35:47.000Z</published>
    <updated>2016-08-28T11:37:19.000Z</updated>
    
    <content type="html">&lt;p&gt;首先导入CoreLocation.framework，然后再引入头文件#import&lt;/p&gt;
&lt;h3 id=&quot;定义属性&quot;&gt;&lt;a href=&quot;#定义属性&quot; class=&quot;headerlink&quot; title=&quot;定义属性&quot;&gt;&lt;/a&gt;定义属性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic , strong)CLLocationManager *locationManager;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;初始化定位服务&quot;&gt;&lt;a href=&quot;#初始化定位服务&quot; class=&quot;headerlink&quot; title=&quot;初始化定位服务&quot;&gt;&lt;/a&gt;初始化定位服务&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#pragma mark - 私有方法
///初始化定位服务
- (void)settupLocation
{
    self.locationManager = [[CLLocationManager alloc] init];
    self.locationManager.delegate = self;
    self.locationManager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;

    if ([CLLocationManager locationServicesEnabled] &amp;amp;&amp;amp;
        [CLLocationManager authorizationStatus] == kCLAuthorizationStatusAuthorizedWhenInUse) {
        //定位功能可用，开始定位
        [self.locationManager startUpdatingLocation];

    } else if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusNotDetermined) {
        //请求授权
        [self.locationManager requestWhenInUseAuthorization];

    } else if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied
              || [CLLocationManager authorizationStatus] == kCLAuthorizationStatusRestricted){
    }
    if (self.schoolStr.length &amp;lt; 2) {
        // 开始定位
        [_locationManager startUpdatingLocation];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;然后使用代理-CLLocationManagerDelegate&quot;&gt;&lt;a href=&quot;#然后使用代理-CLLocationManagerDelegate&quot; class=&quot;headerlink&quot; title=&quot;然后使用代理 CLLocationManagerDelegate&quot;&gt;&lt;/a&gt;然后使用代理 CLLocationManagerDelegate&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#pragma mark - &amp;lt;CLLocationManagerDelegate&amp;gt;
///成功定位
- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&amp;lt;CLLocation *&amp;gt; *)locations
{
    //经纬度信息
    CLLocation *location = [locations lastObject];

    //反地理编码
    CLGeocoder *geocoder = [[CLGeocoder alloc] init];
    [geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&amp;lt;CLPlacemark *&amp;gt; * _Nullable placemarks, NSError * _Nullable error) {
        //编码成功
        if (!error &amp;amp;&amp;amp; placemarks.count &amp;gt; 0) {
            //获取地址对象
            CLPlacemark *address = placemarks.firstObject;
            //获取城市名称
            NSMutableString *city = [NSMutableString stringWithString:address.locality];
            if ([city containsString:@&amp;quot;市&amp;quot;]) {
                [city deleteCharactersInRange:[city rangeOfString: @&amp;quot;市&amp;quot;]];
            }
            //显示定位信息
            self.schoolStr = city;
            [self.tableView reloadData];
            //停止定位
            [self.locationManager stopUpdatingLocation];

        } else {
            //编码失败
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;在Info-plist文件中添加如下配置：&quot;&gt;&lt;a href=&quot;#在Info-plist文件中添加如下配置：&quot; class=&quot;headerlink&quot; title=&quot;在Info.plist文件中添加如下配置：&quot;&gt;&lt;/a&gt;在Info.plist文件中添加如下配置：&lt;/h3&gt;&lt;p&gt;（1）NSLocationAlwaysUsageDescription&lt;br&gt;（2）NSLocationWhenInUseUsageDescription&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先导入CoreLocation.framework，然后再引入头文件#import&lt;/p&gt;
&lt;h3 id=&quot;定义属性&quot;&gt;&lt;a href=&quot;#定义属性&quot; class=&quot;headerlink&quot; title=&quot;定义属性&quot;&gt;&lt;/a&gt;定义属性&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;@property (nonatomic , strong)CLLocationManager *locationManager;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title> initWithNibName 和 loadNibNamed 的区别和联系</title>
    <link href="http://yoursite.com/2016/08/13/initWithNibName-%E5%92%8C-loadNibNamed-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2016/08/13/initWithNibName-和-loadNibNamed-的区别和联系/</id>
    <published>2016-08-13T11:13:03.000Z</published>
    <updated>2016-08-13T11:14:02.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;联系&quot;&gt;&lt;a href=&quot;#联系&quot; class=&quot;headerlink&quot; title=&quot;联系&quot;&gt;&lt;/a&gt;联系&lt;/h3&gt;&lt;p&gt; 可以使用此方法加载用户界面（xib文件）到我们的代码中，这样，可以通过操作这个加载进来的（xib）对象，来操作xib文件内容。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h3&gt;&lt;p&gt;1.集成类不一样&lt;/p&gt;
&lt;p&gt;initWithNibName要加载的xib的类为我们定义的视图控制器类&lt;br&gt;loadNibNamed要加载的xib的类为NSOjbect&lt;/p&gt;
&lt;p&gt;2.加载方式不同&lt;/p&gt;
&lt;p&gt;initWithNibName方法：是延迟加载，这个View上的控件是 nil 的，只有到 需要显示时，才会不是 nil&lt;br&gt;loadNibNamed方法：即时加载，用该方法加载的xib对象中的各个元素都已经存在。&lt;/p&gt;
&lt;h3 id=&quot;获取想要的-view&quot;&gt;&lt;a href=&quot;#获取想要的-view&quot; class=&quot;headerlink&quot; title=&quot;获取想要的 view&quot;&gt;&lt;/a&gt;获取想要的 view&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSArray* nib = [[NSBundle mainBundle] loadNibNamed／@&amp;quot;CustomCell&amp;quot; owner:self options:nil];
for(id item in nib) {

    if([is isKindOfClass:[youview class]]) {

    //找到了你自己需要得view
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;联系&quot;&gt;&lt;a href=&quot;#联系&quot; class=&quot;headerlink&quot; title=&quot;联系&quot;&gt;&lt;/a&gt;联系&lt;/h3&gt;&lt;p&gt; 可以使用此方法加载用户界面（xib文件）到我们的代码中，这样，可以通过操作这个加载进来的（xib）对象，来操作xib文件内容。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通知iOS</title>
    <link href="http://yoursite.com/2016/08/13/%E9%80%9A%E7%9F%A5iOS/"/>
    <id>http://yoursite.com/2016/08/13/通知iOS/</id>
    <published>2016-08-13T11:07:36.000Z</published>
    <updated>2016-08-13T11:09:38.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;发送通知-（在程序任何一个地方都可以发送通知）&quot;&gt;&lt;a href=&quot;#发送通知-（在程序任何一个地方都可以发送通知）&quot; class=&quot;headerlink&quot; title=&quot;发送通知 （在程序任何一个地方都可以发送通知）&quot;&gt;&lt;/a&gt;发送通知 （在程序任何一个地方都可以发送通知）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)getNotofocation {
    //发出通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;A类通知&amp;quot; object:self userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;注册通知&quot;&gt;&lt;a href=&quot;#注册通知&quot; class=&quot;headerlink&quot; title=&quot;注册通知&quot;&gt;&lt;/a&gt;注册通知&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserver: self selector: @selector(callBack) name: @&amp;quot;A类通知&amp;quot;  object: nil  userInfo: nil];

Name: 消息名称 
object: 消息发送者 
userInfo: 消息传递的数据信息
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;定义回调&quot;&gt;&lt;a href=&quot;#定义回调&quot; class=&quot;headerlink&quot; title=&quot;定义回调&quot;&gt;&lt;/a&gt;定义回调&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)callBack {

    NSLog(@&amp;quot;我收到通知了！&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;注销通知&quot;&gt;&lt;a href=&quot;#注销通知&quot; class=&quot;headerlink&quot; title=&quot;注销通知&quot;&gt;&lt;/a&gt;注销通知&lt;/h3&gt;&lt;p&gt;   a. 最优的方法，在 UIViewController.m 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)dealloc {

 [[NSNotificationCenter defaultCenter] removeObserver:self];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   b. 单个移除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] removeObserver:self name:@&amp;quot;Notification_GetUserProfileSuccess&amp;quot; object:nil];
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;发送通知-（在程序任何一个地方都可以发送通知）&quot;&gt;&lt;a href=&quot;#发送通知-（在程序任何一个地方都可以发送通知）&quot; class=&quot;headerlink&quot; title=&quot;发送通知 （在程序任何一个地方都可以发送通知）&quot;&gt;&lt;/a&gt;发送通知 （在程序任何一个地方都可以发送通知）&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;- (void)getNotofocation {
    //发出通知
    [[NSNotificationCenter defaultCenter] postNotificationName:@&amp;quot;A类通知&amp;quot; object:self userInfo:nil];
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>控制器初始化方法</title>
    <link href="http://yoursite.com/2016/08/13/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/08/13/控制器初始化方法/</id>
    <published>2016-08-13T11:03:07.000Z</published>
    <updated>2016-08-13T11:06:34.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;控制器初始化方法&quot;&gt;&lt;a href=&quot;#控制器初始化方法&quot; class=&quot;headerlink&quot; title=&quot;控制器初始化方法&quot;&gt;&lt;/a&gt;控制器初始化方法&lt;/h3&gt;&lt;h4 id=&quot;viewWillAppear&quot;&gt;&lt;a href=&quot;#viewWillAppear&quot; class=&quot;headerlink&quot; title=&quot;viewWillAppear&quot;&gt;&lt;/a&gt;viewWillAppear&lt;/h4&gt;&lt;p&gt;视图即将可见时调用。默认情况下不执行任何操作。 Called when the view is about to made visible. Default does nothing&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;viewDidAppear&quot;&gt;&lt;a href=&quot;#viewDidAppear&quot; class=&quot;headerlink&quot; title=&quot;viewDidAppear&quot;&gt;&lt;/a&gt;viewDidAppear&lt;/h4&gt;&lt;p&gt;视图已完全过渡到屏幕上时调用。。默认情况下不执行任何操作。 Called when the view has been fully transitioned onto the screen. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewWillDisappear&quot;&gt;&lt;a href=&quot;#viewWillDisappear&quot; class=&quot;headerlink&quot; title=&quot;viewWillDisappear&quot;&gt;&lt;/a&gt;viewWillDisappear&lt;/h4&gt;&lt;p&gt;视图被消失时调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作。 Called when the view is dismissed, covered or otherwise hidden. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewDidDisappear&quot;&gt;&lt;a href=&quot;#viewDidDisappear&quot; class=&quot;headerlink&quot; title=&quot;viewDidDisappear&quot;&gt;&lt;/a&gt;viewDidDisappear&lt;/h4&gt;&lt;p&gt;视图被消失后调用，覆盖或以其他方式隐藏。默认情况下不执行任何操作。 Called after the view was dismissed, covered or otherwise hidden. Default does nothing&lt;/p&gt;
&lt;h4 id=&quot;viewDidLoad&quot;&gt;&lt;a href=&quot;#viewDidLoad&quot; class=&quot;headerlink&quot; title=&quot;viewDidLoad&quot;&gt;&lt;/a&gt;viewDidLoad&lt;/h4&gt;&lt;p&gt;在视图加载后被调用，如果是在代码中创建的视图加载器，他将会在loadView方法后被调用，如果是从nib视图页面输出，他将会在视图设置好后后被调用。&lt;br&gt;Called after the view has been loaded. For view controllers created in code, this is after -loadView. For view controllers unarchived from a nib, this is after the view is set.&lt;/p&gt;
&lt;h4 id=&quot;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot;&gt;&lt;a href=&quot;#「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot; class=&quot;headerlink&quot; title=&quot;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&quot;&gt;&lt;/a&gt;「didReceiveMemoryWarning」收到系统传来的内存警告通知后会执行的方法&lt;/h4&gt;&lt;h4 id=&quot;视图控制器发生旋转调用的方法&quot;&gt;&lt;a href=&quot;#视图控制器发生旋转调用的方法&quot; class=&quot;headerlink&quot; title=&quot;视图控制器发生旋转调用的方法&quot;&gt;&lt;/a&gt;视图控制器发生旋转调用的方法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&amp;lt;UIViewControllerTransitionCoordinator&amp;gt;)coordinator {

     NSLog(@&amp;quot;%f&amp;quot;, size.height);
 }  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;当一个视图控制器被创建，并在屏幕上显示的时候。-代码的执行顺序&quot;&gt;&lt;a href=&quot;#当一个视图控制器被创建，并在屏幕上显示的时候。-代码的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序&quot;&gt;&lt;/a&gt;当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、 alloc                   创建对象，分配空间

2、init (initWithNibName)    初始化对象，初始化数据

3、loadView                  从nib载入视图 ，通常这一步不需要去干涉。除非你没有使用xib文件创建视图

4、viewDidLoad               载入完成，可以进行自定义数据以及动态创建其他控件

5、viewWillAppear            视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了

6、viewDidAppear             视图已在屏幕上渲染完成
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot;&gt;&lt;a href=&quot;#当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot; class=&quot;headerlink&quot; title=&quot;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&quot;&gt;&lt;/a&gt;当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、viewWillDisappear          视图将被从屏幕上移除之前执行

2、viewDidDisappear           视图已经被从屏幕上移除，用户看不到这个视图了

3、dealloc                    视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;控制器初始化方法&quot;&gt;&lt;a href=&quot;#控制器初始化方法&quot; class=&quot;headerlink&quot; title=&quot;控制器初始化方法&quot;&gt;&lt;/a&gt;控制器初始化方法&lt;/h3&gt;&lt;h4 id=&quot;viewWillAppear&quot;&gt;&lt;a href=&quot;#viewWillAppear&quot; class=&quot;headerlink&quot; title=&quot;viewWillAppear&quot;&gt;&lt;/a&gt;viewWillAppear&lt;/h4&gt;&lt;p&gt;视图即将可见时调用。默认情况下不执行任何操作。 Called when the view is about to made visible. Default does nothing&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>响应者</title>
    <link href="http://yoursite.com/2016/08/07/%E5%93%8D%E5%BA%94%E8%80%85/"/>
    <id>http://yoursite.com/2016/08/07/响应者/</id>
    <published>2016-08-07T11:25:04.000Z</published>
    <updated>2016-08-07T11:27:33.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;响应者对象（Response-object）&quot;&gt;&lt;a href=&quot;#响应者对象（Response-object）&quot; class=&quot;headerlink&quot; title=&quot;响应者对象（Response object）&quot;&gt;&lt;/a&gt;响应者对象（Response object）&lt;/h3&gt;&lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;第一响应者（First-responder）&quot;&gt;&lt;a href=&quot;#第一响应者（First-responder）&quot; class=&quot;headerlink&quot; title=&quot;第一响应者（First responder）&quot;&gt;&lt;/a&gt;第一响应者（First responder）&lt;/h3&gt;&lt;p&gt;当前接受触摸的响应者对象被称为第一响应者，即表示当前该对象正在与用户交互，它是响应者链的开端。&lt;/p&gt;
&lt;h3 id=&quot;响应者链（Responder-chain）&quot;&gt;&lt;a href=&quot;#响应者链（Responder-chain）&quot; class=&quot;headerlink&quot; title=&quot;响应者链（Responder chain）&quot;&gt;&lt;/a&gt;响应者链（Responder chain）&lt;/h3&gt;&lt;p&gt;响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者（next responder）。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件被交由它处理，如果它不处理，事件就会被传递给它的视图控制器对象（如果存在），然后是它的父视图（superview）对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图（top view）到窗口（UIWindow对象）再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件就被丢弃。一般情况下，在响应者链中只要由对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件&lt;/p&gt;
&lt;h3 id=&quot;管理事件分发&quot;&gt;&lt;a href=&quot;#管理事件分发&quot; class=&quot;headerlink&quot; title=&quot;管理事件分发&quot;&gt;&lt;/a&gt;管理事件分发&lt;/h3&gt;&lt;p&gt;视图对触摸事件是否需要作处回应可以通过设置视图的userInteractionEnabled属性。默认状态为YES，如果设置为NO，可以阻止视图接收和分发触摸事件。除此之外，当视图被隐藏（setHidden：YES）或者透明（alpha值为0）也不会收事件。不过这个属性只对视图有效，如果想要整个程序都步响应事件，可以调用UIApplication的beginIngnoringInteractionEvents方法来完全停止事件接收和分发。通过endIngnoringInteractionEvents方法来恢复让程序接收和分发事件。如果要让视图接收多点触摸，需要设置它的multipleTouchEnabled属性为YES，默认状态下这个属性值为NO，即视图默认不接收多点触摸。&lt;/p&gt;
&lt;h3 id=&quot;处理用户的触摸事件&quot;&gt;&lt;a href=&quot;#处理用户的触摸事件&quot; class=&quot;headerlink&quot; title=&quot;处理用户的触摸事件&quot;&gt;&lt;/a&gt;处理用户的触摸事件&lt;/h3&gt;&lt;p&gt;首先触摸的对象是视图，而视图的类UIView继承了UIRespnder类，但是要对事件作出处理，还需要重写UIResponder类中定义的事件处理函数。根据不通的触摸状态，程序会调用相应的处理函数，这些函数包括以下几个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;

-(void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;

当手指接触屏幕时，就会调用touchesBegan:withEvent方法；

当手指在屏幕上移时，动就会调用touchesMoved:withEvent方法；

当手指离开屏幕时，就会调用touchesEnded:withEvent方法；

当触摸被取消（比如触摸过程中被来电打断），就会调用touchesCancelled:withEvent方法。而这几个方法被调用时，正好对应了UITouch类中phase属性的4个枚举值。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的四个事件方法，在开发过程中并不要求全部实现，可以根据需要重写特定的方法。对于这4个方法，都有两个相同的参数：NSSet类型的touches和UIEvent类型的event。其中touches表示触摸产生的所有UITouch对象，而event表示特定的事件。因为UIEvent包含了整个触摸过程中所有的触摸对象，因此可以调用allTouches方法获取该事件内所有的触摸对象，也可以调用touchesForVIew：或者touchesForWindows：取出特定视图或者窗口上的触摸对象。在这几个事件中，都可以拿到触摸对象，然后根据其位置，状态，时间属性做逻辑处理。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;响应者对象（Response-object）&quot;&gt;&lt;a href=&quot;#响应者对象（Response-object）&quot; class=&quot;headerlink&quot; title=&quot;响应者对象（Response object）&quot;&gt;&lt;/a&gt;响应者对象（Response object）&lt;/h3&gt;&lt;p&gt;响应者对象就是可以响应事件并对事件作出处理。在iOS中，存在UIResponder类，它定义了响应者对象的所有方法。UIApplication、UIView等类都继承了UIResponder类，UIWindow和UIKit中的控件因为继承了UIView，所以也间接继承了UIResponder类，这些类的实例都可以当作响应者&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>定时器用法总结</title>
    <link href="http://yoursite.com/2016/08/07/%E5%AE%9A%E6%97%B6%E5%99%A8%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/08/07/定时器用法总结/</id>
    <published>2016-08-07T11:18:19.000Z</published>
    <updated>2016-08-07T11:19:17.000Z</updated>
    
    <content type="html">&lt;p&gt;NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下：&lt;/p&gt;
&lt;h3 id=&quot;方法-1&quot;&gt;&lt;a href=&quot;#方法-1&quot; class=&quot;headerlink&quot; title=&quot;方法 1&quot;&gt;&lt;/a&gt;方法 1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSInvocation *invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(f)]];
[invo setTarget:self];
[invo setSelector:@selector(myLog)];
time = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES];
[time fire];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;方法-2&quot;&gt;&lt;a href=&quot;#方法-2&quot; class=&quot;headerlink&quot; title=&quot;方法 2&quot;&gt;&lt;/a&gt;方法 2&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;time = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
[time fire];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法-3&quot;&gt;&lt;a href=&quot;#方法-3&quot; class=&quot;headerlink&quot; title=&quot;方法 3&quot;&gt;&lt;/a&gt;方法 3&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;time = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(myLog) userInfo:nil repeats:YES];
[time fire];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法-4&quot;&gt;&lt;a href=&quot;#方法-4&quot; class=&quot;headerlink&quot; title=&quot;方法 4&quot;&gt;&lt;/a&gt;方法 4&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSInvocation *invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(myLog)]];
[invo setTarget:self];
[invo setSelector:@selector(myLog)];
time = [NSTimer scheduledTimerWithTimeInterval:1 invocation:invo repeats:YES];
[time fire];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;方法-5&quot;&gt;&lt;a href=&quot;#方法-5&quot; class=&quot;headerlink&quot; title=&quot;方法 5&quot;&gt;&lt;/a&gt;方法 5&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;time = [[NSTimer alloc] initWithFireDate:[NSDate date] interval:1 target:self selector:@selector(myLog) userInfo:nil repeats:YES];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;关于内存释放&quot;&gt;&lt;a href=&quot;#关于内存释放&quot; class=&quot;headerlink&quot; title=&quot;关于内存释放&quot;&gt;&lt;/a&gt;关于内存释放&lt;/h3&gt;&lt;p&gt;   如果我们启动了一个定时器，在某个界面释放前，将这个定时器停止，甚至置为nil，都不能是这个界面释放，原因是系统的循环池中还保有这个对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[timer invalidate];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   在官方文档中我们可以看到 [timer invalidate]是唯一的方法将定时器从循环池中移除。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;NSTimer在IOS开发中会经常用到，尤其是小型游戏，然而对于初学者时常会注意不到其中的内存释放问题，将其基本用法总结如下：&lt;/p&gt;
&lt;h3 id=&quot;方法-1&quot;&gt;&lt;a href=&quot;#方法-1&quot; class=&quot;headerlink&quot; title=&quot;方法 1&quot;&gt;&lt;/a&gt;方法 1&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSInvocation *invo = [NSInvocation invocationWithMethodSignature:[[self class] instanceMethodSignatureForSelector:@selector(f)]];
[invo setTarget:self];
[invo setSelector:@selector(myLog)];
time = [NSTimer timerWithTimeInterval:1 invocation:invo repeats:YES];
[time fire];
[[NSRunLoop mainRunLoop] addTimer:time forMode:NSDefaultRunLoopMode];
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Objective-C 中实现多线程</title>
    <link href="http://yoursite.com/2016/08/07/Objective-C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/07/Objective-C-中实现多线程/</id>
    <published>2016-08-07T11:13:29.000Z</published>
    <updated>2016-08-07T11:17:16.000Z</updated>
    
    <content type="html">&lt;p&gt;在多核 CPU 时代，由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。&lt;/p&gt;
&lt;h3 id=&quot;performSelectors&quot;&gt;&lt;a href=&quot;#performSelectors&quot; class=&quot;headerlink&quot; title=&quot;performSelectors&quot;&gt;&lt;/a&gt;performSelectors&lt;/h3&gt;&lt;p&gt; NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在指定线程中，或者立即，或者延迟执行某个方法调用。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)performSelector:(SEL)aSelector
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument withObject:(id)anArgument
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay
- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay: (NSTimeInterval)delay inModes:(NSArray *)modes

// 在指定线程中执行方法
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject:(id)arg waitUntilDone:(BOOL)wait
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thread withObject: (id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array
// 在主线程中执行方法
- (void)performSelectorOnMainThread: (SEL)selector withObject:(id)argument waitUntilDone:(BOOL)wait
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait modes:(NSArray *)array

// 在后台线程中执行方法
- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  这一系列方法简单易用:指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。&lt;/p&gt;
&lt;h3 id=&quot;NSThread&quot;&gt;&lt;a href=&quot;#NSThread&quot; class=&quot;headerlink&quot; title=&quot;NSThread&quot;&gt;&lt;/a&gt;NSThread&lt;/h3&gt;&lt;p&gt;   NSThread 是 OS X 和 iOS 都提供的一个线程对象，它是线程的一个轻量级实现。在执行一些轻量级的简单任务时，NSThread 很有用，但用户仍然需要自己管理线程生命周期，进行线程间同步。比如，线程状态，依赖性，线程间同步等线程相关的主题 NSThread 都没有涉及。比如，涉及到线程间同步仍然需要配合使用 NSLock，NSCondition 或者 @synchronized。所以，遇到复杂任务时，轻量级的 NSThread 可能并不合适。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)run {
    while (TRUE) {
        [_lock lock];
        if(_cake &amp;gt; 0){
            [NSThread sleepForTimeInterval:0.5];
            _cake--;
            _occupied = kSum - _cake;
            NSLog(@&amp;quot;Taken by %@\nCurrent free:%ld, occupied: %ld&amp;quot;, [[NSThread currentThread] name], _cake, _occupied);
        }
        [_lock unlock];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;NSOperation&quot;&gt;&lt;a href=&quot;#NSOperation&quot; class=&quot;headerlink&quot; title=&quot;NSOperation&quot;&gt;&lt;/a&gt;NSOperation&lt;/h3&gt;&lt;p&gt;NSOperation 做的事情比 NSThread 更多一些。通过继承 NSOperation，可以使子类获得一些线程相关的特性，进而可以安全地管理线程生命周期。&lt;br&gt;比如，以线程安全的方式建立状态，取消线程。配合 NSOperationQueue，可以控制线程间的优先级和依赖性。这就给出了一套线程管理的基本方法。NSOperation 代表了一个独立的计算单元。一般，我们会把计算任务封装进 NSOperation 这个对象。NSOperation 是抽象类，但同时也提供了两个可以直接使用的实体子类：NSInvocationOperation 和 NSBlockOperation。NSInvocationOperation 用于将计算任务封装进方法，NSBlockOperation 用于将计算任务封装进 block。NSOperationQueue 则用于执行计算任务，管理计算任务的优先级，处理计算任务之间的依赖性。NSOperation 被添加到 NSOperationQueue 中之后，队列会按优先级和进入顺序调度任务，NSOperation 对象会被自动执行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;NSOperation 提供以下任务优先级，以这些优先级设置变量 queuePriority 即可加快或者推迟操作的执行：
NSOperationQueuePriorityVeryHigh
NSOperationQueuePriorityHigh
NSOperationQueuePriorityNormal
NSOperationQueuePriorityLow
NSOperationQueuePriorityVeryLow

NSOperation 使用状态机模型来表示状态。通常，你可以使用 KVO（Key-Value Observing）观察任务的执行状态。这是其他多线程工具所不具备的功能。NSOperation 提供以下状态：
    isReady
    isExecuting
    isFinished
NSOperation 对象之间的依赖性可以用如下代码表示：
 [refreshUIOperation addDependency:requestDataOperation]; [operationQueue addOperation:requestDataOperation]; [operationQueue addOperation:refreshUIOperation];
除非 requestDataOperation 的状态 isFinished 返回 YES，不然 refreshUIOperation 这个操作不会开始。
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;在多核 CPU 时代，由于硬件上就支持多线程技术，就可以让多个线程真正同时地运行。如果任务能够被拆分，各个子任务就能并行地在 CPU 上运行，这就能显著加快运行速度。&lt;/p&gt;
&lt;h3 id=&quot;performSelectors&quot;&gt;&lt;a href=&quot;#performSelectors&quot; class=&quot;headerlink&quot; title=&quot;performSelectors&quot;&gt;&lt;/a&gt;performSelectors&lt;/h3&gt;&lt;p&gt; NSObject 提供了以 performSelector 为前缀的一系列方法。它们可以让用户在指定线程中，或者立即，或者延迟执行某个方法调用。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS特别技能点总结4</title>
    <link href="http://yoursite.com/2016/08/07/iOS%E7%89%B9%E5%88%AB%E6%8A%80%E8%83%BD%E7%82%B9%E6%80%BB%E7%BB%934/"/>
    <id>http://yoursite.com/2016/08/07/iOS特别技能点总结4/</id>
    <published>2016-08-07T11:06:12.000Z</published>
    <updated>2016-08-07T11:10:29.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot;&gt;&lt;a href=&quot;#iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot; class=&quot;headerlink&quot; title=&quot;iOS－获取的NSDate date时间与实际相差8个小时解决方案&quot;&gt;&lt;/a&gt;iOS－获取的NSDate date时间与实际相差8个小时解决方案&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDate *date = [NSDate date];
NSTimeZone *zone = [NSTimeZone systemTimeZone];
NSInteger interval = [zone secondsFromGMTForDate: date];
NSDate *localeDate = [date  dateByAddingTimeInterval: interval]; 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;iOS编程-XCode-Debug忽略SIGPIPE信号&quot;&gt;&lt;a href=&quot;#iOS编程-XCode-Debug忽略SIGPIPE信号&quot; class=&quot;headerlink&quot; title=&quot;iOS编程-XCode Debug忽略SIGPIPE信号&quot;&gt;&lt;/a&gt;iOS编程-XCode Debug忽略SIGPIPE信号&lt;/h3&gt;&lt;p&gt;在 main.m 中添加&lt;br&gt;     signal(SIGPIPE, SIG_IGN);&lt;br&gt;debug的时候, 忽略SIGPIPE是不起作用的. &lt;/p&gt;
&lt;h3 id=&quot;UITableView最上面tableHeaderView留空间的两种方法&quot;&gt;&lt;a href=&quot;#UITableView最上面tableHeaderView留空间的两种方法&quot; class=&quot;headerlink&quot; title=&quot;UITableView最上面tableHeaderView留空间的两种方法&quot;&gt;&lt;/a&gt;UITableView最上面tableHeaderView留空间的两种方法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. UIView *headerView = [[UIView alloc] initWithFrame: CGRectMake(0, 0, 320, 44)];
   m_tableView.tableHeaderView = headerView;

2. m_tableView.contentInset = UIEdgeInsetsMake(44, 0, 0, 0);
   m_tableView.scrollIndicatorInsets = UIEdgeInsetsMake(44, 0, 0, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;iOS-函数&quot;&gt;&lt;a href=&quot;#iOS-函数&quot; class=&quot;headerlink&quot; title=&quot;iOS 函数&quot;&gt;&lt;/a&gt;iOS 函数&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;// ceil：如果参数是小数，则求最小的整数但不小于本身
NSLog(@&amp;quot;%f&amp;quot;,  ceilf(1.0000002)); // 7
NSLog(@&amp;quot;%f&amp;quot;,   ceil(1.000000000000001)); // 15
NSLog(@&amp;quot;%Lf&amp;quot;, ceill(1.000000000000001)); // 15

// round：如果参数是小数，则求本身的四舍五入。
NSLog(@&amp;quot;%f&amp;quot;, round(10.0000000004));
NSLog(@&amp;quot;%f&amp;quot;, roundf(10.5));
NSLog(@&amp;quot;%Lf&amp;quot;, roundl(10));

// floor：如果参数是小数，则求最大的整数但不大于本身.
NSLog(@&amp;quot;%f&amp;quot;, floor(10.00001));
NSLog(@&amp;quot;%f&amp;quot;, floorf(12.4));
NSLog(@&amp;quot;%Lf&amp;quot;, floorl(10.54));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;ios9中设置状态栏颜色与隐藏&quot;&gt;&lt;a href=&quot;#ios9中设置状态栏颜色与隐藏&quot; class=&quot;headerlink&quot; title=&quot;ios9中设置状态栏颜色与隐藏&quot;&gt;&lt;/a&gt;ios9中设置状态栏颜色与隐藏&lt;/h3&gt;&lt;p&gt;1.iOS中设置状态栏的样式由 最顶层的UIWindow所在的控制器控制处理。&lt;br&gt;2.ios9之前可以不用设置window的根控制器，ios9必须设置根控制器。&lt;br&gt;3.ios9后设置状态栏的样式(隐藏)时，在最顶层的UIWindow所在的控制器中通过下面两个方法处理  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UIStatusBarStyle)preferredStatusBarStyle {   //设置样式
 return  UIStatusBarStyleLightContent;
}

- (BOOL)prefersStatusBarHidden { //设置隐藏显示
 return NO;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   通过&lt;br&gt;    [[UIApplication sharedApplication] setStatusBarHidden:BOOL];&lt;br&gt;    [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyle)];&lt;br&gt;   设置不太好使。&lt;br&gt;4.ios9中如果创建多个window，则改变状态栏的样式，只能在最顶层的window中的控制器中设置状态栏样式才有效。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;例如：设置两个Window,通过在最顶层的window中的控制器中设置状态栏样式更改转态栏
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot;&gt;&lt;a href=&quot;#iOS－获取的NSDate-date时间与实际相差8个小时解决方案&quot; class=&quot;headerlink&quot; title=&quot;iOS－获取的NSDate date时间与实际相差8个小时解决方案&quot;&gt;&lt;/a&gt;iOS－获取的NSDate date时间与实际相差8个小时解决方案&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;NSDate *date = [NSDate date];
NSTimeZone *zone = [NSTimeZone systemTimeZone];
NSInteger interval = [zone secondsFromGMTForDate: date];
NSDate *localeDate = [date  dateByAddingTimeInterval: interval]; 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多种方式搭建tableViewCell</title>
    <link href="http://yoursite.com/2016/07/30/%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%90%AD%E5%BB%BAtableViewCell/"/>
    <id>http://yoursite.com/2016/07/30/多种方式搭建tableViewCell/</id>
    <published>2016-07-30T13:46:44.000Z</published>
    <updated>2016-07-30T13:52:22.000Z</updated>
    
    <content type="html">&lt;p&gt;创建 UITableViewCell 的方式主要有四种，使用系统自带的 cell 样式，自定义的继承 UITableViewCell 的方式 ， xib 创建 cell 和 sb 中创建 cell。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;简单的代码添加&quot;&gt;&lt;a href=&quot;#简单的代码添加&quot; class=&quot;headerlink&quot; title=&quot;简单的代码添加&quot;&gt;&lt;/a&gt;简单的代码添加&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//直接在UITableViewCell的生成方法中实现，代码如下
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *identifier = @&amp;quot;cell&amp;quot;;
    UITableViewCell  *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
    if (cell == nil) {

        cell = [[UITableViewCell  alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
        UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(190, 0, 130, cell.frame.size.height)];
        label1.tag = 1;
        [cell.contentView addSubview:label1];
    }
    UILabel *label3 = (UILabel *)[cell.contentView viewWithTag:1];
    label3.text = @&amp;quot;44444&amp;quot;;
    return cell;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自定义的继承UITableViewCell的类&quot;&gt;&lt;a href=&quot;#自定义的继承UITableViewCell的类&quot; class=&quot;headerlink&quot; title=&quot;自定义的继承UITableViewCell的类&quot;&gt;&lt;/a&gt;自定义的继承UITableViewCell的类&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;.h
   @interface Cell3 : UITableViewCell {

       UILabel *_label1;
       UILabel *_label2;
   }

   - (void)setLabel1Text:(NSString *)text1
              label2Text:(NSString *)text2;

   @end

.m
   @implementation Cell3

   - (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
   {
       self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
       if (self) {

           _label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 160, self.frame.size.height)];
           [self.contentView addSubview:_label1];
           _label2 = [[UILabel alloc] initWithFrame:CGRectMake(160, 0, 160, self.frame.size.height)];
           [self.contentView addSubview:_label2];
       }
       return self;
   }

   - (void)setLabel1Text:(NSString *)text1 label2Text:(NSString *)text2
   {
       _label1.text = text1;
       _label2.text = text2;
   }

控制器中的写法

   - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
   {
       static NSString *identifier = @&amp;quot;cell&amp;quot;;
       Cell3 *cell = [tableView dequeueReusableCellWithIdentifier:identifier];
       if (cell == nil) {

           cell = [[Cell3 alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:identifier];
       }
       [cell setLabel1Text:@&amp;quot;2222&amp;quot; label2Text:@&amp;quot;3333&amp;quot;];
       return cell;
   }
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;xib-创建-cell&quot;&gt;&lt;a href=&quot;#xib-创建-cell&quot; class=&quot;headerlink&quot; title=&quot;xib 创建 cell&quot;&gt;&lt;/a&gt;xib 创建 cell&lt;/h3&gt;&lt;p&gt;  1.先在 xib 中设置 Identifier 设置&lt;/p&gt;
&lt;p&gt;  2.声明 [self.tableView registerNib:[UINib nibWithNibName:@”Cell2” bundle:[NSBundle mainBundle]] forCellReuseIdentifier:@”Cell2”];&lt;/p&gt;
&lt;p&gt;  3.在控制器的 UITableView 代理中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {

      Cell2 *cell = [tableView dequeueReusableCellWithIdentifier:@&amp;quot;Cell2&amp;quot;];
      cell.numLabe.text = @&amp;quot;123&amp;quot;;
      return cell;
   }
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;创建 UITableViewCell 的方式主要有四种，使用系统自带的 cell 样式，自定义的继承 UITableViewCell 的方式 ， xib 创建 cell 和 sb 中创建 cell。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
